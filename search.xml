<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>顺序表与链表</title>
    <url>/2021/01/01/0002.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="顺序表与链表"><a href="#顺序表与链表" class="headerlink" title="顺序表与链表"></a>顺序表与链表</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>【基础数据结构】课程综述<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306091824.png" alt="图片"></li>
<li>重点掌握红色！</li>
</ul>
</li>
<li>三个等式<ul>
<li>程序 = 算法 + 数据结构</li>
<li>程序设计 = 算法 + 数据结构 + 编程范式</li>
<li><strong>数据结构 = 结构定义 + 结构操作</strong></li>
</ul>
</li>
<li>通过算法与数据结构，使计算机合理利用资源，让计算资源更有价值</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>【功能更高级的数组】</p>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a><strong>结构定义</strong></h3><ul>
<li><p>空间连续，可以存储任意类型的</p>
<p>相同</p>
<p>元素</p>
<ul>
<li>顺序表里也可以存顺序表</li>
</ul>
</li>
<li><p>size：顺序表的空间大小</p>
</li>
<li><p>length：已存储的元素个数</p>
</li>
<li><p>data_type：存储的元素类型</p>
</li>
</ul>
<h3 id="结构操作"><a href="#结构操作" class="headerlink" title="结构操作"></a><strong>结构操作</strong></h3><ul>
<li><p>插入</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092124.png" alt="图片"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092128.png" alt="图片"></li>
<li>不能空着插，必须连续</li>
<li>插入位置后的所有元素向后移动一位<ul>
<li><strong>从后开始</strong>移动，每个元素向后移动一位</li>
</ul>
</li>
<li>必须要改变的属性：length + 1<ul>
<li>size有可能需要改变，扩容请看下面</li>
</ul>
</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092134.png" alt="图片"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092144.png" alt="图片"></li>
<li>不是真的删除，而是告诉系统这个地址的存储区可以被占用、被覆盖</li>
<li>将后面所有的元素整体向前移动一位<ul>
<li>相当于要删除的位置的值被覆写</li>
<li>最后一个值怎么覆写？<ul>
<li>直接将length - 1</li>
<li>其实都可以自定义设计</li>
</ul>
</li>
</ul>
</li>
<li>必须要改变的属性：length - 1</li>
</ul>
</li>
<li><p>添加扩容操作</p>
<ul>
<li>动态内存分配函数</li>
<li>malloc：只是开辟空间，值不确定。举例：开房没有保洁阿姨<ul>
<li>calloc：开辟空间，并且初始化。举例：开房后有保洁阿姨打扫清理</li>
<li>realloc：重新开辟空间。举例：升级房型</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> void* realloc (void* ptr, size_t size); // 返回新开辟空间的首地址</p>
</blockquote>
<p><strong>3种情况【realloc】</strong></p>
<ol>
<li>先试探能不能在原地址后面直接加空间，空间首地址不变；如果不行，</li>
<li>换个地址找找，申请空间，然后把原空间数据拷贝到新空间，并free掉原空间；如果不行，（自己可以设计减少扩容）</li>
<li>就返回空地址，不清空当前地址</li>
</ol>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>初始化、销毁<ul>
<li>使用malloc开辟空间初始化该结构</li>
<li>从结构里到外free，再将指针置空</li>
</ul>
</li>
<li>扩容操作<ul>
<li>realloc返回地址先赋给中间变量，避免返回NULL的情况，导致原数据迷失</li>
<li>realloc成功后原地址空间自动被free</li>
<li>可设计折半减小的扩容空间，直到确实一点空间都不剩返回失败标志0</li>
</ul>
</li>
<li>插入、删除<ul>
<li>注意不能操作的情况</li>
<li>插入满员时，进行扩容操作</li>
</ul>
</li>
<li>打印输出</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a, b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义结构体类型，并命名为 Vec</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;         <span class="comment">// 数据首地址，存放 int 型顺序表</span></span><br><span class="line">    <span class="keyword">int</span> size, length;  <span class="comment">// size:容量  length:元素个数</span></span><br><span class="line">&#125; Vec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function">Vec *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Vec *v = (Vec *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vec));        <span class="comment">// 给顺序表结构开辟一个空间 </span></span><br><span class="line">    v-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);   <span class="comment">// 开辟一个容量为 n 的空间</span></span><br><span class="line">    v-&gt;size = n;</span><br><span class="line">    v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vec *v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不能直接返回 realloc 的结果，因为 realloc 可能会失败，一旦失败就会把丢失原本的所有数据</span></span><br><span class="line">    <span class="keyword">int</span> extr_size = v-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="comment">// 尝试开辟，失败则 p = NULL，则减小扩容大小再重新尝试开辟</span></span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (v-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">break</span>; </span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(extr_size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开辟成功，转移空间地址后，realloc 会自动释放空间</span></span><br><span class="line">    v-&gt;data = p;</span><br><span class="line">    v-&gt;size += extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vec *v, <span class="keyword">int</span> val, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空间满时，扩容</span></span><br><span class="line">    <span class="keyword">if</span>(v-&gt;length == v-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(v)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;success to expand ! the Vector size is %d\n&quot;</span>), v-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = v-&gt;length; i &gt; ind; i--) &#123;</span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;data[ind] = val;</span><br><span class="line">    v-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vec *v, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ind + <span class="number">1</span>; i &lt; v-&gt;length; i++) &#123;</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vec *v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vec *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Vector : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v-&gt;length; i++)&#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Vec *v = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = rand() % (v-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to Vector = %d\n&quot;</span>, val, ind,insert(v, val, ind));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;erase a iterm at %d frim Vector = %d\n&quot;</span>, ind, erase(v, ind));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(v);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="结构定义-1"><a href="#结构定义-1" class="headerlink" title="结构定义"></a><strong>结构定义</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092208.png" alt="图片"></p>
<ul>
<li>程序内部 + 内存内部<ul>
<li>【程序内部】只暴露头指针<ul>
<li>头指针：记录第一个结点的地址</li>
</ul>
</li>
<li>【内存内部】是连接的结点<ul>
<li>结点：数据域 + 指针域</li>
<li>指针域<ul>
<li>最后一个结点的指针域为NULL</li>
<li>单向链表的指针域又名“后继”；双向链表有“前驱”和“后继”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>与顺序表都属于<code>顺序存储结构</code><ul>
<li>链表思维<code>逻辑上连续</code>，但物理上不一定连续</li>
</ul>
</li>
</ul>
<h3 id="结构操作-1"><a href="#结构操作-1" class="headerlink" title="结构操作"></a><strong>结构操作</strong></h3><ul>
<li>插入<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092211.png" alt="图片"></li>
<li>①走到待插入位置的<strong>前一个</strong>位置的结点p</li>
<li>②先将新的结点x的指针域指向待插入位置的结点p.next</li>
<li>③将p的指针域指向新的结点x</li>
<li>顺序不能变！否则可能引发内存泄漏（你想用已经用不了，但系统却以为你在用）</li>
</ul>
</li>
<li>删除<ul>
<li>走到待删除结点位置的<strong>前一个</strong>位置</li>
</ul>
</li>
<li>翻转<ul>
<li>方法一<ul>
<li>用一个新链表存，使用头插法</li>
<li>不断在index = 0 的位置插入结点</li>
<li>不足：浪费空间，麻烦</li>
</ul>
</li>
<li>方法二<ul>
<li>原地翻转，用两个变量倒，也是头插法</li>
<li>前提：每次操作不要造成内存泄漏</li>
<li>NULL地址还是在最后面，不会翻转</li>
</ul>
</li>
</ul>
</li>
<li>代码演示见后</li>
</ul>
<h3 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h3><ul>
<li>head永远记录的是<strong>尾结点</strong>的地址~</li>
</ul>
<ol>
<li>对于需在index = 0插入结点的情况<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092219.png" alt="图片"></li>
<li>当head记录的是尾结点时，<strong>直接</strong>在head指向的尾结点后插入即可</li>
<li>如果head记录的还是首结点的地址，不好使，因为<ul>
<li>要找index = 0的结点的前一个结点，可能需要遍历完整个链表找到尾结点</li>
<li>而不像单向链表那样，可以直接在head后、index = 0结点前插入</li>
</ul>
</li>
</ul>
</li>
<li>对于在尾部插入结点的情况<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306092224.png" alt="图片"></li>
<li>需要修改head指向新的尾结点【8】！</li>
</ul>
</li>
</ol>
<h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a, b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    ListNode head; <span class="comment">// 虚拟头节点，第一个节点的前一个结点</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; List;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    List *l = getLinkList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> ind = rand() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %d at %d to List = %d\n&quot;</span>, val, ind, insert(l, ind, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;earse a iterm at %d from List = %d\n&quot;</span>, ind, erase(l, ind));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(GREEN(<span class="string">&quot;reverse the list!\n&quot;</span>));</span><br><span class="line">                reverse(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output(l), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode *p = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List *<span class="title">getLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l, <span class="keyword">int</span> ind, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ind &lt; <span class="number">0</span> || ind &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ListNode *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span>(ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    l-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;             </span><br><span class="line">    ListNode *p = l-&gt;head.next, *q; <span class="comment">// q 记录 q-&gt;next</span></span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;            <span class="comment">// 先将虚拟头节点指向 null</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;                      </span><br><span class="line">        q = p-&gt;next;                <span class="comment">// 保存p-&gt;next的地址</span></span><br><span class="line">        p-&gt;next = l-&gt;head.next;     <span class="comment">// 修改顺序</span></span><br><span class="line">        l-&gt;head.next = p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;List(%d) = [&quot;</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">for</span>(ListNode *p = l-&gt;head.next; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(List *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *p = l-&gt;head.next, *q;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clear_node(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>虚拟头结点，方便插入和删除第一个结点<ul>
<li>使用普通变量定义head，❓考虑的是<ul>
<li>虚拟头结点比较固定，不需要随时free</li>
<li>普通变量比指针变量更稳定，没必要malloc</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h1><ul>
<li>初始化数据结构[比如链表、链表结点]时，动态开辟内存[用malloc等]：<ul>
<li>关键：【malloc申请的内存在堆空间，普通变量定义在栈空间(在函数里面定义的)】</li>
<li>栈空间：大小只有8MB；出了函数[作用域]变量就被自动释放了</li>
<li>堆空间：可分配<strong>大内存</strong>；变量<strong>生命周期长</strong>，一般需手动释放</li>
</ul>
</li>
<li>虚拟头结点定义为普通变量和指针变量的区别<ul>
<li>虚拟头节点在之后单向链表的时候，比较方便，而如果用普通变量，则比较麻烦</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/doubleL3/blog-imgs/raw/master/img/WE8asP6.png" alt="图片"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/2021/01/02/0003.%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>FIFO（First In First Out）、LILO。类似排队，区分先来后到</li>
<li>也是顺序结构，需要连续存储空间（不过也可以用链表实现）</li>
</ul>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><ul>
<li>需要连续的存储空间</li>
<li>容量</li>
<li>队首、队尾</li>
<li>+元素个数：用来判断队列是否已满，方便<strong>循环队列</strong>解决假溢出问题</li>
<li>数据类型</li>
</ul>
<h3 id="结构操作"><a href="#结构操作" class="headerlink" title="结构操作"></a>结构操作</h3><ul>
<li><p>出队</p>
<ul>
<li>head - 1</li>
<li>count - 1</li>
</ul>
</li>
<li><p>入队</p>
<ul>
<li>tail + 1</li>
<li>count + 1</li>
</ul>
</li>
<li><p>假溢出</p>
<ul>
<li><p>不能存元素了</p>
</li>
<li><p>实际上可能还没有满：出队操作使队列头部有空位</p>
</li>
<li><p>解决方案：</p>
<p>循环队列</p>
<ul>
<li>tail走到头了再回到队列前面</li>
<li>使用取余运算确定位置：(tail + 1) % length</li>
</ul>
</li>
</ul>
</li>
<li><p>扩容：遇到真溢出时，详见代码演示</p>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>定义tail有两种方式<ul>
<li>①指向最后一个元素的地址</li>
<li><strong>②</strong>指向最后一个元素的下一个地址（本代码的选择）</li>
</ul>
</li>
<li>使用循环队列，已经不存在假溢出的现象</li>
<li>但对于真溢出怎么办呢？</li>
<li><strong>扩容</strong>：针对循环队列的扩容<ul>
<li>3种动态开辟内存的方法【malloc、calloc、realloc】，使用哪一种？</li>
<li>malloc、calloc都可以，但是realloc不好使<ul>
<li>循环队列的尾可能不在头的后面，而是尾和头重合了</li>
<li>举例：当队列已满时，head、tail（这里tail定义为尾部元素的后一位）在如下位置，此时扩容一倍，扩容后队列的push和pop会怎么样呢？</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093207.png" alt="image-20201202094139099"></li>
<li>此时从head→tail之间插入了很多空值，因为realloc是把值按原顺序搬过去，而扩容部分还没有值</li>
<li>那么，不管是从head到tail出队[中间夹杂了很多空值]，还是从tail入队[tail位置存在未出队的元素]，都存在问题！</li>
</ul>
</li>
<li>而用malloc开辟空间后，把原队列从head到tail按顺序迁移，即手动将head调整为索引0，如下，关键在于<strong>头尾指针的调整</strong>！<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093232.png" alt="image-20201202094256207"></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_HL(a,b) <span class="meta-string">&quot;\033[1;&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR_HL(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> head, tail, length, count;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue  *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    q-&gt;head = q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = q-&gt;length;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(extr_size) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (q-&gt;length + extr_size));</span><br><span class="line">        <span class="keyword">if</span>(p) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        p[j] = q-&gt;data[(i + j) % q-&gt;length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    q-&gt;data = p;</span><br><span class="line">    q-&gt;length += extr_size;</span><br><span class="line">    q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;tail = q-&gt;count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;count == q-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!expand(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;expand successfully! Queue-&gt;size(%d)\n&quot;</span>), q-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;tail == q-&gt;length) q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head++;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;head == q-&gt;length) q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; i++, j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[i % q-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Queue *q = init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Queue ! &quot;</span>, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, push(q, val));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the Queue !&quot;</span>, front(q));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(q));</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>FILO（First In Last Out）、LIFO。类比装书的箱子，一头是堵死的</li>
<li>也是顺序结构</li>
</ul>
<h3 id="结构定义-1"><a href="#结构定义-1" class="headerlink" title="结构定义"></a>结构定义</h3><ul>
<li>需要连续的存储空间（有大小限制）</li>
<li>容量</li>
<li>栈顶指针【top】：对于空栈，top = -1，为0可不合适</li>
<li>数据类型</li>
</ul>
<h3 id="结构操作-1"><a href="#结构操作-1" class="headerlink" title="结构操作"></a>结构操作</h3><ul>
<li>出栈：top - 1 // 需要判空</li>
<li>入栈：top + 1，存值 // 需要判满</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309094104.png" alt="图片"></p>
<ul>
<li>DFS和BFS</li>
<li>单调栈、单调队列自行学习</li>
</ul>
<h1 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h1><h2 id="LC-20：-有效的括号"><a href="#LC-20：-有效的括号" class="headerlink" title="LC-20： 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">LC-20</a>： 有效的括号</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309094122.png" alt="图片"></p>
<ul>
<li>关键在于思维：大问题转小问题<ul>
<li>问题简化成只有一种括号，怎么做？可以不使用栈完成吗？</li>
<li>思路：只需要记录左括号数量和右括号数量<ul>
<li>在任意位置，左数 &gt;= 右数</li>
<li>在最后位置，左数 == 右数</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309094110.png" alt="图片"></li>
<li>其实可以只用一个数top记录，遇到左括号+1，遇到右括号-1<ul>
<li>在任意位置，top &gt;= 0</li>
<li>在最后位置，top == 0</li>
</ul>
</li>
</ul>
</li>
<li>这个+1、-1操作，可以联想到栈的入栈、出栈吗？</li>
<li>一次括号匹配相当于入栈出栈一次</li>
<li>括号里的括号相当于完全包含关系</li>
<li>也有分治思想</li>
</ul>
</li>
<li><strong>栈</strong>：可以处理具有完全包含关系的问题</li>
</ul>
<h3 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_HL(a, b) <span class="meta-string">&quot;\033[1;&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR_HL(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(Stack *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = s-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        p = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(s-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (extr_size + s-&gt;size));</span><br><span class="line">        <span class="keyword">if</span>(p) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data = p;</span><br><span class="line">    s-&gt;size = s-&gt;size + extr_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == s-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!expand(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(GREEN(<span class="string">&quot;expand successfully! Stack -&gt; size = (%d)\n&quot;</span>), s-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s-&gt;top; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    Stack *s = init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> op = rand() % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the Stack = %d\n&quot;</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the Stack&quot;</span>, top(s));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, pop(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h1 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h1><ul>
<li>系统栈<ul>
<li>也是栈，大小：8MB</li>
<li>递归时，使用的就是系统栈</li>
</ul>
</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093445.png" alt="图片" style="zoom:50%;"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2021/01/03/0004.%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>树的组成：结点 + 边<ul>
<li>结点 ：集合；边 ： 关系</li>
<li>根结点：全集；子结点：子集<ul>
<li>根结点的所有子结点的集合并集 = 全集</li>
<li>【思想】大问题抽象为树，小问题抽象为子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><p>【结点 + 边】</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093517.png" alt="图片" style="zoom: 67%;">

<ul>
<li>一叉树是链表结构，只有一个分支的树形结构</li>
<li>对于三叉树，则将链表的next指针变成next[3]数组即可</li>
</ul>
<h3 id="属性、性质"><a href="#属性、性质" class="headerlink" title="属性、性质"></a>属性、性质</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093534.png" alt="图片" style="zoom: 33%;">

<ul>
<li>深度、高度<ul>
<li>树的深度和高度是一个值：最大层数</li>
<li>结点的深度和高度不一样<ul>
<li>深度：从根结点往下数，该结点是第几层</li>
<li>高度：从最深的层数往上数，该结点是第几层</li>
</ul>
</li>
</ul>
</li>
<li>度：有几个子孩子</li>
<li>【重要公式】结点数 = 边数 + 1</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li><p>二进制可以转换成任何进制，二叉树同理</p>
<ul>
<li>首先简单</li>
<li>且可以表示所有的树形结构<ul>
<li>方法：左孩子、右兄弟法，又称十字链表法</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093557.png" alt="图片" style="zoom:50%;"></li>
<li>从上往下，从左往右，结点的孩子放在左边，结点的相邻兄弟放在右边</li>
</ul>
</li>
</ul>
</li>
<li><p>对于n叉树，n不确定，而二叉树是确定的</p>
<ul>
<li>n叉树可以用二叉树来实现</li>
<li>所以，利用二叉树可以将非确定性问题 → 计算机能解决的确定性问题</li>
</ul>
</li>
<li><p>【重要公式】二叉树中，度为0的结点比度为2的结点多1个</p>
<ul>
<li>利用另一重要公式：结点数 = 边数 + 1</li>
<li>令 $ n_i $ 表示度为i的结点个数</li>
<li>则：$ [结点数] n_0 + n_1 + n_2 = n_1 + 2 * n_2 + 1 [边数 + 1] $</li>
<li>得：$ n_0 = n_2 + 1 $</li>
</ul>
</li>
<li><p>遍历方式：取决于什么时候[最先、中间、最后]访问根节点</p>
<ul>
<li>前序遍历：根 左 右</li>
<li>中序遍历：左 根 右</li>
<li>后序遍历：左 右 根</li>
<li>遍历时的左、右可以分别代表左、右子树</li>
<li>左右的相对顺序一直是左在前，右在后</li>
</ul>
</li>
<li><p>二叉树分类（国际版）</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093615.png" alt="图片"></li>
</ul>
</li>
<li><p>完全二叉树：除了最后一层最右边可以缺少若干结点，其他地方都满满当当</p>
<ul>
<li>满二叉树：度为0或2即可</li>
</ul>
</li>
<li><p>完美二叉树：度均为2，所有叶结点在同一层</p>
<ul>
<li>PS：中国版只分完全二叉树和满二叉树，满二叉树的定义同国际版的完美二叉树</li>
</ul>
</li>
<li><p>完全二叉树的特点 [完美二叉树同样满足]</p>
<ul>
<li>编号为 i 的结点的左右孩子编号分别是2 * i、2 * i + 1</li>
<li>可以用连续空间（数组）存储，用于算法优化：记录式-&gt;计算式<ul>
<li>不再需要用结构体存储孩子结点的地址，直接通过公式可计算其在数组中的索引</li>
</ul>
</li>
</ul>
</li>
<li><p>广义表：树的字符串化</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093853.png" alt="图片"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306093841.png" alt="图片"></li>
<li>有很多种表示方法，一般怎么简单怎么来，见上图红框：方式一、方式二</li>
</ul>
</li>
<li><p>对于二叉搜索树，中序遍历是顺序的</p>
</li>
<li><p>根据两种遍历可得第三种遍历结果</p>
<ul>
<li>前序遍历/后序遍历可得根结点，中序遍历可得左右孩子的位置</li>
<li>【必须】要有中序遍历，只有它才能确定孩子的左右</li>
</ul>
</li>
</ul>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ul>
<li>二叉搜索树</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clearNode(node-&gt;lchild);</span><br><span class="line">    clearNode(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clearNode(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_node</span><span class="params">(Node *root, <span class="keyword">int</span> val, <span class="keyword">int</span> *flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; root-&gt;data) root-&gt;lchild = insert_node(root-&gt;lchild, val, flag);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert_node(root-&gt;rchild, val, flag);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree *tree, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    tree-&gt;root = insert_node(tree-&gt;root, val, &amp;flag);</span><br><span class="line">    tree-&gt;n += flag;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    pre_order_node(node-&gt;lchild);</span><br><span class="line">    pre_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    in_order_node(node-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    in_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order : &quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    post_order_node(node-&gt;lchild);</span><br><span class="line">    post_order_node(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    output_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    output_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tree(%d) : &quot;</span>, tree-&gt;n);</span><br><span class="line">    output_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 10</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(tree, val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    output(tree);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>广义表还原二叉树</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306094107.png" alt="图片" style="zoom:50%;">

<ul>
<li>具有完全包含关系的问题，使用栈</li>
<li>栈里存储结点地址[Node *]：把广义表中的字符看成结点</li>
<li>转换过程</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>(</strong></th>
<th align="center"><strong>,</strong></th>
<th align="center"><strong>)</strong></th>
<th align="center"><strong>其他字符【字母】</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">【将元素入栈】 下一个’,’前的元素为左孩子</td>
<td align="center">决定下一个字符封装的元素为【右孩子】</td>
<td align="center">记录栈顶，【将元素弹栈】</td>
<td align="center">①将字符【封装】成结点指针类型，作为栈的元素 ②【关系确定】如果栈不为空，则根据该字符相对于’,’的位置，成为栈顶元素的左孩子或右孩子</td>
</tr>
</tbody></table>
<ul>
<li>结构定义、操作定义：栈、二叉树</li>
<li>【关键】转换的匹配规则</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node **data;</span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">top</span><span class="params">(Stack *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, Node *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == s-&gt;size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear_node(node-&gt;lchild);</span><br><span class="line">    clear_node(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> *node_num)</span> </span>&#123;</span><br><span class="line">    Stack *s = init_stack(<span class="built_in">strlen</span>(str));</span><br><span class="line">    Node *temp = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(str[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: &#123;</span><br><span class="line">                push(s, temp);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                p = top(s);</span><br><span class="line">                pop(s);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>: &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                temp = getNewNode(str[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!empty(s) &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">                top(s)-&gt;lchild = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!empty(s) &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">                top(s)-&gt;rchild = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(*node_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    clear_stack(s);</span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; !p) p = temp;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order : &quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    post_order_node(root-&gt;lchild);</span><br><span class="line">    post_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order : &quot;</span>);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    tree-&gt;root = build(str, &amp;node_num);</span><br><span class="line">    tree-&gt;n = node_num;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    clear_tree(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306095937.png" alt="image-20201202082334602"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序与查找</title>
    <url>/2021/01/04/0005.%20%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="排序与查找"><a href="#排序与查找" class="headerlink" title="排序与查找"></a>排序与查找</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>四象限原则：稳定/非稳定、内部/外部<ul>
<li>稳定：相同元素在排序前后的相对位置不变</li>
<li>内部：需要将数据整个加载到内存中进行排序</li>
</ul>
</li>
</ul>
<p>【考虑从小到大排序】</p>
<h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><ul>
<li><p>插入（内部）</p>
<ul>
<li>前：已排序区；后：待排序区</li>
</ul>
</li>
<li><p>后面的数在前面找位置插空</p>
<ul>
<li>一个一个比较、交换，实现【插入】的效果</li>
<li>不是直接和插入位置交换，这样会打乱已排序区的顺序</li>
<li>平均时间复杂度：O(N^2)</li>
</ul>
</li>
<li><p>冒泡（内部）</p>
<ul>
<li>前：待排序区；后：已排序区</li>
</ul>
</li>
<li><p>从第一个元素向后驶进，找到一个最大元素放在已排序区最前、待排序区最后</p>
<ul>
<li>进行N - 1轮冒泡，每轮在已排序中增加一个元素<ul>
<li>【优化】当某一轮冒泡过程没有进行交换操作，可以直接结束</li>
</ul>
</li>
<li>平均时间复杂度：O(N^2)<ul>
<li>最优时间复杂度：O(N)←已排序</li>
<li>最坏时间复杂度：O(N^2)←完全逆序</li>
</ul>
</li>
<li>插入排序可理解为反向冒泡</li>
</ul>
</li>
<li><p>归并（外部）</p>
<ul>
<li>前言：两个有序的数组（长度分别为m、n）合并成一个有序的数组</li>
<li>时间复杂度：O(m + n)</li>
<li>先分治到两两可以比较大小，再把有序的数组两两合并</li>
<li>时间复杂度（最优、最坏、平均都是）：O(NlogN)<ul>
<li>共logN层，每层的合并时间为O(N)</li>
</ul>
</li>
<li>【外部排序】2路归并(上述)、k路归并(多路归并，利用堆)<ul>
<li>参考<a href="https://www.wikiwand.com/zh-hans/%E5%A4%96%E6%8E%92%E5%BA%8F#/%E5%A4%96%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">外归并排序</a>-维基百科，每路的排序方法可以任意，最终归并</li>
<li>其实这个外部排序与否取决于你想不想、需不需要，但它可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><ul>
<li>要保证稳定排序的稳定性，注意==的情况，不能交换[或保证原有的顺序]！</li>
<li>【注意】调用TEST宏时，后一个数组是num，它是在宏定义里拷贝arr得到的一个数组！</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    a ^= b; b ^= a; a ^= b;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(arr, n, func, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    <span class="built_in">memcpy</span>(num, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>, <span class="meta">#func);\</span></span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">free</span>(num);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> insert_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; num[j] &lt; num[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">void</span> bubble_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; times; i++) &#123;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(num[j], num[j + <span class="number">1</span>]);</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">void</span> merge_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">// 递归出口，边界条件：剩余元素 &lt;= 2</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span> &amp;&amp; num[r] &lt; num[l]) &#123;</span><br><span class="line">            swap(num[r], num[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(num, l, mid);</span><br><span class="line">    merge_sort(num, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid || p2 &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt; num[p2])) &#123;</span><br><span class="line">            temp[k++] = num[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = num[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝排好序的数目到目前归并的数据首地址 &amp;num[l], 共 r - l + 1个元素</span></span><br><span class="line">    <span class="built_in">memcpy</span>(num + l, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> randint(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n--) num[n] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> output(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_n 20</span></span><br><span class="line">    <span class="keyword">int</span> arr[max_n];</span><br><span class="line">    randint(arr, max_n);</span><br><span class="line">    TEST(arr, max_n, insert_sort, num, max_n);</span><br><span class="line">    TEST(arr, max_n, bubble_sort, num, max_n);</span><br><span class="line">    TEST(arr, max_n, merge_sort, num, <span class="number">0</span>, max_n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序"></a>不稳定排序</h3><ul>
<li><p>选择（内部）</p>
<ul>
<li><p>前：已排序区；后：待排序区</p>
</li>
<li><p>每轮从待排序区中选择一个最小的元素与待排序区的第一个元素交换</p>
<ul>
<li>可能会有自身与自身交换的情况，所以交换函数不能用异或了</li>
</ul>
</li>
<li><p>不稳定：例如22’1，在第一次交换后，2就跑到了2’的后面，即12’2</p>
</li>
<li><p>时间复杂度（最优、最坏、平均都是）：O(N^2)</p>
</li>
<li><p>一般情况下优于冒泡，两者比较次数差不多，但冒泡的交换太频繁</p>
</li>
</ul>
</li>
<li><p>快排（内部）</p>
<ul>
<li>【基准值、partition】</li>
<li>拿出第1个元素作为基准值<ul>
<li>【尾指针】先从后往前找小于基准值的元素，放到第1个元素位置(已为空)，【头指针】再从前往后找大于基准值的值，放到刚刚空出的位置，循环</li>
<li>最后头尾指针重合，指向一个空位置，放入基准值</li>
<li>再对基准值左右两部分分别进行以上操作</li>
</ul>
</li>
<li>时间复杂度：O(NlogN)<ul>
<li>逆序数列选第一个元素为基准值时，退化为选择排序，O(N^2)</li>
</ul>
</li>
<li>【优化】<ul>
<li>基准值随机选</li>
<li>减少递归的使用，用循环做</li>
<li>左右都找到一个要交换的值后，再交换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(arr, n, func, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    <span class="built_in">memcpy</span>(num, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = &quot;</span>, <span class="meta">#func);\</span></span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">free</span>(num);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">void</span> select_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[ind] &gt; num[j]) ind = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[ind]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通快排</span></span><br><span class="line"><span class="keyword">void</span> quick_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = l, y = r, z = num[x];</span><br><span class="line">    <span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; num[y] &gt; z) y--;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) num[x++] = num[y];</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; num[x] &lt; z) x++;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) num[y--] = num[x];</span><br><span class="line">    &#125;</span><br><span class="line">    num[x] = z;</span><br><span class="line">    quick_sort(num, l, x - <span class="number">1</span>);</span><br><span class="line">    quick_sort(num, x + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本快排</span></span><br><span class="line"><span class="keyword">void</span> quick_sort1(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = l, y = r, z = num[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= y &amp;&amp; num[x] &lt; z) x++;</span><br><span class="line">            <span class="keyword">while</span> (x &lt;= y &amp;&amp; num[y] &gt; z) y--;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= y) &#123;</span><br><span class="line">                swap(num[x], num[y]);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x &lt;= y);</span><br><span class="line">        quick_sort1(num, x, r);</span><br><span class="line">        r = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> randint(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n--) num[n] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> output(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_n 20</span></span><br><span class="line">    <span class="keyword">int</span> arr[max_n];</span><br><span class="line">    randint(arr, max_n);</span><br><span class="line">    TEST(arr, max_n, select_sort, num, max_n);</span><br><span class="line">    TEST(arr, max_n, quick_sort, num, <span class="number">0</span>, max_n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>普通快排算法，有很多可优化点<ul>
<li>【优化点】基准值选择、递归→循环、交换方式<ul>
<li>注意几个边界的==：x &lt;= y、num[] &lt; z、num[] &gt; z</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li><p>朴素二分</p>
<ul>
<li>前提：单调序列</li>
<li>如果要查找的值在序列中重复存在，二分查找分辨不出找到的是哪一个</li>
</ul>
</li>
<li><p>特殊二分</p>
<ul>
<li>11110000<ul>
<li>引入虚拟头指针，索引为-1</li>
<li>mid计算需要+1，避免死循环，比如10情况</li>
</ul>
</li>
<li>00001111<ul>
<li>引入虚拟尾指针，索引为n [数组范围为0 ~ n - 1]</li>
</ul>
</li>
<li>这里比参考内容还增加一个<strong>虚拟指针</strong>的概念，通过更改查找的边界[-1 ~ n -1 或 0 ~ n]，可以<strong>反映找不到值时的情况</strong></li>
</ul>
</li>
<li><p>三分查找</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306095424.png" alt="图片"></li>
<li>解决【求凹凸函数极值点】问题</li>
<li>将原问题的规模分成三分之一</li>
<li>更新策略：保留值小的元素与另一端的区间；停止条件：$ |m_1 - m_2|&lt; ESPL $</li>
<li>时间复杂度：$ O(log_3N) $，比二分查找 $ O(log_2N) $稍慢</li>
</ul>
<h3 id="代码演示：-2"><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>虚拟指针的使用，可以避免没有答案时[000000]返回假答案[0或n - 1]的情况</li>
<li>11110000的情况，在计算mid时要+1，避免陷入死循环，如10</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(func) &#123;\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="meta">#func, func);\</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> binary_search1(<span class="keyword">int</span> *num, <span class="keyword">int</span> n, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n <span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (num[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> binary_search2(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">-1</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid] == <span class="number">1</span>) head = mid;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> binary_search3(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid] == <span class="number">1</span>) tail = mid;</span><br><span class="line">        <span class="keyword">else</span> head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head == n ? <span class="number">-1</span> : head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    P(binary_search1(arr1, <span class="number">10</span>, <span class="number">7</span>));</span><br><span class="line">    P(binary_search2(arr2, <span class="number">10</span>));</span><br><span class="line">    P(binary_search3(arr3, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>

</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>用于查找的【数据结构】</li>
<li>结构定义<ul>
<li>需要一片连续的空间，存储元素</li>
<li>与顺序表一致，元素类型可变</li>
</ul>
</li>
<li>结构操作<ul>
<li>哈希函数：可以把任意类型元素映射成整型值[数组下标]<ul>
<li>然后可以存储某值到对应的数组下标中</li>
<li>数组下标只能是整型</li>
</ul>
</li>
<li>冲突处理方法<ul>
<li>开放定值【常用】：往后看看有没有空位，如二次探测法…但容易产生数据堆聚问题</li>
<li>再哈希：又名散列法，使用多种哈希函数</li>
<li>拉链法【常用】：用<strong>链表</strong>结构存储每个位置的元素</li>
<li>建立公共溢出区：把冲突的元素统一放到一个特定区域</li>
</ul>
</li>
</ul>
</li>
<li>查找的时间复杂度：趋近于O(1)<ul>
<li>其他耗时：哈希函数转换、拉链法[查找链表元素]或其他冲突处理方法导致的耗时</li>
<li>只有数组、顺序表是O(1)的</li>
</ul>
</li>
<li>哈希表的空间利用率一般是50~90%<ul>
<li>哈希函数一定会存在冲突情况，开辟空间时需要预留</li>
<li>当利用率可以达到70%时，它就可以在工业上使用了，冲突越少，利用率越高，哈希函数越优秀</li>
</ul>
</li>
</ul>
<h3 id="代码演示：-3"><a href="#代码演示：-3" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>哈希函数：BKDR-Hash，冲突处理方法：拉链法</li>
<li>插入值时使用的是头插法</li>
<li>哈希表结构的利用率不可能达到100%，所以开辟的空间需要扩大，一倍</li>
<li>calloc开辟哈希表空间，可以让每个位置的链表首地址置空，安全</li>
<li>哈希函数可以自己设计</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    Node **data;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">init_node</span><span class="params">(<span class="keyword">char</span> *str, Node *head)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;str = strdup(str);</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HashTable *<span class="title">init_hashtable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    h-&gt;size = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    h-&gt;data = (Node **)<span class="built_in">calloc</span>(h-&gt;size, <span class="keyword">sizeof</span>(Node *));</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) hash = hash * seed + str[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    Node *p = h-&gt;data[ind];</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;str, str)) p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *p = node, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;str);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_hashtable</span><span class="params">(HashTable *h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h-&gt;size; i++) &#123;</span><br><span class="line">        clear_node(h-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(h-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_n 100</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span> + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    HashTable *h = init_hashtable(max_n + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;op, str)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %s to HashTable\n&quot;</span>, str);</span><br><span class="line">                insert(h, str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search %s from HashTable result = %d\n&quot;</span>, str, search(h, str));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_n</span></span><br><span class="line">    clear_hashtable(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h1 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h1><ul>
<li>❓关于快速排序优化版中边界的思考<ul>
<li><img src="https://gitee.com/doubleL3/blog-imgs/raw/master/img/QVxwRHT.png" alt="图片"></li>
<li>同样按照普通版快排优化边界判断，下面优化的思路有问题，而在普通版均可实现<ul>
<li>32 - 33行：num[] &lt; z 和 num[] &gt; z 分别改称 &lt;= 和 &gt;=，会出现【段错误或死循环】<ul>
<li>对于num[] &lt;= z 【死循环】<ul>
<li>举例：2 1 ，基准值为2，左指针x一直走到右端，出界，而右指针y不变，第27行while (l &lt; r)成立，x又回到l，变成了死循环</li>
</ul>
</li>
<li>对于num[] &gt;= z 【段错误——爆栈】<ul>
<li>举例：1 2，基准值为1，右指针y一直走到左端，变-1，而左指针x和r不变，第39行quick_sort(num, x, r)不断递归调用，最终爆栈</li>
</ul>
</li>
<li>分析原因：普通版把基准值拿出来了，优化版基准值还在里面，需要考虑这个区别</li>
</ul>
</li>
<li>32 - 34行：x &lt;= y 改成 x &lt; y，也会出现【段错误】<ul>
<li>举例：2 3，基准值为2，此时x、y分别指向2、3，经过循环，x、y都指向2，而x和r都不变，第39行quick_sort(num, x, r)不断递归调用，最终爆栈</li>
<li>分析原因：x、y要错开，不然有点像特殊二分111000不+1的情况</li>
</ul>
</li>
<li><strong>小结</strong>：x、y都得动起来，x不动导致<strong>爆栈</strong>，y不动导致<strong>死循环</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306095931.png" alt="图片" style="zoom:50%;"></li>
<li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法(动图演示)</a></li>
<li><a href="https://www.cxyxiaowu.com/2026.html">十大经典排序算法动画与解析，看我就够了</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>森林与并查集</title>
    <url>/2021/01/06/0007.%20%E6%A3%AE%E6%9E%97%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="森林与并查集"><a href="#森林与并查集" class="headerlink" title="森林与并查集"></a>森林与并查集</h1><ul>
<li>并查集：合<strong>并</strong>集合[建立连通关系]、<strong>查</strong>找<strong>集</strong>合中的连通关系[判断某两个点是否连通]</li>
</ul>
<h2 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306100924.png" alt="图片" style="zoom: 67%;">

<ul>
<li>规则：已经具有连通关系的点不能重复连接</li>
<li>将所有点分成了2个集合：①、②</li>
<li>[PS] 点与点的关系(合并、判断连通)→也可以是→集合与集合的关系</li>
</ul>
<h2 id="Quick-Find算法"><a href="#Quick-Find算法" class="headerlink" title="Quick-Find算法"></a>Quick-Find算法</h2><ul>
<li>核心思想：染色<ul>
<li>一个颜色，对应一个类别</li>
<li>初始化：个体独立，都写成自己的索引，属于一个独立的集合里</li>
<li>把和自己<strong>连通的所有</strong>点的颜色改成要染的颜色</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>连通判断：O(1)——查找快，所以叫Quick-Find</li>
<li>合并操作：O(N)——需要遍历所有的点才能确定是否要合并</li>
</ul>
</li>
<li>引发思考：为什么又叫森林呢？<ul>
<li>关键在于<strong>合并</strong>操作，几个点与几个点的合并，集合与集合的合并</li>
<li>类似于子树与子树之间的合并，或是将一棵树作为另一棵树的子树</li>
<li>所有的集合放在一起，类似于所有的树放在一起，就是森林</li>
</ul>
</li>
<li>那么，除了染色还有其他方式吗？<ul>
<li>思考：染成了什么颜色并不重要，只需要知道和哪些点的颜色相同，即连通</li>
</ul>
</li>
</ul>
<h2 id="Quick-Union算法"><a href="#Quick-Union算法" class="headerlink" title="Quick-Union算法"></a>Quick-Union算法</h2><ul>
<li>生活启发：找大哥，找领导</li>
<li>核心思想：找代表元素 [根结点]<ul>
<li>存的值就是其代表元素</li>
<li>初始化：个体独立，都写成自己的索引，属于一个独立的集合里</li>
<li>找到<strong>两点的代表元素</strong>，修改其中一个代表元素<strong>里的值</strong>为另一个代表元素里的值</li>
<li>代表元素：里面的值就是它自己</li>
<li>联想：大哥或他的小弟叛变了，都从大哥开始叛变，叛变到另一个小弟的大哥那<ul>
<li>与Quick-Find的结果一样，都是把一棵子树整体合并到另一棵子树，不过是通过代表元素来实现的</li>
<li>只能是根结点指向根结点</li>
</ul>
</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>都得找根结点，与树高相关</li>
<li>连通操作：O(树高)</li>
<li>合并操作：O(树高)</li>
<li>2种情况<ul>
<li>正常状态→均为O(logN)</li>
<li>退化为一个链表→均为O(N)</li>
</ul>
</li>
</ul>
</li>
<li>对于退化情况，如何解决呢 ：weighted Quick-Union</li>
</ul>
<h2 id="weighted-Quick-Union算法【按秩合并】"><a href="#weighted-Quick-Union算法【按秩合并】" class="headerlink" title="weighted Quick-Union算法【按秩合并】"></a>weighted Quick-Union算法【按秩合并】</h2><ul>
<li>如何避免退化？→保证枝繁叶茂<ul>
<li>合并依据1：树高，矮树挂在高树下[两两结合]<ul>
<li>高度为 h 的树，至少需要的结点个数N为2 ^ (h - 1)</li>
<li>即树高h = log[2]N + 1 ≈ log[2]N</li>
<li>[PS] 只有两棵一样树高的树合并，才会使高度增加</li>
</ul>
</li>
<li>合并依据2：结点数量，结点少的树挂在结点多的树下</li>
<li>两种优化方式都能得到O(logN)，但是合并依据2【结点数量】更优秀一些</li>
</ul>
</li>
<li>为什么合并依据2更优秀<ul>
<li>【示例】什么是平均查找次数<ul>
<li>如下图所示，计算了A、B树的平均查找次数</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104709.png" alt="image-20210306104701093"></li>
<li>结点深度即为结点的查找次数，平均查找次数 = 总查找次数 / 总结点数</li>
<li>此示例，B树的查找操作更快</li>
</ul>
</li>
<li>【推导】合并依据2直接决定平均查找次数<ul>
<li>对于有SA、SB个结点的A、B树，它们的总查找次数LA、LB分别为：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104750.png" alt="图片"></li>
<li>其中，li 代表第 i 个结点的深度</li>
</ul>
</li>
<li>此时进行合并操作，分别计算①A→B和②B→A的平均查找次数<ul>
<li>①当A树作为子树合并到B树时，为<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104756.png" alt="图片"></li>
<li>A树中的所有结点需要多查找一次</li>
</ul>
</li>
<li>②当B树作为子树合并到A树时，为<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104800.png" alt="图片"></li>
<li>B树中的所有结点需要多查找一次</li>
</ul>
</li>
</ul>
</li>
<li>【比较两种方式的平均查找次数】<ul>
<li>和树高[LA、LB]没有直接关系，而分子的结点数量[SA、SB]【直接】决定查找次数，次数越小越好</li>
<li>谁的结点数少，就作为子树被合并</li>
<li>思考：上面的推导是否证明高度无法作为合并依据呢？<ul>
<li>否，高度间接影响着结点数量，一般情况高度越低，结点数量越少</li>
<li><strong>但是</strong>，对于特殊情况，A树比B树高，而A树结点数量却比B树少时，还是按照【结点数量】作为合并依据，将A树作为子树合并到B树里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>所以以结点数作为合并依据更优秀！合并思路如下</li>
</ul>
</li>
<li>在合并两棵子树时<ul>
<li>如果结点数一样，就按照普通Quick-Union的思路换</li>
<li>如果不一样，结点数少的子树的根结点接在：结点数多的子树的根结点下面</li>
</ul>
</li>
<li>[PS]换句话说<ul>
<li>在换大哥时</li>
<li>如果小弟数量一样，就按照普通Quick-Union的思路换</li>
<li>如果不一样，小弟少的大哥得跟：小弟多的大哥混</li>
</ul>
</li>
</ul>
<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="+ 路径压缩"></a>+ 路径压缩</h2><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104837.png" alt="图片"></li>
<li>0的位置有些尴尬</li>
<li>不管0的代表元素为1还是3，并没区别，将0直接挂载3的下面，还能减小树高</li>
<li>【方法】让每一个非根结点直接指向根结点，让结构扁平化</li>
</ul>
<p><strong>上述算法的效率比较</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309095131.png" alt="图片"></p>
<h3 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h3><h2 id="Quick-Find-vs-Quick-Union"><a href="#Quick-Find-vs-Quick-Union" class="headerlink" title="Quick-Find vs. Quick-Union"></a>Quick-Find vs. Quick-Union</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309095140.png" alt="图片"></p>
<ul>
<li>【关键】理解Quick-Union<ul>
<li>0-&gt;1-&gt;2-&gt;4-&gt;5、3-&gt;4-&gt;5；8-&gt;9-&gt;7-&gt;6</li>
<li>查找、合并边界：自己的代表元素就是本身时，停止</li>
</ul>
</li>
</ul>
<h2 id="Quick-Union-vs-weighted-Quick-Union"><a href="#Quick-Union-vs-weighted-Quick-Union" class="headerlink" title="Quick-Union vs. weighted Quick-Union"></a>Quick-Union vs. weighted Quick-Union</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309095149.png" alt="图片"></p>
<ul>
<li>【关键】理解weighted的含义<ul>
<li>当两个集合的元素个数不一样时</li>
<li>元素少的集合的代表元素的值：元素多的集合的代表元素的值</li>
<li>小弟少的大哥得跟着小弟多的大哥混</li>
</ul>
</li>
<li>结果可视化<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309095157.png" alt="图片"></li>
<li>很明显，weighted方法得到的树更矮，合并、查找效率更高</li>
</ul>
</li>
</ul>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="HZOJ-71：朋友圈"><a href="#HZOJ-71：朋友圈" class="headerlink" title="HZOJ-71：朋友圈"></a>HZOJ-71：朋友圈</h4><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306104933.png" alt="图片"></p>
<p><strong>样例输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>样例输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<ul>
<li>思路<ul>
<li>使用数据结构——并查集</li>
<li>1即合并操作，2即查找操作</li>
<li>分别测试Quick-Find、Quick-Union [+weighted、+路径压缩、-weighted]的算法效率</li>
</ul>
</li>
</ul>
<h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick-Find"></a>Quick-Find</h3><p>查找、合并策略：基于染色</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;color = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;color[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;color[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(u, a) == find(u, b)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> color_a = u-&gt;color[a];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= u-&gt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;color[i] - color_a) <span class="keyword">continue</span>;</span><br><span class="line">        u-&gt;color[i] = u-&gt;color[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;color);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick-Union"></a>Quick-Union</h3><ul>
<li>基于Quick-find<ul>
<li>修改结构定义的color为代表元素father</li>
<li>修改查找操作：需要找到底</li>
<li>修改合并操作：也要找到两个元素的底，才合并</li>
</ul>
</li>
<li>易出现退化为链表的问题，下面进行优化</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306105338.png" alt="图片"></p>
<ul>
<li>基于Quick-find<ul>
<li>修改结构定义的color为代表元素father</li>
<li>修改查找操作：需要找到底</li>
<li>修改合并操作：也要找到两个元素的底，才合并</li>
</ul>
</li>
<li>易出现退化为链表的问题，下面进行优化</li>
</ul>
<h3 id="weighted"><a href="#weighted" class="headerlink" title="+ weighted"></a>+ weighted</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306105330.png" alt="图片"></p>
<ul>
<li>基于Quick-Union</li>
<li>添加size属性，记录结点所在集合的结点个数，以此作为合并策略</li>
</ul>
<h3 id="路径压缩-1"><a href="#路径压缩-1" class="headerlink" title="+ 路径压缩"></a>+ 路径压缩</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306105325.png" alt="图片"></p>
<ul>
<li>每次查找就会做一次路径压缩，将【查找元素】到【根代表元素】区间的所有元素都指向根代表元素 [根结点]</li>
</ul>
<h3 id="－weighted"><a href="#－weighted" class="headerlink" title="－weighted"></a>－weighted</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a ,b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *father;</span><br><span class="line">    <span class="comment">//int *size;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//u-&gt;size = (int *)malloc(sizeof(int) * (n + 1));</span></span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">        <span class="comment">//u-&gt;size[i] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(u, a), fb = find(u, b);</span><br><span class="line">    <span class="keyword">if</span> (fa == fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb);</span></span><br><span class="line">    u-&gt;father[fb] = fa;</span><br><span class="line">    <span class="comment">//u-&gt;size[fa] += u-&gt;size[fb];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="comment">//free(u-&gt;size);</span></span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>抹掉所有与size相关的操作</li>
<li>有了路径压缩后，不按秩合并[去除size属性]也能达到很好的效果</li>
</ul>
<p><strong>HZOJ平台上题目测试用时</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left">Quick-Find</th>
<th align="left">Quick-Union</th>
<th align="left">+weighted</th>
<th align="left">+路径压缩</th>
<th align="left">weighted</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用时(ms)</strong></td>
<td align="left">744</td>
<td align="left">2020</td>
<td align="left">164</td>
<td align="left">172</td>
<td align="left">188</td>
</tr>
</tbody></table>
<ul>
<li>Quick-Union出现了退化问题</li>
<li>加了路径压缩后，不按秩合并也能达到很好的效果</li>
<li><strong>后三个方法</strong>都有不错的效果！</li>
</ul>
<h3 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h3><ul>
<li>在weighted Quick-Union算法部分，结点数更优秀的推导是否证明高度无法作为合并依据呢？<ul>
<li>否，高度间接影响着结点数量，一般情况高度越低，结点数量越少</li>
<li>但是，对于特殊情况，A树比B树高，而A树结点数量却比B树少时<ul>
<li>需按照【结点数量】作为合并依据：将A树作为子树合并到B树里</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306105114.png" alt="图片"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/2021/01/05/0006.%20%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h1><h2 id="回顾-完全二叉树"><a href="#回顾-完全二叉树" class="headerlink" title="回顾[完全二叉树]"></a>回顾[完全二叉树]</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306095959.png" alt="图片" style="zoom:50%;">

<ul>
<li><p>完全二叉树默认从1开始编号</p>
<ul>
<li>这样可以保证左孩子、右孩子编号简洁</li>
<li>[否则] 左孩子编号需为2 * i + 1，右孩子编号需为2 * i + 2</li>
</ul>
</li>
<li><p>可编号的性质→可用顺序结构存储，而不需要保存下一个结点的地址</p>
<ul>
<li><img src="https://i.loli.net/2020/12/02/DnX8VaTRLbd7mox.png" alt="图片" style="zoom:50%;"></li>
</ul>
</li>
<li><p>二叉树→数组的转换</p>
<ul>
<li>按层序遍历的顺序存储在数组中，每一层的结点存储是连续的</li>
</ul>
</li>
</ul>
<h2 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆[优先队列]"></a>堆[优先队列]</h2><p>优先队列是堆的一个别名；堆是在<strong>完全二叉树</strong>的基础上维护的</p>
<h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><ul>
<li>结构与完全二叉树一样，但多维护了一种性质<ul>
<li>大顶堆：对于任意三元组，根结点值最大</li>
<li>小顶堆：对于任意三元组，根结点值最小</li>
</ul>
</li>
</ul>
<h3 id="结构操作"><a href="#结构操作" class="headerlink" title="结构操作"></a>结构操作</h3><p>一切操作都要维护自己的性质！</p>
<ul>
<li>尾部插入【+调整】<ul>
<li>在尾部插入该元素，再自下向上调整，最远调整到根结点<ul>
<li>在三元组里不断调整，依次与父结点比较，只要交换了就不停止，直到到达根结点</li>
<li>交换时只会改变交换元素的相对大小，整个结构的相对大小关系不变</li>
</ul>
</li>
<li>比较的编号其实就是i 与 i / 2</li>
<li>时间复杂度：$ O(log_2N) $，即树高</li>
</ul>
</li>
<li>头部弹出【+调整】<ul>
<li>将最后一个元素拿到堆顶，再自上向下调整，直到该元素没有子结点<ul>
<li>在三元组里不断调整，依次与孩子结点比较，只要交换了就不停止，直到没有孩子</li>
<li>为什么选择最后一个元素放到堆顶？</li>
<li>因为，如果拿其他位置的元素，谁来补这个元素的缺口呢</li>
</ul>
</li>
<li>比较的编号其实就是i、2 * i 与 2 * i + 1</li>
<li>时间复杂度：同为树高</li>
</ul>
</li>
<li>[PS]<ul>
<li>大顶堆：方便查找第1大和第2大的元素 [根结点、第二层中]<ul>
<li>找第3大、第4大…就不那么简单，不方便确定所在层数</li>
</ul>
</li>
<li>上面这个过程<ul>
<li>队尾进元素，队首出元素-&gt;同队列</li>
<li>而出队的元素是最值-&gt;又名优先队列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> cnt, size;</span><br><span class="line">&#125; <span class="built_in">priority_queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">priority_queue</span> *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span> *q = (<span class="built_in">priority_queue</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">priority_queue</span>));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    q-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    q-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="built_in">priority_queue</span> *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;cnt == q-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[++(q-&gt;cnt)] = val;</span><br><span class="line">    <span class="keyword">int</span> ind = q-&gt;cnt;</span><br><span class="line">    <span class="keyword">while</span> (ind &gt;&gt; <span class="number">1</span> &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        ind &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[<span class="number">1</span>] = q-&gt;data[q-&gt;cnt--];</span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ind &lt;&lt; <span class="number">1</span>) &lt;= q-&gt;cnt) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;</span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> max_op 20</span></span><br><span class="line">    <span class="built_in">priority_queue</span>*q = init(max_op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        push(q, val);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;insert %d to the priority_queue.\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max_op; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, top(q));</span><br><span class="line">        pop(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> max_op</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>根据其性质，全部弹出，将得到一个排好序的序列</li>
<li>思维转变：堆顶元素的弹出操作 ==&gt; 堆顶元素与堆尾元素交换<ul>
<li><strong>大顶堆</strong>的元素全部弹出：<strong>原数组</strong>存储了一个<strong>从小到大</strong>的排序序列</li>
<li>[至此，从大顶堆，得到一个特殊的小顶堆]</li>
</ul>
</li>
<li>时间复杂度：$ O(NlogN) $<ul>
<li>消耗的时间在于调整操作，每次调整的时间复杂度是 $ O(logN) $，共N个元素，需调整N - 1次</li>
<li>弹出操作的时间复杂度是O(1)的</li>
<li>时间效率一定不会退化</li>
</ul>
</li>
</ul>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><ul>
<li>若要使用堆排序，首先需要维护一个堆，也就是用普通的序列<strong>建堆</strong>，下面有2种思路</li>
</ul>
<h4 id="1-插入建堆法"><a href="#1-插入建堆法" class="headerlink" title="1. 插入建堆法"></a>1. 插入建堆法</h4><ul>
<li>按照前述尾部插入的调整方法：自下向上<ul>
<li>从第0层 [默认根结点在第0层] 开始，计算每一层的最多调整次数：</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306100309.png" alt="图片" style="zoom:50%;"></li>
<li>第 i 层元素的调整次数为 i，第 i 层的结点数为2 ^ i→ 第 i 层的总调整次数为 $ i * (2 ^ i) $</li>
</ul>
</li>
<li>最坏的建堆时间复杂度O(NlogN)，计算过程如下：<ul>
<li>总的调整次数 $ S = (n - 1) * 2 ^ {n + 1}+ 1 $，过程如下：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306100428.png" alt="图片"></li>
<li>利用裂项相消法</li>
</ul>
</li>
<li>上面的n对应层数 - 1 [从第0层开始的]，若令总的结点数为N，则 $ n ≈ log_2N $</li>
<li>【层数n→结点数N的换算】将 $ n ≈ log_2N $代入S，得到 $ S ≈ Nlog_2N $</li>
<li>即最坏的时间复杂度为：$ O(NlogN) $</li>
</ul>
</li>
</ul>
<h3 id="2-线性建堆"><a href="#2-线性建堆" class="headerlink" title="2. 线性建堆"></a>2. 线性建堆</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306100544.png" alt="图片"></p>
<ul>
<li><p>如图所示</p>
<ul>
<li>常规思路：越到下面层，需要的调整次数越多，也就是权重越大</li>
<li>那是否可以思维反转，把大权重放到前面，让下面结点数多的层的权重减小</li>
<li>线性思路：可以！从倒数第二层开始排，【自上向下】调整</li>
</ul>
</li>
<li><p>最坏的建堆时间复杂度O(N)</p>
<ul>
<li>同样利用裂项相消法得到总的调整次数 $ S = 2 ^ {n + 1} - 2 - n $</li>
<li>把层数n换算到结点数N，得到 $ S ≈ 2N - 2 - log_2N $</li>
<li>即最坏的时间复杂度为：O(N)</li>
</ul>
</li>
</ul>
<h3 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>线性建堆</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define swap(a, b) &#123;\</span><br><span class="line">    __typeof(a) __temp &#x3D; a;\</span><br><span class="line">    a &#x3D; b; b &#x3D; __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void downUpdate(int *arr, int n, int ind) &#123;</span><br><span class="line">    while ((ind &lt;&lt; 1) &lt;&#x3D; n) &#123;</span><br><span class="line">        int temp &#x3D; ind, l &#x3D; ind &lt;&lt; 1, r &#x3D; ind &lt;&lt; 1 | 1;</span><br><span class="line">        if (arr[l] &gt; arr[temp]) temp &#x3D; l;</span><br><span class="line">        if (r &lt;&#x3D; n &amp;&amp; arr[r] &gt; arr[temp]) temp &#x3D; r;</span><br><span class="line">        if (ind &#x3D;&#x3D; temp) break;</span><br><span class="line">        swap(arr[temp], arr[ind]);</span><br><span class="line">        ind &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int *arr, int n) &#123;</span><br><span class="line">    arr -&#x3D; 1;</span><br><span class="line">    for (int i &#x3D; n &gt;&gt; 1; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">        downUpdate(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; n; i &gt; 1; i--) &#123;</span><br><span class="line">        swap(arr[i], arr[1]);</span><br><span class="line">        downUpdate(arr, i - 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(int *arr, int n) &#123;</span><br><span class="line">    printf(&quot;[&quot;);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;]&quot;);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    srand(time(0));</span><br><span class="line">    #define max_n 20</span><br><span class="line">    int *arr &#x3D; (int *)malloc(sizeof(int) * max_n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; max_n; i++) &#123;</span><br><span class="line">        arr[i] &#x3D; rand() % 100;</span><br><span class="line">    &#125;</span><br><span class="line">    output(arr, max_n);</span><br><span class="line">    heap_sort(arr,max_n);</span><br><span class="line">    output(arr, max_n);</span><br><span class="line">    free(arr);</span><br><span class="line">    #undef max_n</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>这里的【堆排序】考虑了【建堆】+【排序】: $ O(N) + O(NlogN) = O(NlogN)$</li>
<li>没有定义堆结构，用数组模拟堆</li>
</ul>
<h1 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h1><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306100859.png" alt="img"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>基础数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉查找树——AVL树</title>
    <url>/2021/01/08/0009.%20AVL%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="平衡二叉查找树（2）——AVL树（小学生必知必会系列）"><a href="#平衡二叉查找树（2）——AVL树（小学生必知必会系列）" class="headerlink" title="平衡二叉查找树（2）——AVL树（小学生必知必会系列）"></a>平衡二叉查找树（2）——AVL树（小学生必知必会系列）</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214515.png" alt="image-20201221153419032" style="zoom:50%;">

<p>右边的退化成了一个链表，查找效率变成了最糟糕的 O(n)，插入顺序不同，会影响查找效率，搞笑了！！所以提出了AVL树。</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214523.png" alt="image-20201221153626059" style="zoom:50%;">

<h3 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h3><ol>
<li>平衡二叉树排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质</li>
<li>平衡二叉树排序树的学习重点，在于平衡条件以及平衡调整的相关学习</li>
</ol>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><ol>
<li>拥有所有二叉排序树的所有特点</li>
<li>左子树跟右子树的高度差 &lt;= 1 （AVL树的真正性质， 防止退化成链表）</li>
</ol>
<h3 id="思考-："><a href="#思考-：" class="headerlink" title="思考 ："></a>思考 ：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214541.png" alt="image-20201221154324630" style="zoom:50%;">

<ol>
<li><p>$H &lt;= SIZE(H) &lt;= 2^H - 1$</p>
</li>
<li><p>$1.618^H &lt;= SIZE(H) &lt;= 2^H - 1$</p>
</li>
<li><p>AVL树，查找效率在$log_2N$ -  $log_3N$之间，效率最差也是$log_2N$</p>
</li>
<li><p>AVL 树改进的是节点数量的下限</p>
</li>
<li><p>树高 = 生命长度，节点数量 = 生命财富，不同的算法，达到的结果是不同的</p>
</li>
<li><p>教育提升的是底限，而不是上限，上限取决于能力和运气</p>
</li>
</ol>
<h2 id="AVL树平衡调整"><a href="#AVL树平衡调整" class="headerlink" title="AVL树平衡调整"></a>AVL树平衡调整</h2><ol>
<li>插入与删除操作：与BS树一样，需要排序 ，一旦破坏了AVL树的性质，就会触发平衡调整操作</li>
<li>发生在回溯阶段的，<code>第一个失衡节点处</code></li>
<li>理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD 四棵子树树高的关系</li>
<li>LL，大右旋</li>
<li>LR，先小左旋，再大右旋</li>
<li>RL，先小右旋，再大左旋</li>
<li>RR，大左旋</li>
</ol>
<h3 id="基础操作（左旋，右旋）"><a href="#基础操作（左旋，右旋）" class="headerlink" title="基础操作（左旋，右旋）"></a>基础操作（左旋，右旋）</h3><h5 id="左旋："><a href="#左旋：" class="headerlink" title="左旋："></a>左旋：</h5><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214541.png" alt="image-20201221160307127" style="zoom:50%;">

<h5 id="右旋："><a href="#右旋：" class="headerlink" title="右旋："></a>右旋：</h5><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214548.png" alt="image-20201221160431271" style="zoom:50%;">

<h5 id="失衡："><a href="#失衡：" class="headerlink" title="失衡："></a>失衡：</h5><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214611.png" alt="image-20201221160759081" style="zoom:50%;">

<h6 id="LL型-："><a href="#LL型-：" class="headerlink" title="LL型 ："></a>LL型 ：</h6><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214558.png" alt="image-20201221160845562" style="zoom:50%;">

<p>树高判断 ： </p>
<ul>
<li><p>A、B、C、D的树高分别为$h_1$、$h_2$、$h_3$、$h_4$</p>
</li>
<li><p>增加节点之前，该树是平衡的，满足AVL树性质的，即每个节点的左右子树的高度差不超过1</p>
</li>
<li><p>而增加一个叶子节点后，该树是LL失衡，说明说明只能叶子节点<code>必须是增加在A树上</code>，否则要么不是LL失衡，要么增加之前就失衡，不满足条件（$h_1$为已经增加叶子节点的高度）</p>
</li>
<li><p>因为是LL失衡，即在K1位置（<code>回溯</code>的<code>第一失衡</code>节点）发现失衡，所以，K2与K3是平衡的，所以 $h_1 = h_2 + 1$ 、$|h_3 - h_4| \leq 1$</p>
</li>
<li><p>K1失衡，K2树高比K3树高多2，则只能是 $h_1 = h_2 + 1 = max(h_3,h_4) + 2$</p>
</li>
<li><p>调整方法 ： K2节点<code>右旋一次即可</code></p>
</li>
</ul>
<h6 id="LR型：（变成LL）"><a href="#LR型：（变成LL）" class="headerlink" title="LR型：（变成LL）"></a>LR型：（变成LL）</h6><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214626.png" alt="image-20201222091311873" style="zoom:50%;">

<p>树高判断 ： </p>
<ul>
<li><p>A、B、C、D的树高分别为$h_1$、$h_2$、$h_3$、$h_4$</p>
</li>
<li><p>增加节点之前，该树是平衡的，满足AVL树性质的，即每个节点的左右子树的高度差不超过1</p>
</li>
<li><p>而增加一个叶子节点后，该树是LR失衡，说明说明只能叶子节点<code>必须是增加在B树或者C树其中之一上</code>，否则要么不是LR失衡，要么增加之前就失衡，不满足条件（$h_2$、$h_3$为已经增加叶子节点的高度）</p>
</li>
<li><p>因为是LR失衡，即在K1位置（<code>回溯</code>的<code>第一失衡</code>节点）发现失衡，所以，K2与K3是平衡的，所以 <code>K2的树高比D树高2</code>，也就是<code>高在K3树</code>上，<code>A树</code>的树高与<code>D树</code>一样，$max(h_2, h_3) = h_4 = h_1$</p>
</li>
<li><p>调整方法 ： K2节点<code>左旋一次</code>变成<code>LL型</code>，再在K3节点<code>大右旋一次</code>即可。</p>
</li>
</ul>
<h3 id="RR型与RL型只是上面两种的对称模式"><a href="#RR型与RL型只是上面两种的对称模式" class="headerlink" title="RR型与RL型只是上面两种的对称模式"></a>RR型与RL型只是上面两种的对称模式</h3><h3 id="SB树（课后学习，根据节点数量调整）"><a href="#SB树（课后学习，根据节点数量调整）" class="headerlink" title="SB树（课后学习，根据节点数量调整）"></a>SB树（课后学习，根据节点数量调整）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214636.png" alt="image-20201221163858679" style="zoom:50%;">

<ul>
<li>用上面类似的方法判断节点数量，从而学习调整方法</li>
</ul>
<h2 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h2><ol>
<li>插入和删除以后，注意<code>重新计算树高</code>字段</li>
<li>引入了 <code>NIL 节点</code>，代替 NULL，NULL <code>不可访问</code>，NIL 是一个是<code>实际节点，可访问</code></li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n-&gt;lchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(n) (n-&gt;rchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(n) (n-&gt;h)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, h;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = <span class="number">0</span>, NIL-&gt;h = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;h = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哪边子树比较高就取哪边，同时 + 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_height</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;h = H(L(root)) &gt; H(R(root)) ? H(L(root)) : H(R(root)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(H(L(root)) - H(R(root))) &lt;= <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;h &gt; root-&gt;rchild-&gt;h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;h &lt; root-&gt;lchild-&gt;rchild-&gt;h) &#123;</span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;h &lt; root-&gt;rchild-&gt;lchild-&gt;h) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱的循环条件修改为NIL，同时这个版本仍是bug版本，因为仅仅判别了度为2的节点</span></span><br><span class="line"><span class="function">Node *<span class="title">predcessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predcessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>,</span><br><span class="line">          root-&gt;key, root-&gt;h,</span><br><span class="line">          root-&gt;lchild-&gt;key,</span><br><span class="line">          root-&gt;rchild-&gt;key</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼编码</title>
    <url>/2021/01/10/0011.%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="headerlink" title="哈夫曼树与哈夫曼编码"></a>哈夫曼树与哈夫曼编码</h2><h2 id="一、内容"><a href="#一、内容" class="headerlink" title="一、内容"></a>一、内容</h2><ol>
<li>直观的了解哈弗曼树与哈弗曼编码</li>
<li>证明：哈弗曼编码是最优的变长编码</li>
</ol>
<h2 id="二、前置知识"><a href="#二、前置知识" class="headerlink" title="二、前置知识"></a>二、前置知识</h2><h3 id="什么是编码"><a href="#什么是编码" class="headerlink" title="什么是编码"></a>什么是编码</h3><p>‘a’ = 97 = $(0110\ 0001)_2$</p>
<p>‘0’ = 48 = $(0011\ 0000)_2$</p>
<p>注意：任何信息，在计算机中，都是二进制存储的</p>
<p>编码作用 ： 把一段二进制映射为人类看得懂的字符！</p>
<p>信息：”aa00” = $01100001、01100001、00110000、00110000$</p>
<p>一台计算机<code>传输到</code>另外一台计算机，传输 32 个比特位</p>
<p>假设：计算机的网络是 32bit/s。所以用时：1 s</p>
<p>特定场景：只有 a,b,0,1 四种字符需要传输</p>
<p>海贼班编码（自创）：a:00, b: 01, 0: 10, 1: 11</p>
<p>“aa00” = 00001010</p>
<p>在带宽不变的情况下，当前只需要传输 0.25s</p>
<h3 id="定长与变长编码"><a href="#定长与变长编码" class="headerlink" title="定长与变长编码"></a>定长与变长编码</h3><ol>
<li><code>Ascii 编码</code> 和 <code>特定场景下的海贼班编码</code>，都属于<code>定长编码</code>（长度一定）</li>
<li>对于每一个字符，编码<code>长度相同</code>，这就是<code>定长编码</code></li>
<li>【大家自行补充】UTF-8编码，是变长编码，UTF-16，是定长编码</li>
<li>对于每一个字符，编码<code>长度不相同</code>，这就是<code>变长编码</code></li>
<li>将<code>定长编码</code>，看成是<code>变长编码</code>的<code>特例</code></li>
<li>变长编码，一定<code>不差于</code>定长编码</li>
</ol>
<h3 id="变长编码应用场景"><a href="#变长编码应用场景" class="headerlink" title="变长编码应用场景"></a>变长编码应用场景</h3><p>特定场景：</p>
<ol>
<li>只有四种字符 : ab01</li>
<li>a: 0.8, b: 0.05, 0: 0.1, 1: 0.05</li>
</ol>
<p>平均编码长度：</p>
<p>$l_i$：第 i 种字符，编码长度</p>
<p>$p_i$：第 i 种字符，出现概率</p>
<p>平均编码长度（期望值）：$avg(l) = \sum{l_i}\times{p_i}$</p>
<blockquote>
<p>意义 ： 用于评估传输特定信息量所需要的比特位数量，数量越小越好。</p>
</blockquote>
<p>假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位</p>
<p>海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i}=2$</p>
<blockquote>
<p>定长编码的<code>平均编码</code>长度 = 定长编码的长度（定长）</p>
</blockquote>
<p>新·海贼班编码：</p>
<p>a: 1</p>
<p>b: 01</p>
<p>0: 000</p>
<p>1: 001</p>
<blockquote>
<p>设计<code>变长编码</code>的时候，前缀切记<code>不能重叠</code>！！！如： a : 1， b : 110，这个是不行的，因为b中读到第一个 1 的时候已经跟a 的编码符合，直接编码成 a 了读不到 b！！！</p>
</blockquote>
<p>平均编码长度：$1<em>0.8+2</em>0.05+3<em>0.1+3</em>0.05=1.35$</p>
<p>100个字符，传输135个比特位</p>
<h2 id="三、哈弗曼编码"><a href="#三、哈弗曼编码" class="headerlink" title="三、哈弗曼编码"></a>三、哈弗曼编码</h2><ol>
<li>首先，<code>统计</code>得到<code>每一种</code>字符的<code>概率</code></li>
<li>将 <code>n 个</code>字符，建立成一棵<code>哈弗曼树</code></li>
<li>每一个字符，都落在<code>叶子结点</code>上</li>
<li>按照<code>左0，右1</code>的形式，将编码读取出来</li>
</ol>
<blockquote>
<p>因为所有字符都落在<code>叶子节点</code>上，所以<code>没有</code>一个字符是另一个字符的<code>前缀</code>！</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309113003.png" alt="image-20201227090511381" style="zoom:50%;">

<p>得到新编码：</p>
<p>a: 0 | b: 110 | 0: 10 | 1: 111</p>
<p>平均编码长度：$1<em>0.8+3</em>0.05+2<em>0.1+3</em>0.05=1.3$</p>
<p>结论：哈弗曼编码，是<code>最优的变长编码</code></p>
<blockquote>
<p>如果提到<code>变长编码</code>，就必须想到<code>哈夫曼编码</code></p>
</blockquote>
<h2 id="四、公式证明（证明-avg-l-sum-l-i-times-p-i-的值最小）"><a href="#四、公式证明（证明-avg-l-sum-l-i-times-p-i-的值最小）" class="headerlink" title="四、公式证明（证明 $avg(l) = \sum{l_i}\times{p_i}$ 的值最小）"></a>四、公式证明（证明 $avg(l) = \sum{l_i}\times{p_i}$ 的值最小）</h2><blockquote>
<p>哈夫曼编码什么时候会<code>退化</code>成定长编码呢？</p>
<p>当所有字符的概率都一样的时候的就会退化成定长编码！所以定长编码能做的事情，哈夫曼编码一定能做到！</p>
</blockquote>
<blockquote>
<p>哈夫曼编码最优，优在平均编码长度</p>
</blockquote>
<ol>
<li>首先表示平均编码长度，求解公式最优解</li>
<li>最终，和熵与交叉熵之间的关系</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309144840.png" alt="image-20201227102527197" style="zoom: 33%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309145042.png" alt="image-20210309145036420" style="zoom: 67%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309145111.png" alt="image-20201227102725731" style="zoom: 33%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309145227.png" alt="image-20210309145221608" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309145334.png" alt="image-20210309145326272" style="zoom:50%;">

<h3 id="代码展示："><a href="#代码展示：" class="headerlink" title="代码展示："></a>代码展示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line">    __typeof(a) __c = a; \</span><br><span class="line">    a = b, b = __c; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">double</span> per)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;ch = ch;</span><br><span class="line">    p-&gt;p = per;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">CombinNode</span><span class="params">(Node *a, Node *b)</span> </span>&#123;</span><br><span class="line">    Node *p = getNewNode(<span class="number">0</span>, a-&gt;p + b-&gt;p);</span><br><span class="line">    p-&gt;lchild = a;</span><br><span class="line">    p-&gt;rchild = b;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pick_min</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[n]-&gt;p &gt; arr[j]-&gt;p) &#123;</span><br><span class="line">            swap(arr[n], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getHaffmanTree</span><span class="params">(Node **arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pick_min(arr, n - i);</span><br><span class="line">        pick_min(arr, n - i - <span class="number">1</span>);</span><br><span class="line">        arr[n - i - <span class="number">1</span>] = CombinNode(arr[n - i], arr[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __output_encode(Node *root, <span class="keyword">char</span> *str, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    str[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %s\n&quot;</span>, root-&gt;ch, str);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    str[k] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;lchild, str, k + <span class="number">1</span>);</span><br><span class="line">    str[k] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    __output_encode(root-&gt;rchild, str, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_encode</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    __output_encode(root, str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Node **arr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    arr = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lf&quot;</span>, ch, &amp;p);</span><br><span class="line">        arr[i] = getNewNode(ch[<span class="number">0</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = getHaffmanTree(arr, n);</span><br><span class="line">    output_encode(root);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法（多种、单模）</title>
    <url>/2021/01/11/0012.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="字符串的匹配算法"><a href="#字符串的匹配算法" class="headerlink" title="字符串的匹配算法"></a>字符串的匹配算法</h1><h2 id="一、暴力匹配算法（单模匹配）"><a href="#一、暴力匹配算法（单模匹配）" class="headerlink" title="一、暴力匹配算法（单模匹配）"></a>一、暴力匹配算法（单模匹配）</h2><ol>
<li>字符串匹配问题：单模匹配问题，顾名思义，只有一个模式串（待查找串）</li>
<li>在一个文本串中查找一个“模式串”是否存在过。</li>
<li>方式：依次对齐模式串和文本串的<code>每一位</code>，直到匹配成功。</li>
<li>关键：不重不漏的找到答案</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210114220209.png" alt="image-20210114220207950" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210114220226.png" alt="image-20210114220224100" style="zoom:50%;">

<h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">			flag = flag &amp;&amp; (s[i + j] &amp;&amp; s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;brute_force(%s, %s) = %d\n&quot;</span>, s, t, brute_force(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="二、KMP-算法"><a href="#二、KMP-算法" class="headerlink" title="二、KMP 算法"></a>二、KMP 算法</h2><ol>
<li><p>KMP 算法中，模式串中的<code>第三部分的重要性</code></p>
</li>
<li><p><code>第三部分</code>是可以帮助我们<code>加快匹配速度</code>的，<code>避免</code>掉大量<code>无用</code>的<code>匹配</code>尝试</p>
</li>
<li><p>KMP 算法保证不漏：第三部分匹配到的是模式串的<code>最长前缀</code></p>
</li>
<li><p>第三部分<code>紧挨着失配</code>位置。</p>
</li>
<li><p>普通编码：获得 NEXT 数组，使用 NEXT 数组</p>
<blockquote>
<p>next 数组：i 匹配成功，i + 1 失败，i 位置最长匹配的前缀位置</p>
</blockquote>
</li>
<li><p>高级编码：抽象化了一个<code>状态机模型</code>，j 所指向的就是<code>状态机中的位置</code></p>
</li>
<li><p>getNext 方法相当于根据输入字符，进行状态跳转，实际上就是改变 j 的值</p>
</li>
<li><p>最坏时间复杂度 ： $O(mn)$ ，有优化方法</p>
</li>
</ol>
<blockquote>
<p>文本串的内容是未知的，模式串的内容则是已知的，可以提前对模式串的内容进行处理。</p>
<p>模式串的失配的位置在每一位都有可能，所以需要处理每一位的第三部分字符串的信息，即 next 数组。</p>
</blockquote>
<blockquote>
<p>正常的时候，简单单模匹配的话，用 sunday 算法就可以了，但是KMP算法之所以需要学习，是因为它存在一个状态机的高级思维模式。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210114215428.png" alt="image-20210114215426449" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210114223933.png" alt="image-20210114223931354" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210114224653.png" alt="image-20210114224651489" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115085710.png" alt="image-20210115085708833" style="zoom:50%;">

<h4 id="普通代码："><a href="#普通代码：" class="headerlink" title="普通代码："></a>普通代码：</h4><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210119154803.png" alt="image-20210119144402289"> </p>
<h4 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">int</span> &amp;j, <span class="keyword">char</span> input, <span class="keyword">int</span> *next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; t[j + <span class="number">1</span>] != input) j = next[j];</span><br><span class="line">    <span class="keyword">if</span> (t[j + <span class="number">1</span>] == input) j += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n + <span class="number">1</span>);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; t[i]; i++) next[i] = getNext(t, j, t[i], next);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getNext(t, j, s[i], next) != n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kmp(%s, %s) = %d\n&quot;</span>, s, t, kmp(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="三、SUNDAY-算法"><a href="#三、SUNDAY-算法" class="headerlink" title="三、SUNDAY 算法"></a>三、SUNDAY 算法</h2><ol>
<li><p>SUNDAY 算法理解的核心，在于理解<code>黄金对齐点位</code></p>
</li>
<li><p>是文本串的匹配尾部，一定会出现在模式串中的字符</p>
</li>
<li><p>应该和模式串中最后一位出现该字符的位置对齐</p>
</li>
<li><p>第一步：预处理每一个字符在模式串中最后一次出现的位置</p>
</li>
<li><p>第二步：模拟暴力匹配算法过程，失配的时候，文本串指针根据预处理信息向后移动若干位</p>
</li>
<li><p>最快时间复杂度：$O(n/m)$，即假设文本串100，模式串10，则最快的话，$100/10 = 10$ 次移动就完事了，很难达到最差的时间复杂度</p>
</li>
<li><p><a href="https://www.cnblogs.com/hsluoyang/p/12939275.html">动画展示</a></p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115093613.png" alt="image-20210115093612053" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115093629.png" alt="image-20210115093627104" style="zoom:50%;">

<blockquote>
<p>查找文章中一个单词，此算法最快！</p>
<p>如果文本串中存在模式串没有的字符，直接跳到虚拟位置，即模式串的 -1 虚拟位。 </p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115095755.png" alt="image-20210115095753935" style="zoom:50%;">

</li>
</ol>
<h4 id="代码演示：-2"><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> offset[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(t), m = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) offset[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; i++) offset[t[i]] = n - i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + n &lt;= m; i += offset[s[i + n]]) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j] &amp;&amp; flag; j++) &#123;</span><br><span class="line">            <span class="comment">// 等价于 flag = (flag &amp;&amp; (s[i + j] == t[j]));</span></span><br><span class="line">            flag = flag &amp;&amp; (s[i + j] == t[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sunday(%s, %s) = %d\n&quot;</span>, s, t, sunday(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="四、字符串的哈希匹配算法"><a href="#四、字符串的哈希匹配算法" class="headerlink" title="四、字符串的哈希匹配算法"></a>四、字符串的哈希匹配算法</h2><blockquote>
<p>单模匹配算法、依旧是暴力匹配、面试中常用的方法</p>
</blockquote>
<ol>
<li>可以使用哈希操作判断两个字符串是否相等</li>
<li>哈希值不同的话，两个字符串一定不相等，从而就不需要按位比较了</li>
<li>$H = (\sum_{k=0}^{n-1}{C_k\times base^k})%P$</li>
<li>在文本串上，每一位字符串哈希值的前缀和，方便一会求区间和</li>
<li>$H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}%P $</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309152252.png" alt="image-20210309152244989" style="zoom:50%;">

<p>快速求逆元的推导过程：<br>$$<br>\begin{aligned}<br>x\times x^{-1}&amp;\equiv1\ (mod\ P) \<br>令：P%x&amp;=r ,P/x = k\<br>P &amp;= kx+r \<br>kx+r &amp;\equiv0\ (mod\ P) \<br>kr^{-1}+x^{-1} &amp;\equiv0\ (mod\ P) \<br>x^{-1} &amp;\equiv-kr^{-1}\ (mod\ P)<br>\end{aligned}<br>$$</p>
<blockquote>
<p>取余运算下的逆元：$(x_1 \times x_2) % P = 1$ 则 $x_1$ 与 $x_2$ 互为逆元。 </p>
<p>可以把除法变成乘法，比如 $ (2 \times 4) % 7= 1$， 则 $（16 / 4） % 7 = 4$  等价于 $（16 \times 2）% 7 = 4$.</p>
<p>这种求逆元的方式，比扩展欧几里得要快！</p>
<p>推导公式：把求 $x$ 的逆元转换成求 $r$ 的逆元，即把一个大问题转为一个小问题。</p>
<p><code>P 必须取素数！不然可能出现inv[0]的情况</code></p>
</blockquote>
<h4 id="代码演示（逆元）"><a href="#代码演示（逆元）" class="headerlink" title="代码演示（逆元）"></a>代码演示（逆元）</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_n 1000</span></span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        inv[i] = ((-(<span class="number">7</span> / <span class="number">2</span>) * inv[<span class="number">7</span> % i]) % <span class="number">7</span> + <span class="number">7</span>) % <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; inv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N 1000000</span><br><span class="line">#define P 9973 &#x2F;&#x2F;必须是素数</span><br><span class="line">#define base 13</span><br><span class="line">long long H[MAX_N + 5];</span><br><span class="line">long long K[MAX_N + 5]; &#x2F;&#x2F;base的i次方对base取模</span><br><span class="line">long long inv[P]; &#x2F;&#x2F;1 到 p - 1 模 P 的逆元</span><br><span class="line">char s[MAX_N + 5];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    inv[1] &#x3D; 1;</span><br><span class="line">    for (long long i &#x3D; 2; i &lt; P; i++) &#123;</span><br><span class="line">        inv[i] &#x3D; ((-(P &#x2F; i) * inv[P % i]) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    K[0] &#x3D; 1;</span><br><span class="line">    for (long long i &#x3D; 1; i &lt;&#x3D; MAX_N; i++) &#123;</span><br><span class="line">        K[i] &#x3D; (K[i - 1] * base) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    H[0] &#x3D; 0;</span><br><span class="line">    for (long long i &#x3D; 1; s[i]; i++) &#123;</span><br><span class="line">        H[i] &#x3D; (H[i - 1] + K[i] * s[i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long getH(long long l, long long r) &#123;</span><br><span class="line">    return ((H[r] - H[l - 1]) % P * inv[K[l]] % P + P) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long isSame(long long i, long long j, long long n) &#123;</span><br><span class="line">	for (long long k &#x3D; 0; k &lt; n; k++) &#123;</span><br><span class="line">		if (s[i + k] - s[j + k]) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">    long long m, l1, l2, r1, r2;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%lld&quot;, &amp;m);</span><br><span class="line">    for (long long i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        long long val1 &#x3D; getH(l1, r1);</span><br><span class="line">        long long val2 &#x3D; getH(l2, r2);</span><br><span class="line">        long long  n1 &#x3D; r1 - l1 + 1, n2 &#x3D; r2 - l2 + 1;</span><br><span class="line">        if (n1 - n2 || val1 - val2) &#123;</span><br><span class="line">            printf(&quot;No\n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isSame(l1, l2, n1)) &#123;</span><br><span class="line">                printf(&quot;Yes\n&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot;No\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="五、shift-and-算法"><a href="#五、shift-and-算法" class="headerlink" title="五、shift_and 算法"></a>五、shift_and 算法</h2><blockquote>
<p>把模式串换一种形式表现，这样后续的匹配中，跟模式串其实没什么关系了。</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309152650.png" alt="image-20210115145658276" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309152658.png" alt="image-20210309152614701" style="zoom: 67%;">
</blockquote>
<ol>
<li><p>把模式串中出现过的字符存进一个数组 $d$ 中，并根据该字符在模式串的位置，把字符转换成二进制</p>
<blockquote>
<p>如上图 $a$ 只在第0位以及第3位出现过，所以把0跟3标为1，其他位置标为0，读取时，应该从左到右读取二进制。（与字符串的二进制编码顺序是相反的）</p>
</blockquote>
</li>
<li><p>第一步对模式串做特殊处理，把每一种字符出现的位置，转换成相应的二进制编码</p>
</li>
<li><p>后续匹配的过程中跟模式串<code>一毛钱关系都没有</code></p>
</li>
<li><p>$p_i = (p_{i-1}&lt;&lt;1 | 1) &amp; d[s_i]$</p>
</li>
<li><p>$p_i$第 j 位二进制为1，代表<code>当前位置为结尾</code>，可以<code>匹配成功</code>模式串的<code>第 j 位</code>，即前 <code>j + 1</code>位</p>
<blockquote>
<p>这里，p 值得高位在右边，代码里面的 p 值，高位在左边！！！</p>
</blockquote>
</li>
<li><p>时间复杂度恒定在：$ O(n) $</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115150549.png" alt="image-20210115150547475" style="zoom:50%;">

<blockquote>
<p>个人理解：p的来源</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309152912.png" alt="image-20210309152909209" style="zoom: 67%;">
</blockquote>
<h4 id="代码演示：-3"><a href="#代码演示：-3" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; n++, i++) d[t[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; d[s[i]];</span><br><span class="line">        <span class="comment">//最高位为1，则说明匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>))) <span class="keyword">return</span> i - n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>], t[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s, t) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;shift_and(%s, %s) = %d\n&quot;</span>, s, t, shift_and(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

</li>
</ol>
<blockquote>
<p>如果字符串太长，可以把 $d$ 跟 $p$ 修改下数据结构，只要让这个数据结构可以支持<code>左移、或、与</code>三种运算即可。</p>
</blockquote>
<blockquote>
<p>shift_and 算法主要是用来解决类似下面的正则表达式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115201332.png" alt="image-20210115201330937"></p>
<p>这个正则表达式，其实就是一个模式串。比如 adef，就可以匹配上面的正则表达式。</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2021/01/12/0013.%20%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="字典树结构"><a href="#字典树结构" class="headerlink" title="字典树结构"></a>字典树结构</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210115202810.png" alt="image-20210115202809011" style="zoom:50%;">

<ol>
<li>也叫做：前缀索引树</li>
<li>把每个字符串按照前缀的顺序插入到树形结构中</li>
<li>字典树可以用于字符串的排序，时间复杂度 $O(n)$</li>
</ol>
<blockquote>
<p>白色：当前节点不独立成词；</p>
<p>红色：当前节点独立成词。</p>
</blockquote>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>];</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *p, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>) p-&gt;next[ind] = getNewNode();</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root, <span class="keyword">int</span> k, <span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">// k 是指当前在第几层</span></span><br><span class="line">    s[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        s[k] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">        output(root-&gt;next[i], k + <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    output(root, <span class="number">0</span>, str);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="七、海贼-OJ-282-最大异或和"><a href="#七、海贼-OJ-282-最大异或和" class="headerlink" title="七、海贼 OJ-282-最大异或和"></a>七、海贼 OJ-282-最大异或和</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309153645.png" alt="image-20210309153637692" style="zoom:50%;">

<ol>
<li>思考：如何使得异或结果尽可能大</li>
<li>结论：参与异或运算的两个数字，参与异或运算的每一位尽可能不同</li>
<li>问题转换为：确定一个数字的情况下，找到从高为到低位与当前数字尽量不同的另外一个数字</li>
<li>把每个数字看成一个二进制字符串，插入到字符串中，采用贪心策略进行选择</li>
</ol>
<h3 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 31</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Node *next[<span class="number">2</span>];</span><br><span class="line">&#125; tree[MAX_N * BASE + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">Node *<span class="title">getNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tree[cnt++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !!(x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNode();</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = !(x &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind]) &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            root = root-&gt;next[ind];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root-&gt;next[!ind];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> val[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, a;</span><br><span class="line">    Node *root = getNode();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a, n--;</span><br><span class="line">    insert(root, a);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        ans = max(query(root, a), ans);</span><br><span class="line">        insert(root, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/2021/01/13/0014.%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="AC自动机（多模匹配下的效率问题）"><a href="#AC自动机（多模匹配下的效率问题）" class="headerlink" title="AC自动机（多模匹配下的效率问题）"></a>AC自动机（多模匹配下的效率问题）</h1><h2 id="多模匹配问题"><a href="#多模匹配问题" class="headerlink" title="多模匹配问题"></a>多模匹配问题</h2><ol>
<li><p>有多个模式串的匹配问题，就是多模匹配问题</p>
</li>
<li><p>Step1：多个模式串，建立成一棵字典树</p>
</li>
<li><p>Step2：和<code>文本串的每一位</code>对齐匹配，模拟暴力匹配算法的过程</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309181041.png" alt="image-20210309181034354" style="zoom: 67%;">



</li>
</ol>
<h2 id="AC-自动机的思想"><a href="#AC-自动机的思想" class="headerlink" title="AC 自动机的思想"></a>AC 自动机的思想</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309181123.png" alt="image-20210309181113236" style="zoom: 67%;">

<ol>
<li><p>当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he</p>
</li>
<li><p>she 对应了字典树中的节点 P，he 对应了字典树中的节点Q</p>
</li>
<li><p>P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程</p>
</li>
<li><p>在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作</p>
</li>
<li><p>这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】</p>
</li>
<li><p>AC 自动机 = Trie + Fail 指针</p>
</li>
<li><p>子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】</p>
</li>
<li><p>没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）</p>
</li>
<li><p>通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态</p>
</li>
<li><p>第二种理解：当前状态，并不代表唯一状态。</p>
<blockquote>
<p>为了编程方便，根节点的默认等价关系设置为空节点。</p>
</blockquote>
</li>
</ol>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>], *<span class="title">fail</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">int</span> node_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node_cnt += <span class="number">1</span>;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    p-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;str = strdup(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_ac</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node **q = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * (node_cnt + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        root-&gt;next[i]-&gt;fail = root;</span><br><span class="line">        q[tail++] = root-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        Node *p = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            Node *c = p-&gt;next[i], *k = p-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; k-&gt;next[i] == <span class="literal">NULL</span>) k = k-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">NULL</span>) k = root;</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;next[i]) k = k-&gt;next[i];</span><br><span class="line">            c-&gt;fail = k;</span><br><span class="line">            q[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">    Node *p = root, *q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p-&gt;next[ind] == <span class="literal">NULL</span>) p = p-&gt;fail;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) p = root;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind]) p = p-&gt;next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;find : %s\n&quot;</span>, q-&gt;str);</span><br><span class="line">            q = q-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    build_ac(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    match(root, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><strong>AC 自动机优化：</strong>使用路径压缩思想，使状态转移时可以一步跳转到目标状态。（废物利用）</p>
<ul>
<li><p>优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。</p>
</li>
<li><p>优化后的AC自动机的时间复杂度：<code>O(n)</code></p>
</li>
</ul>
<h4 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag, tag[BASE]; <span class="comment">//1: trie, 0: ac， 方便最后的 clear 释放</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[<span class="title">BASE</span>], *<span class="title">fail</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">int</span> node_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node_cnt += <span class="number">1</span>;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    p-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[ind] == <span class="literal">NULL</span>) root-&gt;next[ind] = getNewNode();</span><br><span class="line">        root-&gt;tag[ind] = <span class="number">1</span>;</span><br><span class="line">        root = root-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    root-&gt;str = strdup(str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_ac</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node **q = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * (node_cnt + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;next[i] = root;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;next[i]-&gt;fail = root;</span><br><span class="line">        q[tail++] = root-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        Node *p = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            Node *c = p-&gt;next[i], *k = p-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;next[i] = k-&gt;next[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; k-&gt;next[i] == <span class="literal">NULL</span>) k = k-&gt;fail;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">NULL</span>) k = root;</span><br><span class="line">            <span class="keyword">if</span> (k-&gt;next[i]) k = k-&gt;next[i];</span><br><span class="line">            c-&gt;fail = k;</span><br><span class="line">            q[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">    Node *p = root, *q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;find : %s\n&quot;</span>, q-&gt;str);</span><br><span class="line">            q = q-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;tag[i]) clear(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    build_ac(root);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    match(root, str);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="预习资料：【数据结构】-gt-字符串统计"><a href="#预习资料：【数据结构】-gt-字符串统计" class="headerlink" title="预习资料：【数据结构】&gt; 字符串统计"></a>预习资料：【数据结构】&gt; 字符串统计</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309181847.png" alt="image-20210309181843798"></p>
<ol>
<li>AC 自动机裸题</li>
<li>解题的关键，在于如何维护每一个单词的计数量</li>
<li>使用幼儿园必知必会的指针技巧维护</li>
<li><strong>船长翻车：</strong>题目数据中给出的单词会有重复</li>
</ol>
<h3 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag, *cnt;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">26</span>], fail;</span><br><span class="line">&#125; tree[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"><span class="keyword">int</span> *ans[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>, cnt = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNewNode</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree[p].next[ind] == <span class="number">0</span>) tree[p].next[ind] = getNewNode();</span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    tree[p].flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[p].cnt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tree[p].cnt = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        tree[p].cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    tree[root].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[root].next[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            tree[root].next[i] = root;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[tree[root].next[i]].fail = root;</span><br><span class="line">        q[tail++] = tree[root].next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = q[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = tree[p].next[i], k = tree[p].fail;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                tree[p].next[i] = tree[k].next[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = tree[k].next[i];</span><br><span class="line">            tree[c].fail = k;</span><br><span class="line">            q[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = str[i] - <span class="string">&#x27;a&#x27;</span>, q;</span><br><span class="line">        p = tree[p].next[ind];</span><br><span class="line">        q = p;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[q].flag) &#123;</span><br><span class="line">                (*tree[q].cnt) += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q = tree[q].fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        ans[i] = insert(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    build();</span><br><span class="line">    match(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, *ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>双数组字典树</title>
    <url>/2021/01/14/0015.%20%E5%8F%8C%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="双数组字典树"><a href="#双数组字典树" class="headerlink" title="双数组字典树"></a>双数组字典树</h1><h2 id="传统字典树的缺点"><a href="#传统字典树的缺点" class="headerlink" title="传统字典树的缺点"></a>传统字典树的缺点</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309181251.png" alt="image-20210124153235264" style="zoom:50%;">

<ol>
<li>完全二叉树，实际存储结构是连续数组空间，思维逻辑结构是树型的</li>
<li>完全二叉树，节省了大量的存储边的空间（不用记录左右子树的地址，节省了存储边信息的空间）</li>
<li>优化思想：<code>记录式</code> 改 <code>计算式</code></li>
<li>$n$ 个节点的字典树，有效 使用 $n-1$ 条边，浪费了 $(k-1)*n+1$ 条边的存储空间</li>
<li>参考完全二叉树的优点，提出了双数组字典树</li>
</ol>
<blockquote>
<ul>
<li>空间换时间</li>
<li>字符串排序，时间复杂度<code>O(n)</code></li>
</ul>
</blockquote>
<blockquote>
<p>完全二叉树，是一种思维中的树形结构，而在实际中其实一段连续的数组空间。</p>
</blockquote>
<h2 id="双数组字典树-1"><a href="#双数组字典树-1" class="headerlink" title="双数组字典树"></a>双数组字典树</h2><ol>
<li><p>顾名思义，两个数组代表一棵字典树结构</p>
</li>
<li><p>base 数组信息<code>与子节点编号相关</code>，base + i 就是第 i 个子节点编号</p>
<blockquote>
<p>允许存在负值，所以独立成词的标识不能放在base数组</p>
</blockquote>
</li>
<li><p>check 数组信息负责做<code>【亲子鉴定】</code>，check 数组中用正负表示是否独立成词</p>
</li>
<li><p>不擅长进行动态插入操作，代价较大</p>
</li>
<li><p>一次建立，终身使用</p>
</li>
<li><p>为了方便，基于普通字典树实现的双数组字典树</p>
</li>
<li><p>增加了 fail 数组，可以完成基于双数组字典树的 AC 自动机</p>
</li>
<li><p>超小规模实验结果：双数组字典树压缩效率是 25 倍</p>
</li>
<li><p>非常方便的输出到文件中，进行机器之间的共享</p>
</li>
<li><p>课后作业：利用真实数据集，测试双数组字典树的压缩效率</p>
</li>
</ol>
<blockquote>
<ul>
<li><p>不存储边的信息。</p>
</li>
<li><p>用双数组字典树实现的一般是离线存储结构</p>
<ul>
<li>不擅长动态插入，一般只是用来查询</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_LEVEL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO_LEVEL 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, frm, args...) &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt;= MSG_LEVEL) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(frm,#<span class="meta">#args); \</span></span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(args...) LOG(INFO_LEVEL, args)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct Node &#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    struct Node *next[BASE];</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct DANode &#123;</span><br><span class="line">    <span class="keyword">int</span> base, check, fail;</span><br><span class="line">&#125; DANode;</span><br><span class="line"></span><br><span class="line">Node *getNewNode() &#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(p-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;next));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> code(<span class="keyword">char</span> c) &#123; <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> insert(Node *root, <span class="keyword">const</span> <span class="keyword">char</span> *str) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    Node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = code(str[i]);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[ind] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            p-&gt;next[ind] = getNewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> clear_trie(Node *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        clear_trie(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> get_base_value(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>, flag;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        base += <span class="number">1</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE &amp;&amp; flag; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[base + i].check) flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (flag == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> transform_double_array_trie(Node *root, DANode *tree, <span class="keyword">int</span> ind) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;flag) tree[ind].check = -tree[ind].check;</span><br><span class="line">    <span class="keyword">int</span> base = get_base_value(root, tree, ind);</span><br><span class="line">    tree[ind].base = base;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tree[base + i].check = ind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_ind = ind;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = transform_double_array_trie(root-&gt;next[i], tree, base + i);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; max_ind) max_ind = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_ind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dump_double_array_trie(DANode *tree, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    LOG_INFO(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LOG_INFO(<span class="string">&quot;%d %d %d\n&quot;</span>, tree[i].base, tree[i].check, tree[i].fail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> build_ac_base_double_array_trie(DANode *tree, <span class="keyword">int</span> max_ind) &#123;</span><br><span class="line">    <span class="keyword">int</span> *que = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (max_ind + <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    tree[<span class="number">1</span>].fail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> child_ind = tree[<span class="number">1</span>].base + i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[child_ind].check) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        tree[child_ind].fail = <span class="number">1</span>;</span><br><span class="line">        que[tail++] = child_ind;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = que[head++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = tree[p].base + i, k = tree[p].fail;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[c].check) != p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &amp;&amp; <span class="built_in">abs</span>(tree[tree[k].base + i].check) != k) k = tree[k].fail;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tree[tree[k].base + i].check) == k) k = tree[k].base + i;</span><br><span class="line">            tree[c].fail = k;</span><br><span class="line">            que[tail++] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(que);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    Node *root = getNewNode();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        cnt += insert(root, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> tree_size = <span class="keyword">sizeof</span>(DANode) * (cnt * BASE);</span><br><span class="line">    DANode *tree = (DANode *)<span class="built_in">malloc</span>(tree_size);</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, tree_size);</span><br><span class="line">    <span class="keyword">int</span> max_ind = transform_double_array_trie(root, tree, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> s1 = cnt * <span class="keyword">sizeof</span>(Node);</span><br><span class="line">    <span class="keyword">size_t</span> s2 = max_ind * <span class="keyword">sizeof</span>(DANode);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;trie(%lu Byte), double array trie(%lu Byte)\n&quot;</span>, s1, s2);</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;rate : %.2lf\n&quot;</span>, <span class="number">1.0</span> * s2 / s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_ind; i++) &#123;</span><br><span class="line">        LOG_DEBUG(<span class="string">&quot;(%d | %d, %d)\t&quot;</span>, i, tree[i].base, tree[i].check);</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>) LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    build_ac_base_double_array_trie(tree, max_ind);</span><br><span class="line">    dump_double_array_trie(tree, max_ind);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    clear_trie(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="二叉字典树"><a href="#二叉字典树" class="headerlink" title="二叉字典树"></a>二叉字典树</h2><ol>
<li>计算机中所有信息都是二进制存储的</li>
<li>任何信息都可以看成一个二进制串</li>
<li>插入二进制串的字典树，就是二叉字典树</li>
<li>二叉字典树可以存储任意信息</li>
<li>节省空间，浪费时间，本质：时间换空间的算法思维</li>
<li>哈弗曼编码 + 二叉字典树 可能更配哦，既节省了空间，又在最大限度上节省了查找时间</li>
</ol>
<p>不积跬步，无以至千里。不积小流，无以成江海。</p>
<p><strong>建议：</strong>多看几本基本的算法书、【数论基础】、多接触离散型数学思维</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件及目录</title>
    <url>/2021/01/02/0017.%20%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="文件及目录"><a href="#文件及目录" class="headerlink" title="文件及目录"></a>文件及目录</h1><blockquote>
<p>借助系统提供的底层服务，去完成想做的东西！</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="预备基础"><a href="#预备基础" class="headerlink" title="预备基础"></a>预备基础</h3><ol>
<li>cp ：先从磁盘中找到文件，再拷贝出来，最后写到磁盘中的目标文件</li>
<li>mv：先从磁盘中找到文件，再拷贝出来写到磁盘中的目标文件，最后删除原文件</li>
<li>cat： 把文件读取出来，放到标准输出文件</li>
</ol>
<blockquote>
<p>这几个文件都是跟读写文件相关的命令！而这些读写之前，都要先打开文件，即 <code>open</code> 函数！</p>
</blockquote>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><code>flags</code>：标志，即打开<code>pathname</code> 文件，用<code>flag</code> 标志的方式打开。</li>
<li>放回一个新的<code>文件描述符</code> 或者 <code>-1</code>；</li>
<li>返回的文件描述符可以在<code>后续系统中被调用</code></li>
</ul>
<blockquote>
<p>被成功调用返回的文件描述符一定是当前进程中打开的最小数字！比如当前打开了 0、1、2、3、4 这五个文件，如果此时把 2 号文件关闭，然后打开第六个文件，则第六个文件返回的是 2 这个文件描述符，因为此时 2 是空置的描述符中最小的值。（也就是会补空！）</p>
</blockquote>
<blockquote>
<p>当打开了一个文件，创建了一个新的文件描述符的时候，系统内核中的全局表（管理所有文件的进程码）就会新增一条信息，表示该进程打开了该文件以及该文件的描述符、状态、偏移量等。 </p>
</blockquote>
<blockquote>
<p>打开文件后，文件指针默认在文件头部</p>
<p>文件描述 [file description]</p>
<ul>
<li>每次调用open会创建一个新的open文件描述，它是系统全局文件表中的一条信息<ul>
<li>记录文件偏移量和文件的状态</li>
</ul>
</li>
<li>[PS] 文件描述符是一个open文件描述的引用，不因pathname的改变而受影响</li>
</ul>
</blockquote>
<ul>
<li><code>flags</code> 中必须含有 <code>O_RDONLY</code>, <code>O_WRONLY</code>,  或者 <code>O_RDWR</code>。（只读、只写、可读可写）</li>
<li><code>O_CREAT</code> : 创建<ul>
<li>底层是一个int型数据，叫做位掩码<ul>
<li>32位，可表示32种状态，每一位表示一种状态</li>
<li>状态之间可使用与、或、异或的方式转换</li>
</ul>
</li>
</ul>
</li>
<li><code>O_TRUNC</code> : 截断</li>
<li><code>O_DIRECT</code> : 直接IO</li>
</ul>
<blockquote>
<p>直接 io： 直接写到内存中</p>
<p>缓冲 io ： 先放到缓存中，再存入内存中。（直到遇到回车或者程序结束符才会停止输出）</p>
<p>在磁盘中写的时候，也是类似的原理；输入一个字符，会先被系统放在缓冲中，如果在一段时间之内没有新数据写入，内核就会吧数据真正存放到内存中。（如果断电的话，缓存中的数据就会丢失！）</p>
</blockquote>
<ul>
<li><code>O_NONBLOCK</code> : 非阻塞IO，如果没有拿到数据，则直接返回一个 -1</li>
</ul>
<blockquote>
<p>阻塞 io ：会浪费资源，一定要等到数据输入才肯罢休</p>
<p>非阻塞 io ：需要比较频繁的擦看数据，避免错过拿到数据的时间</p>
</blockquote>
<ul>
<li><code>O_TMPFILE</code>: 系统运行时，会把数据放在这个临时文件夹中，当下次系统重启时，才会被清空</li>
</ul>
<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>从该文件描述符<code>fd</code> 中<code>尝试</code>读取<code>最多的到count字节</code>的数据到 <code>buff</code> 中。</p>
<blockquote>
<p>尝试读取，即有可能读不到那么多数据。</p>
</blockquote>
<ul>
<li><code>fd</code> : 前面文件返回的描述符</li>
<li><code>ssize_t</code> ：以<code>_t</code> 结尾的类型就是用户自定义类型 </li>
</ul>
<blockquote>
<p>返回值 <code>ssize_t</code>：读取的<code>字节数</code> 或 -1</p>
<ul>
<li>猜测：也是基本类型之一，可能是long long，可能是int</li>
<li>通过ctags一步步找具体类型：ctrl + ] 、ctrl + o <ul>
<li>int [32位系统下]；long int [64位系统下]</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>读取操作会从文件指针，即<code>offset</code> 位置开始。（<code>offset</code> 会自增，根据读取的进度自行增加，方便读取）</li>
<li><code>count = 0</code> 的时候会返回 0 或者无效。</li>
<li> <code>count &gt; SSIZE_MAX</code> 的时候会 返回一个未定义的值。</li>
</ul>
<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>从该文件描述符<code>fd</code> 中<code>尝试</code>写入<code>最多的到count字节</code>的数据到 <code>buff</code> 中。</p>
<ul>
<li>对于<code>seekable file（可搜索文件）</code>，将在<code>offset</code>处进行写入，并且<code>offect</code>将增加<code>实际写入的字节数</code>。 如果使用<code>O_APPEND(追加)</code>打开（2）文件，则在写入之前首先将<code>offset</code>设置为文件的<code>末尾</code>。</li>
</ul>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>关闭文件描述符<code>fd</code>（内核关闭该文件）。</p>
<p><code>不关闭的话，可能会存在危害！！有些会自动关闭，有些不会，如果一堆文件不关闭，可能会使得系统崩溃</code></p>
<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>打开一个<code>pathname</code>文件，并关联到一个<code>stream流</code>（关联到一个<code>字节河流</code>）</p>
<blockquote>
<p>这个<code>fopen</code> 才是<code>标准io</code>函数，之前的open 并不是一个<code>标准io</code>函数</p>
</blockquote>
<ul>
<li>FILE : 特殊文件指针，文件流</li>
<li>参数 ： <code>r、r+、w、w+、a、a+</code> 均是对一个<code>文件流</code>进行操作</li>
<li>返回值 ：成功则返回一个<code>FILE pointer</code>文件指针， 失败则返回<code>空指针</code>，并将<code>全局的错误变量</code>建立起来</li>
</ul>
<h3 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> sys_errlist[];</span><br><span class="line"><span class="keyword">int</span> sys_nerr;</span><br><span class="line"><span class="keyword">int</span> errno;       <span class="comment">/* Not really declared this way; see errno(3) */</span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>打印一个系统的错误信息（就是<code>&lt;errno.h&gt;</code> 里面的全局变量<code>errno</code></p>
<h3 id="fread-fwrite：二进制流的IO"><a href="#fread-fwrite：二进制流的IO" class="headerlink" title="fread\fwrite：二进制流的IO"></a>fread\fwrite：二进制流的IO</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><code>read</code> 返回的是 <code>ssize_t</code> ，这里返回<code>size_t</code></li>
<li>从<code>stream</code> 中读写数据到 <code>ptr</code> 中，每次读取的大小为<code>size</code>，总共读取的次数为<code>nmemb</code></li>
<li>返回成功写到 <code>item</code> 的个数（字节数），如果发生错误，返回值则是一个<code>小于size 的数字或者 0</code></li>
</ul>
<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>关闭一个<code>流stream</code>。</p>
<p><code>fclose</code>会刷新对应的<code>stream</code>（任何被写入的输出），因为标准IO里面的所有操作都是缓冲IO，所有需要<code>刷新fflush</code>，然后关闭该文件。</p>
<blockquote>
<p>缓冲中时，没有任何权利去执行任何操作，只能等待。</p>
</blockquote>
<blockquote>
<p>所有到<code>标准错误</code>的输出<code>stderr</code>都会无缓冲的输出，不用任何等待。</p>
</blockquote>
<blockquote>
<p>中途忘记参数的时候，直接在函数位置，按 <code>shift + k</code>就可以跳到<code>man手册</code> </p>
</blockquote>
<h3 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>打开一个目录，返回一个<code>目录流指针</code>。该目录流会移动到目录的<code>第一个文件</code>。</p>
<h3 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>返回<code>dirp目录</code>中的<code>下一个文件</code>，用结构体表示。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ftell</code> 与 <code>fseek</code> 都是用来锁定当前在<code>流中的位置</code>。</li>
</ul>
</blockquote>
<blockquote>
<p>传统的<code>offset</code>是以<code>字节</code>为单位，但在<code>目录</code>这里，<code>并不是</code>。</p>
</blockquote>
<h3 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>关闭当前目录。</p>
<h3 id="stat、fstat、-lstat、-fstatat"><a href="#stat、fstat、-lstat、-fstatat" class="headerlink" title="stat、fstat、 lstat、 fstatat"></a>stat、fstat、 lstat、 fstatat</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>获取一个文件的状态：当前它的所属者、属性等等。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond precision for the following timestamp fields. For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="getpwnam-getpwnam-r-getpwuid-getpwuid-r"><a href="#getpwnam-getpwnam-r-getpwuid-getpwuid-r" class="headerlink" title="getpwnam, getpwnam_r, getpwuid, getpwuid_r"></a>getpwnam, getpwnam_r, getpwuid, getpwuid_r</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpwnam_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct passwd *pwd, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, struct passwd **result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpwuid_r</span><span class="params">(<span class="keyword">uid_t</span> uid, struct passwd *pwd, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, struct passwd **result)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>获得<code>password</code> 的信息</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">    <span class="keyword">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="getgrnam-getgrnam-r-getgrgid-getgrgid-r"><a href="#getgrnam-getgrnam-r-getgrgid-getgrgid-r" class="headerlink" title="getgrnam, getgrnam_r, getgrgid, getgrgid_r"></a>getgrnam, getgrnam_r, getgrgid, getgrgid_r</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgrnam_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, struct group *grp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, struct group **result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgrgid_r</span><span class="params">(<span class="keyword">gid_t</span> gid, struct group *grp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, struct group **result)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>根据<code>gid</code> 获得<code>组</code></p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_name;        <span class="comment">/* group name */</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_passwd;      <span class="comment">/* group password */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   gr_gid;         <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>  **gr_mem;         <span class="comment">/* NULL-terminated array of pointers to names of group members */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="标准IO是缓冲IO"><a href="#标准IO是缓冲IO" class="headerlink" title="标准IO是缓冲IO"></a>标准IO是缓冲IO</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/1609911920001-L87o6NXvF6ArZMLc.png" alt="img"></p>
<ul>
<li>第一个<code>&quot;Hello world&quot;</code>直接输出，<code>stderr</code>没有缓冲</li>
<li>第二个<code>&quot;Hello world&quot;</code>本来会等<code>sleep</code>结束，无法输出到<code>stdout</code>，但是可以<code>立马输出</code>，通过<ul>
<li>手动刷新缓冲区：<code>fflush</code></li>
<li>输出换行</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令行解析</title>
    <url>/2021/01/01/0016.%20Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Linux-命令行解析"><a href="#Linux-命令行解析" class="headerlink" title="Linux 命令行解析"></a>Linux 命令行解析</h1><h2 id="getopt函数"><a href="#getopt函数" class="headerlink" title="getopt函数"></a>getopt函数</h2><h4 id="getopt-函数-：命令行解析函数"><a href="#getopt-函数-：命令行解析函数" class="headerlink" title="getopt 函数 ：命令行解析函数"></a>getopt 函数 ：命令行解析函数</h4><ul>
<li>头文件 ： &lt;unistd.h&gt;</li>
<li>原型 ： <code>int</code> getopt(int argc, char * const argv[], const char *optstring);</li>
</ul>
<blockquote>
<p>看到<code>int</code>很自然就可以想到是返回 成功 0，失败 -1， 或者返回个数</p>
</blockquote>
<ul>
<li>argc argv：由 <code>main 函数</code>的参数<code>直接传递</code>而来</li>
<li>optstring：一个包含准确选项字符的字符串</li>
<li>返回值：返回下一个选项</li>
</ul>
<blockquote>
<p>用 man 手册查询认识相关命令时，注重你要找的参数，不要过多的关注其变种。</p>
</blockquote>
<h4 id="getopt设置的一些全局变量"><a href="#getopt设置的一些全局变量" class="headerlink" title="getopt设置的一些全局变量"></a>getopt设置的一些全局变量</h4><ul>
<li>char *optarg ：指向当前选项参数（如果有）的指针</li>
<li>int optind  ：再次调用getopt()时的下一个argv 指针索引</li>
<li>int optopt() ： 最有一个已知选项</li>
<li>int opterr()  ：这个变量非零时，向stderr打印错误。默认为1。 </li>
</ul>
<h4 id="参数-optstring-详解"><a href="#参数-optstring-详解" class="headerlink" title="参数 optstring 详解"></a>参数 optstring 详解</h4><h5 id="getopt-函数的第三个参数optstring-是一个有所有合法的“可选字体”所组成的字符串。"><a href="#getopt-函数的第三个参数optstring-是一个有所有合法的“可选字体”所组成的字符串。" class="headerlink" title="getopt() 函数的第三个参数optstring 是一个有所有合法的“可选字体”所组成的字符串。"></a>getopt() 函数的第三个参数optstring 是一个有所有合法的“可选字体”所组成的字符串。</h5><ol>
<li><code>单个</code>字符，表示<code>选项</code></li>
<li>单个字符后加<code>一个冒号</code>“：”，表示该选项后<code>必须跟一个参数值</code>。参数<code>紧跟</code>在选项后或者<code>以空格</code>隔开。该参数的指针<code>赋给 optarg</code>。</li>
<li>单个字符后跟<code>两个冒号</code>“：：”，表示该选项后<code>可以带</code>参数<code>也可以不带</code>参数。但参数<code>必须紧跟</code>在选项后不能以空格隔开。该参数的指针赋给optarg。</li>
</ol>
<p>例子： “<code>xy:z::</code>”表示 <code>x</code> 选项没有选项参数，<code>y</code> 选项必须有参数，中间可有空格可没，<code>z</code> 参数可有参数选项。也可没有参数选项，但是如果有选项参数的话必须紧跟在选项之后不能有空格。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210101223051229.png" alt="image-20210101223051229"></p>
<ol>
<li><code>getopt</code> 内部有一个 <code>opt index</code> 指针（索引）的位置，指针会从 <code>0</code> 开始往后面扫描，<code>getopt</code> 每次会返回一个，直到找到最后一个的时候。会返回一个 <code>-1.</code></li>
<li>当 <code>!= -1</code>的时候，返回的是一个<code>int</code> 型的选项字符，通过选项字符判断</li>
</ol>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">int</span> a_flag = <span class="number">0</span>, l_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((opt = getopt(argc, argv, <span class="string">&quot;alm:o::&quot;</span>)) != <span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> :</span><br><span class="line">                a_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span> :</span><br><span class="line">                l_flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;msg = %s\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span> :</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;opt = %s\n&quot;</span>, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -al\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;optind = %d\noptopt = %d\n&quot;, optind, optopt);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞与非阻塞IO</title>
    <url>/2021/01/03/0018.%20%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h1><blockquote>
<p>多思考，诸如用阻塞IO的话，那能不能用非阻塞，哪个更优。</p>
</blockquote>
<h3 id="什么是阻塞"><a href="#什么是阻塞" class="headerlink" title="什么是阻塞"></a>什么是阻塞</h3><p>在运行过程中，有前提条件没完成，只能停止干等着不懂。</p>
<h3 id="什么是非阻塞"><a href="#什么是非阻塞" class="headerlink" title="什么是非阻塞"></a>什么是非阻塞</h3><p>在运行过程中，哪怕有前提条件没完成，也不会干等着，可以干其他事。</p>
<h3 id="读写文件时，阻塞与非阻塞的区别？"><a href="#读写文件时，阻塞与非阻塞的区别？" class="headerlink" title="读写文件时，阻塞与非阻塞的区别？"></a>读写文件时，阻塞与非阻塞的区别？</h3><ol>
<li>打开文件</li>
<li>把buf当作参数，用write系统调用，把数据传递给内核（用户态下沉到内核态），内核拿到数据，内核再把buf写到磁盘中（内核是快缓冲，这里主要以机械硬盘讨论），内核调动底层的IO设备管理，根据Inode与block放到磁盘的某一个位置。</li>
<li>阻塞：没写进去就等着，啥也不干</li>
<li>非阻塞：只通知，不管有没有写进去，继续做其他事</li>
</ol>
<h3 id="fcbtl：可以把一个文件变成非阻塞或者阻塞"><a href="#fcbtl：可以把一个文件变成非阻塞或者阻塞" class="headerlink" title="fcbtl：可以把一个文件变成非阻塞或者阻塞"></a>fcbtl：可以把一个文件变成非阻塞或者阻塞</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>操作文件描述符，</p>
<ul>
<li><code>fd</code> ：文件描述符</li>
<li><code>cmd</code> ：操作命令</li>
<li><code>arg</code> ：变参列表，<code>cmd</code> 的参数，存在的情况下，大多数是<code>int</code></li>
</ul>
<p>操作（cmd）：</p>
<ul>
<li>复制一个文件描述符</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210106190405728.png" alt="image-20210106190405728"></li>
<li>文件描述符标志</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108213937.png" alt="image-20210106190534232"></li>
<li>文件状态标志</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108213928.png" alt="image-20210106190511674"></li>
</ul>
<blockquote>
<p>把文件变成阻塞或者非阻塞，用到的<code>cmd</code>就是<code>F_SETFL</code>以及里面的<code>O_NONBLOCK</code></p>
</blockquote>
<p>返回值 ：</p>
<ul>
<li>成功返回</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108213945.png" alt="image-20210106190804916"></li>
</ul>
<blockquote>
<p>头文件的引入顺序有关联！！！尽量把自己写的头文件放在最后！！！</p>
</blockquote>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li> <code>O_NONBLOCK </code>是位掩码，它的每个比特都有含义，如果用<code>F_SETFL</code>设置一个确定的值，如果这样做，会破坏之前的<code>flag</code>，比如一个文件的权限是 <code>110</code>唯独没有<code>O_NONBLOCK </code>的权限，那这样操作（相当于赋值等于操作），就会直接<code>抹除</code>前面的权限，只留下<code>O_NONBLOCK </code>的权限，即<code>001</code>！！修改如下：</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">//考虑是否会出错</span></span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_block</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag &amp;= ~O_NONBLOCK;</span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>先用<code>F_GETFL</code>获得文件当前的状态（同时判断是否会出错），然后用<code>或操作</code>加上<code>O_NONBLOCK</code>，再把这个<code>flag</code>当成<code>F_SETFL</code>的参数。</li>
<li>如果变成<code>阻塞IO</code>的话，就先对<code>O_NONBLOCK</code>取反，再跟<code>flag</code>与操作。</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试程序，用 0， 1， 2来测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    make_nonblock(<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alin is %d years old! &lt;%d&gt;\n&quot;</span>, age, ret);</span><br><span class="line">    perror(<span class="string">&quot;scanf&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><code>0</code>号文件是<code>标准输入文件</code>，正常的话会等待用户输入，才不会阻塞，而改成了<code>非阻塞</code>之后，<code>scanf</code>看一眼<code>0</code>文件没有东西，就直接走人，瞬间结束，而输出的内容则是一个<code>未定义的变量</code></li>
<li><code>scanf </code>与 <code>标准输入流有没有打开</code>没有多大的联系。</li>
<li>用<code>sleep</code>让当前的程序睡眠（阻塞），什么都不做，这个时候<code>输入内容</code>，数据就可以到达<code>scanf</code>家门口，静静等待<code>scanf</code>读取。</li>
</ul>
<blockquote>
<p>每次打开程序，系统都会自动打开0，1，2文件，这三个文件不是凭空产生的，而是从其父亲<code>继承</code>过来的！！</p>
<p>C语言中所有大写的单词都是宏定义！</p>
<p><code>sleep</code>操作，类似于等数据来了，主动通知<code>scanf</code>多久之后开门迎接它！！（也可以不睡觉，去干其他事！而这，就是后面的<code>select</code>操作）。</p>
</blockquote>
<h3 id="select-：-IO多路复用，就是“影分身”同时干多件事"><a href="#select-：-IO多路复用，就是“影分身”同时干多件事" class="headerlink" title="select ： IO多路复用，就是“影分身”同时干多件事"></a>select ： IO多路复用，就是“影分身”同时干多件事</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="line">                  fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><code>监控多个文件</code>（数量必须小于系统一开始设定的数量，正常的话应该是1024），直到文件准备就绪，可执行相对应的IO操作。</p>
<ul>
<li><code>nfds</code> ：文件描述符数量，等于数字最大的文件描述符 + 1；</li>
<li><code>fd_set</code>：自定义类型，文件描述符集合，这个函数包括，<code>可读文件集合，可写文件结合，异常文件集合</code></li>
</ul>
<blockquote>
<p>集合操作 ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>struct timeval *timeout</code>时间结构体，超时。代表多久后算超时，超时就直接返回。</li>
<li>返回值 ：</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210106201938667.png" alt="image-20210106201938667"></li>
</ul>
<h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="comment">/* Watch stdin (fd 0) to see when it has input. */</span></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    <span class="comment">//把监控文件加入</span></span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;rfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait up to five seconds. */</span></span><br><span class="line">	<span class="comment">//睡眠时间</span></span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//监控一次</span></span><br><span class="line">    retval = select(<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">    <span class="comment">/* Don&#x27;t rely on the value of tv now! */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Data is available now.\n&quot;</span>);</span><br><span class="line">        <span class="comment">//scanf(&quot;%s&quot;, buff);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No data within five seconds.\n&quot;</span>);  <span class="comment">/* FD_ISSET(0, &amp;rfds) will be true. 超时的时候执行的程序*/</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210106202346199.png" alt="image-20210106202346199"></p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210106202605831.png" alt="image-20210106202605831"></p>
<ul>
<li>对 <code>0</code>文件进行监控，当有输入的时候，<code>./a.out</code>感知到了输入（<code>IO感知，最开始想实现的目标</code>），直接运行输入的命令，如果命令存在，则运行该命令，如果命令不存在，会被父进程<code>zsh</code>收走</li>
</ul>
<blockquote>
<p>如果最后加上<code>scanf(&quot;%s&quot;, buff);</code>则<code>./a.out</code>感知到的命令如果运行不成功，会被程序自己收走，而不是被系统<code>zsh</code>收走。</p>
<p>超时操作，相当于设置了一个定时任务，超过了，就直接结束返回。</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程</title>
    <url>/2021/01/04/0019.%20%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多进程（面试必问）"><a href="#多进程（面试必问）" class="headerlink" title="多进程（面试必问）"></a>多进程<code>（面试必问）</code></h1><h2 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h2><ul>
<li><p>说法 ： </p>
<ul>
<li>程序在内存中的镜像；</li>
<li>正在运行的程序（即程序实例化）</li>
</ul>
</li>
<li><p>什么是程序    </p>
<ul>
<li>编译好的可执行的二进制文件，放在磁盘中</li>
<li>在<code>linux</code> 中，程序是一个有<code>X权限</code>的<code>普通文件</code></li>
<li>应用 ： 程序的<code>集合</code>（程序 &lt; 应用）</li>
</ul>
</li>
<li><p>什么是线程</p>
</li>
</ul>
<h2 id="进程接口"><a href="#进程接口" class="headerlink" title="进程接口"></a>进程接口</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>创建一个子进程，返回一个<code>PID</code>；</p>
<ul>
<li><p>调用<code>fork</code> 的是<code>父进程</code>，产生的是<code>子进程</code></p>
<blockquote>
<p><code>子进程</code>就是<code>父进程</code>的<code>完全克隆体</code>，把父进程整一份代码都克隆过去。</p>
<p>但拷贝<code>一开始并没有发生</code>，只是<code>登记一下</code>，当<code>内存发生变化</code>（写入），拷贝才会发生（<code>写拷贝</code>），这样做可以节省内存空间。</p>
<p>子进程刚产生的时候，所有的<code>资源</code>以及<code>使用时间</code>都会被<code>清空归零</code>。</p>
</blockquote>
</li>
<li><p>父进程与子进程的<code>内存空间``是两个完全独立</code>的<code>进程空间</code>，不过<code>子进程的初始状态</code>是<code>父进程调用fork</code> 时的状态，内容一模一样。</p>
</li>
<li><p>子进程拥有独立且唯一的PID。</p>
</li>
<li><p>子进程不会继承父进程的<code>内存锁、异步IO操作、记录锁、计时器</code>。</p>
</li>
<li><p>返回值：返回<code>两个PID</code>，父进程中返回<code>子进程的PID</code>，子进程返回 <code>0</code>；</p>
</li>
</ul>
<blockquote>
<p>为什么会返回两个？因为<code>fork</code>产生子进程的时候，子进程跟父进程的<code>状态</code>是一模一样的，<code>子进程也有fork</code>，所以会返回两个，一个给子进程，一个给父进程。</p>
<p><code>子进程</code>可以通过<code>getpid()</code> 与 <code>getppid()</code>得到<code>自己与父进程的PID</code>，但<code>父进程</code>无法通过<code>其他函数</code>得到<code>子进程的PID</code>，所以<code>父进程</code>只能通过<code>fork</code> 得到<code>子进程的pid</code>，而<code>子进程</code>不需要记住<code>自己跟父进程的PID</code>，所以<code>fork</code> 返回的是<code>0</code>.</p>
</blockquote>
<h5 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h5><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>在这里，输入数据后（比如输入“<code>alin</code>”），会输出两次数据 （“<code>alinalin</code>”）。</p>
</li>
<li><p>原因：<code>标准io</code> 是<code>缓冲io</code>，没有<code>换行</code>或者<code>return 0</code>的话，<code>printf</code> 输出的数据会<code>一直放在缓冲区中</code>，而<code>fork</code> 是在<code>printf 之后</code>，所以<code>printf 输出</code>之后，<code>子进程才复制</code>，<code>子进程return 0，</code> <code>刷新了缓冲区</code>，使得<code>缓冲存放的printf 的内容</code>给输出来。</p>
</li>
<li><p>如果<code>printf</code> 加了一个<code>\n</code> 换行，就只会有<code>一个输出</code></p>
<blockquote>
<ol>
<li>如果没输出两个，是因为编译器被优化过了。</li>
<li>如果<code>fork</code> 放在<code>printf之前</code> ，那不用考虑，肯定是输出两个！</li>
</ol>
</blockquote>
</li>
</ul>
<h5 id="修改1"><a href="#修改1" class="headerlink" title="修改1"></a>修改1</h5><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Process!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>如果 <code>pid &lt; 0</code>，则是<code>fork出错</code>，最常见的原因是<code>内存不够</code>了。</p>
</li>
<li><p><code>pid = 0</code> ： 子进程； <code>pid &gt; 0</code>： 父进程</p>
</li>
<li><p>输出结果 ：  <code>Parent Process! Child Process!</code></p>
<blockquote>
<p>父进程<code>不一定会先执行</code>，但大概率会先执行，是否可以先执行，是由内核基于调度的算法决定的。</p>
<ul>
<li><code>cpu</code> 会给每个进程一定时间的运行时间，谁先运行完谁先输出</li>
<li>父进程在 <code>fork</code> 子进程之后，剩余时间不多，而子进程的时间完全没消耗，只能排在后面等待系统调度，所以会比父进程晚输出。</li>
<li>而如果有信号中断了父子进程的运行，等内核重新调度的时候，父子进程谁优先就说不准了。</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *wstatus)</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>等待进子程发生变化，返回一个<code>int 型</code>的<code>状态标识</code>，<code>0成功</code>，<code> 1中断</code></p>
<ul>
<li><p><code>wstatus</code> ： 存放子进程退出状态</p>
</li>
<li><p>子进程状态： <code>正常死亡，异常死亡，唤醒</code>。</p>
</li>
<li><p>子进程死亡，父进程收尸，其实就是内核释放子进程的资源</p>
</li>
<li><p>如果子进程成为“僵尸”，就会占用系统资源，可以在<code>top</code>中看到</p>
</li>
<li><p>子进程状态一改变，<code>wait</code> 会<code>立马</code>得到返回值。</p>
<blockquote>
<p>子进程死了，父进程也死了，则不会产生“僵尸”</p>
</blockquote>
</li>
</ul>
<h5 id="修改2"><a href="#修改2" class="headerlink" title="修改2"></a>修改2</h5><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Process!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait Status = %d\n&quot;</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>通过 <code>ps</code> 查看进程，后缀带着<code>&lt;defunct&gt;</code>就是僵尸进程，用<code>ps -aux | grep z</code> 就可以查探到将进程，可以用<code>kill</code>杀掉。也可以用 <code>top</code> 查看。</p>
</li>
<li><p>程序子进程输出后<code>return 1</code>，父进程收到<code>子进程状态值1</code>，输出 <code>256</code>，再<code>return 0</code>；</p>
<blockquote>
<p>为什么会输出256？看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/image-20210108210539686.png" alt="image-20210108210539686"></p>
</blockquote>
</li>
</ul>
<h5 id="修改3"><a href="#修改3" class="headerlink" title="修改3"></a>修改3</h5><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是第 %d 个孩子\n&quot;</span>, i);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>产生十个子进程，<code>fork</code>后<code>pid = 0</code>，直接<code>break</code>，子进程<code>不会再产生子进程</code>，直接打印输出，而<code>父进程继续循环</code>，从而实现产生十个子进程</li>
</ul>
<hr>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>用一个新的进程镜像替换当前的进程镜像。</p>
<blockquote>
<p><code>fork</code>复制产生的子进程，其后续的代码怎么运行，其实已经被父进程所规定，会跟父进程的后续代码一样，为了不跟父进程后续代码一样，有了<code>exec</code>一族函数</p>
</blockquote>
<ul>
<li><code>arg</code> 是前面 <code>path</code> 的参数</li>
<li> <code>execl()/execlp()/execle()</code>：<code>l</code>是 <code>list</code> 列表的意思，包含着参数<code>arg参数列表</code></li>
<li> <code>execv()/execvp()/execvpe()</code>：<code>v</code>是包含<code>argv</code>的意思，提供了一个<code>数组</code>，类似<code>main函数</code>的<code>argv</code>传递方式。</li>
<li><code>execle()/execvpe()</code>：允许给可执行程序传递一个<code>环境变量的参数envp</code></li>
<li><code>execlp()/execvp()/execvpe()</code>：复制<code>shell的过程</code>，寻找可执行程序</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        execl(<span class="string">&quot;vim&quot;</span>, <span class="string">&quot;vim&quot;</span>, <span class="string">&quot;3.exec.c&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In end!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After Child terminated\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>父进程有着完整的代码，<code>fork</code>之后，子进程也同样拥有父进程一样的代码，但在<code>execlp</code>之后，<code>子进程后面的代码完全不见</code>，所以<code>子进程execl后面</code>的<code>代码不会被执行</code>，但<code>父进程</code>再接受<code>子进程的fork返回值</code>之后，<code>照样执行</code>后面的代码。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC与高级进程管理</title>
    <url>/2021/01/05/0020.%20IPC%E4%B8%8E%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IPC-进程间通信"><a href="#IPC-进程间通信" class="headerlink" title="IPC: 进程间通信"></a>IPC: 进程间通信</h1><h2 id="作业要求（数字累加）"><a href="#作业要求（数字累加）" class="headerlink" title="作业要求（数字累加）"></a>作业要求（数字累加）</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210122200835.png" alt="image-20210122200833589"></p>
<h2 id="作业讲解"><a href="#作业讲解" class="headerlink" title="作业讲解"></a>作业讲解</h2><h3 id="1-start-与-end-的传参"><a href="#1-start-与-end-的传参" class="headerlink" title="1. start 与 end 的传参"></a>1. start 与 end 的传参</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:e:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                start = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> :</span><br><span class="line">                end = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -s start_num -e end_num\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start = %d\nend = %d\n&quot;</span>, start, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<blockquote>
<p><code>ln -s</code> ： 建立软链接</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305215419.png" alt="image-20210122203505318"></p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305215424.png" alt="image-20210122203610534"></p>
</blockquote>
<h3 id="2-INS"><a href="#2-INS" class="headerlink" title="2. INS"></a>2. INS</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:e:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                start = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> :</span><br><span class="line">                end = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -s start_num -e end_num\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start = %d\nend = %d\n&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m father!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth child!\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>在父进程睡眠的 10s 内，子进程已经没有了后续的代码，所以成为了僵尸进程，当父进程结束的时候，僵尸进程也都自动消失。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305215431.png" alt="image-20210122204426486"></p>
<blockquote>
<p>当到了项目的时候，如果子进程没建立成功，最好不要立即杀掉，因为可能涉及其他进程。</p>
</blockquote>
<h3 id="3-进程通信"><a href="#3-进程通信" class="headerlink" title="3.进程通信"></a>3.进程通信</h3><ul>
<li><p>所有的子进程以及父进程都是相互独立的，没有沟通，而现在需要他们相互协作完成一个数字累加任务，所以需要他们进行进程间的通信，因为进程之间是相互独立的，所以需要一个媒介（文件）来完成进程间的通信。 </p>
</li>
<li><p>怎么存储这个数据（媒介）？ 有多种方法，这里用结构体来探讨。</p>
</li>
<li><p>建立结构体，并通过打开文件，对该结构体进行写入与读取</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct <span class="title">Msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">set_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nsize = fwrite(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fcolse(f);</span><br><span class="line">    <span class="keyword">return</span> nwrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nread = fread(num, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><p>原子操作 ： 把文件读取出来，看看数据是多少，然后修改，所以就是上面两个操作的二次封装，变成一个拥有“读取信息” 与 “写入信息” 的操作。</p>
<ul>
<li><p>通过文件锁来实现：进程抢到文件锁就执行，没抢到就等着</p>
</li>
<li><h4 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inc lude <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>每个孩子的共同操作（协同）</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> pid_num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            FILE *f = fopen(num_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="comment">//对文件加一个互斥锁，使得其他进程无法同时对该文件进行操作</span></span><br><span class="line">            flock(f-&gt;_fileno, LOCK_EX);</span><br><span class="line">            <span class="comment">//读取文件，看看文件的数据是否已经达到了要求</span></span><br><span class="line">            fread(&amp;num, <span class="keyword">sizeof</span>(struct Msg), <span class="number">1</span>, f);</span><br><span class="line">            <span class="keyword">if</span> (num.now &gt; end) &#123;</span><br><span class="line">                fclose(f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//文件数据没达到要求，对其对其进行操作</span></span><br><span class="line">            num.sum += num.now;</span><br><span class="line">            num.now++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The &lt;%d&gt;th Child : now = %d, sum = %d\n&quot;</span>, pid_num, num.now, num.sum);</span><br><span class="line">            <span class="comment">//将数据写入文件中</span></span><br><span class="line">            set_num(&amp;num);</span><br><span class="line">            <span class="comment">//解开文件锁，使得其他进程可以抢夺该文件，并操作</span></span><br><span class="line">            flock(f-&gt;_fileno, LOCK_UN);</span><br><span class="line">            fclose(f);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>此处的逻辑有点混乱，</p>
<ul>
<li>在<code>get_num</code> 做加锁， 在<code>set_num</code> 做解锁，这样的话，在<code>main</code>函数中，<code>set_num</code>没有锁却做解锁，是否出现问题，这类问题需要做考虑。</li>
<li>可以多生成一个文件<code>lock_file</code>，用来当一个空盒子，谁抢到空盒子，谁就对文件进行操作，避免对文件操作出现问题，代码如下：</li>
</ul>
</blockquote>
<pre><code>&#123;% spoiler "代码演示" %&#125;
    
    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> num_file[] = <span class="string">&quot;./.num&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> lock_file[] = <span class="string">&quot;./.lock&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> <span class="title">num</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">set_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(f);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nwrite = fwrite(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nwrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_num</span><span class="params">(struct Msg *msg)</span> </span>&#123;</span><br><span class="line">    FILE *f = fopen(num_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> nread = fread(msg, <span class="number">1</span>, <span class="keyword">sizeof</span>(struct Msg), f);</span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> end, <span class="keyword">int</span> pid_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FILE *lock = fopen(lock_file, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_EX);</span><br><span class="line">        <span class="comment">//这里需要判断，如果没有读到lock文件，需要关闭，不然锁不会释放，后续也用不了。</span></span><br><span class="line">        <span class="keyword">if</span> (get_num(&amp;num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num.now &gt; end) &#123;</span><br><span class="line">            fclose(lock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num.sum += num.now;</span><br><span class="line">        num.now++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The &lt;%d&gt;th Child : now = %d, sum = %d\n&quot;</span>, pid_num, num.now, num.sum);</span><br><span class="line">        set_num(&amp;num);</span><br><span class="line">        flock(lock-&gt;_fileno, LOCK_UN);</span><br><span class="line">        fclose(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, start = <span class="number">0</span>, end = <span class="number">0</span>, ins = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;s:e:i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                start = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> :</span><br><span class="line">                end = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span> :</span><br><span class="line">                ins = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -s start_num -e end_num\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start = %d\nend = %d\n&quot;</span>, start, end);</span><br><span class="line">    num.now = <span class="number">0</span>;</span><br><span class="line">    num.sum = <span class="number">0</span>;</span><br><span class="line">    set_num(&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ins; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ins; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        do_add(end, x);</span><br><span class="line">    &#125;</span><br><span class="line">    get_num(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, num.sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    &#123;% endspoiler %&#125;</code></pre>
<h4 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h4><ul>
<li>数据保护，一般来说，都是互斥的，即只有一人能用，其他人不行</li>
<li>如果不加锁，就会产生多个进程同时对一个文件操作，比如五个进程同时对同一文件进行+1 操作，得出的结果仅仅只是 + 1， 而不是 + 5</li>
<li>加锁的原因：希望资源的使用者对资源的使用是同步发生的，即事件发生的顺序是确定的，即一个接着一个的来，即互斥锁。</li>
<li>如果不解锁并不关闭文件的话，就会产生阻塞。</li>
<li>加了锁后，就变成了原子操作，开文件，读文件都不会有其他进程的干扰，变成了一个不能再被其他进程分割的操作，就是原子操作。</li>
</ul>
<h2 id="高级进程管理"><a href="#高级进程管理" class="headerlink" title="高级进程管理"></a>高级进程管理</h2><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul>
<li>进程调度是一个内核子系统</li>
<li>进程调度的主要任务是决定哪一个“就绪”状态的进程来执行</li>
<li>就绪进程是<code>非阻塞进程</code></li>
<li>阻塞进程就是正在睡眠的进程，需要内核唤醒的进程</li>
</ul>
<blockquote>
<p>比如作业中进程的先后顺序就涉及了进程调度。</p>
</blockquote>
<blockquote>
<p>涉及到优先级。</p>
<p>阻塞进程就是正在睡眠的进程。</p>
</blockquote>
<h3 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305215446.png" alt="image-20210122224608908"></p>
<blockquote>
<p>还有五态模型。</p>
</blockquote>
<ul>
<li>就绪：万事具备，就差<code>cpu</code>调度</li>
</ul>
<h3 id="从单任务到多任务（进程调度的历史）"><a href="#从单任务到多任务（进程调度的历史）" class="headerlink" title="从单任务到多任务（进程调度的历史）"></a>从单任务到多任务（进程调度的历史）</h3><ul>
<li>DOS是单任务操作系统，每次只运行一个进程；</li>
<li>在单处理器的操作系统中，进程交错运行，从用户角度看，仿佛是多个任务在同时运行；</li>
<li>在多处理器的操作系统中，在不同的处理器上可以同时运行不同的任务，做到真正的并行运行</li>
<li>所谓调度：运行哪个进程，运行多久</li>
</ul>
<blockquote>
<p>并发：在一个时间段内有很多事情发生。</p>
<p>并行：在同一时刻，永远有其他进程与当前进程齐头并进。（比如有几个cpu就有几个任务可以并行。）</p>
</blockquote>
<h3 id="协同式和抢占式"><a href="#协同式和抢占式" class="headerlink" title="协同式和抢占式"></a>协同式和抢占式</h3><h4 id="协同：（实用性不高）"><a href="#协同：（实用性不高）" class="headerlink" title="协同：（实用性不高）"></a>协同：（实用性不高）</h4><ul>
<li>进程会一直运行直到它自己结束。（让出 <code>yielding</code> ）</li>
<li>操作系统不做任何干预</li>
</ul>
<h4 id="抢占：（当前的潮流）"><a href="#抢占：（当前的潮流）" class="headerlink" title="抢占：（当前的潮流）"></a>抢占：（当前的潮流）</h4><ul>
<li>调度器决定进程何时结束并执行另一个进程，这叫做抢占。</li>
<li>进程被抢占前运行的时间称为该进程的时间片。</li>
<li>调度器给每个进程分配一个处理器时间片。</li>
</ul>
<blockquote>
<p>优先级高的，初期时间片会长一点。</p>
</blockquote>
<h3 id="时间片：一个进程在-cpu-运行的时间"><a href="#时间片：一个进程在-cpu-运行的时间" class="headerlink" title="时间片：一个进程在 cpu 运行的时间"></a>时间片：一个进程在 cpu 运行的时间</h3><ul>
<li><p>时间片的长短对于系统的全局行为和性能来说是至关重要的。</p>
</li>
<li><p>时间片过长：提升系统通吐率和全局性能</p>
<ul>
<li>进程执行前需要等待很长的时间，降低了并发运行</li>
<li>用户会感到明显的延迟</li>
</ul>
</li>
<li><p>时间片过短：提升交互性能</p>
<ul>
<li><p>大量的时间花费在调度上</p>
</li>
<li><p>时间局部性带来的性能提升将大打折扣</p>
<blockquote>
<p>高速缓存保存的历史，如果时间调度过快，则很难会建立这样的历史数据。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>解决时间片长短问题：不用时间片</p>
<blockquote>
<p>确定就绪队列，结合总时间，合理安排相关进程的时间，并不一定相等，优先级高的会享受更多的电脑资源。</p>
</blockquote>
</li>
</ul>
<h3 id="IO约束型和处理器约束型"><a href="#IO约束型和处理器约束型" class="headerlink" title="IO约束型和处理器约束型"></a>IO约束型和处理器约束型</h3><blockquote>
<p>应用在使用cpu时的不同之处所定义的两种类型。</p>
</blockquote>
<ul>
<li>一直消耗完可用时间片的进程为处理器约束型进程；<ul>
<li>需要获取大量的cpu资源</li>
<li>消耗掉调度器分配的全部cpu</li>
</ul>
</li>
<li>多数时间处于阻塞状态或者等待资源的进程为IO约束型进程<ul>
<li>经常阻塞在文件IO操作上：文件，网格，键盘，鼠标</li>
<li>也可能除了请求内核执行IO操作之外什么也不错</li>
</ul>
</li>
</ul>
<h3 id="IO约束及处理器约束对时间片的要求"><a href="#IO约束及处理器约束对时间片的要求" class="headerlink" title="IO约束及处理器约束对时间片的要求"></a>IO约束及处理器约束对时间片的要求</h3><ul>
<li>处理器约束：<ul>
<li>期望获得更长的时间片，从而最大化缓存命令，尽快完成任务（时间局部性）</li>
</ul>
</li>
<li>IO约束：<ul>
<li>进程只会运行极短的时间，然后阻塞在内核资源</li>
<li>期望在自己阻塞后，更快的被唤醒，好进行下次的IO操作，调度更多的IO，对资源有更高效的使用</li>
<li>一个等待用户输入的程序，被调度的越快，越有无缝衔接的感觉，听音乐也是如此</li>
<li>简而言之：需要更短的时间片</li>
</ul>
</li>
</ul>
<h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul>
<li>传统UNIX进程调度时，内核给进程分配时间片，时间片用完，挂起该进程，执行其他进程</li>
<li>如果此时系统中没有其他就绪的进程，内核给一斤执行过的进程重新划分时间片，并重新执行</li>
<li>进程创建和终止金属进入和退出就绪队列</li>
<li>如果有高优先级的进程，会优先运行这些进程，然后运行低优先级的进程</li>
<li>所有进程都有机会被运行</li>
</ul>
<h4 id="完全公平调度器（CFS-完全公平调度算法）"><a href="#完全公平调度器（CFS-完全公平调度算法）" class="headerlink" title="完全公平调度器（CFS:完全公平调度算法）"></a>完全公平调度器（CFS:完全公平调度算法）</h4><ul>
<li>CFS 给 N 个进程每个进程分别分配 1/N 的处理器时间</li>
<li>然后通过优先级和权值调整分配，默认优先级为0，权值为1；</li>
<li>优先级值设置越小（优先级越高），则权值越大，分配比例也增加</li>
<li>为了确定每个进程真实的执行时间：引入目标延迟，目标延迟时调度的固定周期</li>
<li>为了避免因为目标延迟设置过小导致每个进程运行的时间过短：引入最小粒度</li>
</ul>
<blockquote>
<p>最小粒度：即时间片的最低标准，cpu 给与的时间片最短不能低于这个标准。</p>
</blockquote>
<ul>
<li>公平性：每个进程都会得到处理器资源的“公平配额”</li>
</ul>
<blockquote>
<p>公平配额：处理基于进程的重要程度，给与相应 cpu 资源</p>
</blockquote>
<h2 id="多核与多CPU"><a href="#多核与多CPU" class="headerlink" title="多核与多CPU"></a>多核与多CPU</h2><p>现在的<code>cpu</code>是一个<code>物理cpu</code> 里面有<code>多个核心</code>，<code>一个核心</code>就被认为是<code>一个cpu</code>，即<code>一个物理cpu</code>包含许多<code>小cpu</code>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信（共享内存）下</title>
    <url>/2021/01/07/0022.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程间的通信（下）"><a href="#进程间的通信（下）" class="headerlink" title="进程间的通信（下）"></a>进程间的通信（下）</h1><h2 id="自言自语版聊天室（基于共享内存）"><a href="#自言自语版聊天室（基于共享内存）" class="headerlink" title="自言自语版聊天室（基于共享内存）"></a>自言自语版聊天室（基于共享内存）</h2><h3 id="chat-h"><a href="#chat-h" class="headerlink" title="chat.h"></a><code>chat.h</code></h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CHAT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CHAT_H</span></span><br><span class="line"><span class="comment">// 一个标配的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>]; <span class="comment">//用来存储用户名字</span></span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">1024</span>]; <span class="comment">//用来存储用户发生的信息</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 线程互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 条件变量。信号量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="server-c-服务端"><a href="#server-c-服务端" class="headerlink" title="server.c : 服务端"></a><code>server.c</code> : 服务端</h3><ul>
<li>创建共享内存，准备好聊天所需要的所有资源 </li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">share_memory</span> =</span> <span class="literal">NULL</span>; <span class="comment">//共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((share_memory = (struct Msg *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 因为服务端优先启动，所以需要在服务端启动时，把相关资源都初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(share_memory, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Msg));</span><br><span class="line">    	<span class="comment">// 初始化线程互斥锁</span></span><br><span class="line">    	<span class="comment">// 属性变量</span></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> m_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;m_attr);</span><br><span class="line">    	<span class="comment">// 设置进程间共享</span></span><br><span class="line">        <span class="comment">// PTHREAD_PROCESS_SHARED 等价于1</span></span><br><span class="line">    pthread_mutexattr_setpshared(&amp;m_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;m_attr);</span><br><span class="line">		<span class="comment">// 同样的方式初始化条件变量，与上面相似</span></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> c_attr;</span><br><span class="line">    pthread_condattr_init(&amp;c_attr);</span><br><span class="line">    	<span class="comment">// 在linux 系统下，下面两个操作会被忽略</span></span><br><span class="line">    pthread_condattr_setpshared(&amp;c_attr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_cond_init(&amp;share_memory-&gt;cond, &amp;c_attr);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 客户端发信息，服务端打印出全部信息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加线程锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server Got th Mutex!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待客户端发信号，同时加上互斥锁，避免漏掉信号</span></span><br><span class="line">        pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sever got the cond signal\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s.\n&quot;</span>, share_memory-&gt;name, share_memory-&gt;msg);</span><br><span class="line">        <span class="comment">// 打印完之后，清空一下信息</span></span><br><span class="line">        <span class="built_in">memset</span>(share_memory-&gt;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(share_memory-&gt;msg));</span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="client-c-客户端"><a href="#client-c-客户端" class="headerlink" title="client.c : 客户端"></a><code>client.c</code> : 客户端</h3><ul>
<li>发送信息，同时发送信号给服务端，告知服务端可以处理信息了</li>
<li>因为服务端只能处理一次，必须保证客户端使用该共享内存时，该空间属于该客户端，其他客户端用不了该空间</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;chat.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Msg</span> *<span class="title">share_memory</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, shmid;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;n:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span> :</span><br><span class="line">                <span class="built_in">strcpy</span>(name, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s -n name\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">// 退出不能用 0 退出，因为 0 退出是表示程序运行正常</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">202101</span>);</span><br><span class="line">    <span class="comment">// 拿到 id </span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Msg), IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到共享内存</span></span><br><span class="line">    <span class="keyword">if</span> ((share_memory = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> msg[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 避免因为一直读取到空格而陷入死循环</span></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(msg)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 确认服务端打印完，里面的数据已经被清空了，这个时候客户端才能加锁</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strlen</span>(share_memory-&gt;msg)) &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sending : %s...\n&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 告诉服务端相关信息</span></span><br><span class="line">        <span class="built_in">strcpy</span>(share_memory-&gt;msg, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(share_memory-&gt;name, name);</span><br><span class="line">        <span class="comment">// 发出抢锁信号</span></span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">        <span class="comment">// 解锁（可能会出问题，逻辑上应该先解锁 ）</span></span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="comment">// 如果先解锁，再发信号，可能会被另一个客户端抢到信号，如果这样，服务端是打印不出任何东西的</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Client signaled the cond\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220406.png" alt="image-20210207213059694"></p>
<h2 id="线程接口"><a href="#线程接口" class="headerlink" title="线程接口"></a>线程接口</h2><blockquote>
<p>线程是进程的一个分支，这个函数用于建立一个分支，也即线程。</p>
<p>一个进程可以拥有一个或者多个线程。</p>
<p>线程本质上是一种轻量级的进程：</p>
<ul>
<li>进程的空间是相互独立的，且调度代价较大</li>
<li>线程可以通过共享内存，使得线程间的通信变得及其简单，同时调度上的代价较低，因为切换线程的时候，不用把其他线程的缓存给清空置换了，这样消耗的代价大大降低。</li>
</ul>
</blockquote>
<h3 id="pthread-create：创建线程"><a href="#pthread-create：创建线程" class="headerlink" title="pthread_create：创建线程"></a>pthread_create：创建线程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread.</span><br></pre></td></tr></table></figure>
<p>编译的时候需用用<code>-pthread</code></p>
<p><code>arg</code>：是<code>start_routine</code>的<code>唯一</code>参数，所以，如果想要传多个参数，可以将这些参数封装成一个结构体，然后把结构体传给<code>start_routine</code>。</p>
<p>线程会以以下几种方式死亡：</p>
<ul>
<li><p><code>pthread_exit</code>：自杀，自行调用。自杀的后，会返回一个值给<code>pthread_join</code>线程（类似父子进程中的<code>wait</code>）。</p>
</li>
<li><p>从<code>start_routine</code>返回，等价<code>pthread_exit</code></p>
</li>
<li><p>被取消（他杀）</p>
</li>
<li><p>所有线程中一个使用了<code>exit</code> 或者主进程从<code>main</code>中返回时，所有的线程也会跟着死亡。</p>
<blockquote>
<p>因为共享内存，所以如果一个线程导致内存崩溃，极有可能也会导致所有线程都死掉。</p>
</blockquote>
</li>
</ul>
<p><code>attr</code>：大部分用<code>null</code>。</p>
<p>在返回之前，该函数会把<code>线程ID</code>保存在 <code>thread</code>中，以供后续的所有操作。</p>
<p>新建立的线程会继承主进程的源码，待处理的信号则被清空，不会继承主进程的交替信号。（类似父子进程）。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免因为 arg 在主函数中因为循环等原因，使得变量被修改了，为了降低风险，多一个变量存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">in1</span>;</span></span><br><span class="line">    in1 = *(struct MyArg *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> *<span class="title">in</span>;</span></span><br><span class="line">    in = (struct MyArg *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In Thread!\n&quot;</span>); <span class="comment">// 有可能输出两次</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old\n&quot;</span>, in-&gt;name, in-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s is %d years old\n&quot;</span>, in1.name, in1.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyArg</span> <span class="title">arg</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(name, <span class="string">&quot;alin&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(arg.name, name);</span><br><span class="line">    arg.age = age;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, print, &amp;arg);</span><br><span class="line">    <span class="comment">// 稍微等一下，避免 print 函数还没来得及输出就直接死了</span></span><br><span class="line">    usleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="线程池（面试经常问到）"><a href="#线程池（面试经常问到）" class="headerlink" title="线程池（面试经常问到）"></a>线程池（面试经常问到）</h2><ol>
<li><p>多进程（<code>fork</code>）：消耗大</p>
<blockquote>
<p>早期是单进程，单有多个任务时，只能一个一个慢慢处理。</p>
</blockquote>
</li>
<li><p>多线程：随时建立与释放，<code>费时</code>，消耗资源</p>
</li>
<li><p>线程池：不会随意被释放</p>
<ol>
<li><p>任务队列：循环</p>
<ul>
<li><code>push</code>（锁）、<code>pop</code>、<code>init</code></li>
</ul>
<blockquote>
<p>存放任务</p>
</blockquote>
</li>
<li><p><code>pthread_create</code>：创建 N 个线程</p>
<blockquote>
<p>线程需要主动去抢任务，而这个有可能会产生数据竞争，所以需要先加个锁，抢到锁的人，优先执行任务。</p>
<p>当任务量大于线程数时，则会循环抢任务。</p>
</blockquote>
</li>
<li><p><code>do_work</code>：工作</p>
<ul>
<li><code>while（1）</code><ul>
<li>取出： <code>pop</code>（锁） </li>
<li>干活</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="thread-pool-h-：任务队列定义"><a href="#thread-pool-h-：任务队列定义" class="headerlink" title="thread_pool.h ：任务队列定义"></a><code>thread_pool.h</code> ：任务队列定义</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">char</span> **data;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="thread-pool-c-：任务队列操作"><a href="#thread-pool-c-：任务队列操作" class="headerlink" title="thread_pool.c ：任务队列操作"></a><code>thread_pool.c</code> ：任务队列操作</h3><ul>
<li>循环队列</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_init</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    taskQueue-&gt;size = size;</span><br><span class="line">    taskQueue-&gt;total = <span class="number">0</span>;</span><br><span class="line">    taskQueue-&gt;head = taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;taskQueue-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;taskQueue-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 队列里面每个值为一个void *指针</span></span><br><span class="line">    taskQueue-&gt;data = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_queue_push</span><span class="params">(struct task_queue *taskQueue, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 压入栈之前，先锁上</span></span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (taskQueue-&gt;total == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="comment">// 装满的时候，就得把锁打开，避免别人出不去，也进不来</span></span><br><span class="line">        pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is full!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;push&gt; : %s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;data[taskQueue-&gt;tail] = str;</span><br><span class="line">    taskQueue-&gt;total++;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;tail == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cond_signal(&amp;taskQueue-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出操作，是人名，所以是char *</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">task_queue_pop</span><span class="params">(struct task_queue *taskQueue)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="comment">// 当队列空时，处于等待状态（也可能原本有人，但是被其他人提前给抢了，这个时候，也处于等待）</span></span><br><span class="line">    <span class="keyword">while</span> (taskQueue-&gt;total == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task queue is empty!\n&quot;</span>);</span><br><span class="line">        pthread_cond_wait(&amp;taskQueue-&gt;cond, &amp;taskQueue-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = taskQueue-&gt;data[taskQueue-&gt;head];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;pop&gt; : %s\n&quot;</span>, str);</span><br><span class="line">    taskQueue-&gt;total--;</span><br><span class="line">    <span class="keyword">if</span> (++taskQueue-&gt;head == taskQueue-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;task qeueue reach end!\n&quot;</span>);</span><br><span class="line">        taskQueue-&gt;head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;taskQueue-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="text-c-：测试线程池"><a href="#text-c-：测试线程池" class="headerlink" title="text.c ：测试线程池"></a><code>text.c</code> ：测试线程池</h3><ul>
<li>创建线程</li>
<li>工作</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD 5 <span class="comment">// 线程数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE 50 <span class="comment">// 队列容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_work</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分离自己，不让其他程序联入该线程，与 pthread_join 相反</span></span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> *<span class="title">taskQueue</span> =</span> (struct task_queue *)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *str = task_queue_pop(taskQueue);</span><br><span class="line">        <span class="comment">// 线程可以通过 pthread_self 拿到自己的 ID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%ld&gt; : %s !\n&quot;</span>, pthread_self(), str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化线程池</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THREAD];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_queue</span> <span class="title">taskQueue</span>;</span></span><br><span class="line">    task_queue_init(&amp;taskQueue, QUEUE);</span><br><span class="line">    <span class="comment">// 定义任务队列中每个任务的空间</span></span><br><span class="line">    <span class="keyword">char</span> buff[QUEUE][<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 每个线程去任务队列拿取任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD; i++) &#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, do_work, (<span class="keyword">void</span> *)&amp;taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环打开文件</span></span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 切记不能用 w 打开，否则代码全消失</span></span><br><span class="line">        FILE *fp = fopen(<span class="string">&quot;./test.c&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fgets(buff[sub], <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            task_queue_push(&amp;taskQueue, buff[sub++]);</span><br><span class="line">            <span class="keyword">if</span> (sub == QUEUE) &#123;</span><br><span class="line">                sub = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (taskQueue.total == taskQueue.size) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (taskQueue.total &lt; taskQueue.size) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 避免 cpu 运行太密集，所以睡眠一下</span></span><br><span class="line">                    usleep(<span class="number">10000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><ul>
<li>可以运行，也可以如自己所想，实现在任务队列中拿取任务，不过最后出现段错误</li>
<li>不要直接在while里面进行sub++，而是在task_queue_push里面进行sub++，这样就可以了</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概论</title>
    <url>/2021/01/09/0024.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络概论"><a href="#计算机网络概论" class="headerlink" title="计算机网络概论"></a>计算机网络概论</h1><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223201.png" alt="image-20210211102215302" style="zoom:50%;">

<h2 id="计算机网络传输数据的封装过程（数据封装、解封）"><a href="#计算机网络传输数据的封装过程（数据封装、解封）" class="headerlink" title="计算机网络传输数据的封装过程（数据封装、解封）"></a>计算机网络传输数据的封装过程（数据封装、解封）</h2><blockquote>
<p>当你在网站输入一个网站域名，点击回车后，会发送什么事情？ （<code>面试常问</code>）</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223241.png" alt="image-20210211102316913" style="zoom: 50%;">

<ul>
<li><p>第一个设备（源）：应用层产生一个<code>message报文</code>，到传输层贴上<code>端口信息</code>，到网络层贴上<code>目的地IP信息</code>，到数据链路层（<code>本地局域网</code>） 贴上<code>mark地址</code>，此时数据准备发出，并已经知道<code>目的地</code>在哪，即<code>局域网</code>这部机器最终到<code>哪台机器</code>去，最后到物理层。</p>
<blockquote>
<p><code>message报文</code>的大小不定，未必就是一个大的数据，需要考虑底层是怎么运行的！</p>
<p>比如发一个<code>12M</code>的图片，这个图片未必就是一个<code>message</code>。</p>
<p>再比如写一个<code>send</code>函数，可以直接把<code>12M</code>的函数一下子都发出去，这个逻辑看起来并无问题，因为并没有限制，但是，针对底层来说，这种写法是否真的合适呢？有什么好处或者坏处呢？</p>
<p>发送一个<code>12M</code>的数据，<code>TCP</code>底层一定会把数据切片再发送出去；也可以在发送之前，先自己将其切成一个一个的小片<code>message</code>，再发出去，这样的操作效率可能更高。 </p>
<p>所以，有时可以通过对计算机网络与底层的了解来微调程序，从而可以使得程序的效率更佳。</p>
</blockquote>
</li>
<li><p>第二个设备（链路交换机）：判断这个数据包需要去哪个地方，即拿出<code>mark地址</code>，从而知道了是去<code>出口路由器</code>。</p>
<blockquote>
<p>​         比方在局域网中，当前主机的<code>IP地址</code>为<code>192.168.0.3</code>，目的地是谷歌的<code>DNS服务:8.8.8.8的80端口</code>，所以，第一个设备的传输层是贴上<code>80端口</code>标签，网络层贴上<code>8.8.8.8</code>标签；然后到链路层，由于<code>本机</code>不知道<code>8.8.8.8</code>在哪，所以只能借助其他的网络连接。</p>
<p>本地局域网，相当于本地所有的机器都连在一起，本地通信靠在局域网内喊一声，如果有回应，说明对方就是要找的目标，就可以开始与对方通信。</p>
<p>子网掩码 &amp; 目标<code>IP地址</code>，如果得到的地址与自己的一样，说明当前机子是在本地局域网内，否则则说明当前机子不是在本地局域网，这个时候就需要给网关（<code>初始路由</code>）发信息说<code>目的地址</code>不在局域网内（不在交换机所连接的机器中，不能靠”吼”一嗓子就可以传达信息）。所以这个时候需要通过第三个设备<code>路由器</code>来实施了。</p>
</blockquote>
</li>
<li><p>第三个设备（路由器）： 路由器的定位是通过<code>网关地址 Gateway</code>，如果判断不是本地局域网，则把数据交给<code>网关</code>，网关则从物理层、数据链路层把相关的外套拆除之后，露出网络层的信息，得到<code>目的IP地址8.8.8.8</code>，然后在自己的<code>路由表</code>中，用<code>最长字符串匹配</code>，查询去哪里对应目的地，就可以找到如果要找<code>8.8.0.0</code>（后面两位不管）的地址中时，都需要转到另一个路由器中，则会把数据传到那个路由器中去寻找目的地。如果路由器直接连接目标主机，则可以直接把数据传给目标主机。</p>
<blockquote>
<p>这整个过程涉及到一层一层拨开读取信息寻找目标，以及一层一层封装成属于自己的数据包。</p>
<p>图中属于简化路线图，真正的情况是极有可能需要经过好几个路由器，一层一层找，才能到达目标主机。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>分层带来的好处：</p>
<ul>
<li>各层之间是独立的</li>
<li>灵活性好</li>
<li>结构上可以分割开</li>
<li>易于实现与维护</li>
<li>能促进标准化工作</li>
</ul>
</li>
<li><p>各层的功能：（各层都可能提供这样的服务）</p>
<ul>
<li><p>差错控制：对传入数据的正误进行判断</p>
</li>
<li><p>流量控制：针对对端的数据容量大小，进行数据传输量的控制。</p>
<blockquote>
<p>​          己端发送数据给对端时，对端发回来的信息中会包含有对端容量剩余量的信息，己端根据当前已经发送的数据量判断当前发送量是否已经超过对端数据容量，从而决定是否还要发送数据。</p>
</blockquote>
</li>
<li><p>分段和复用</p>
<ul>
<li>分段：数据的分段</li>
<li>复用：对某种概念的复用</li>
</ul>
</li>
<li><p>复用与分用</p>
</li>
<li><p>连接建立和释放</p>
<blockquote>
<p>​          所有的网络，并无存在真实的连接。所有的连接，都是两端维护一些变量，通过这些变量的变化来确认连接的好坏。 </p>
<p>​          如果己端发送断连信息，对端没有任何回应，就属于半连接状态。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="网络协议的组成要素"><a href="#网络协议的组成要素" class="headerlink" title="网络协议的组成要素"></a>网络协议的组成要素</h3><ul>
<li>语法：两端共同认同的交互方式。</li>
<li>语义： 确定语法的某种特殊信息怎么解析出其代表的特殊意义。</li>
<li>同步：指事件发生的顺序是有迹可循的，是可以预知的。</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul>
<li><p>现在整个互联网（通用互联网）使用的都是分组交换网络</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223252.png" alt="image-20210211112015313" style="zoom:50%;">
</li>
<li><p><code>TCP</code>把一个<code>message</code>切成一个一个单独的<code>Packet</code>，这些<code>Packet</code>都是一个一个单独走的，都会各自选择自己要去的<code>目的地</code>前进（大多数情况下都会选择同一条网络，但是加入有外力干预，比如服务器关闭等，都会使得路线的选择不同），<code>路线选择</code>表面看上去是<code>packet</code>自己选的，实际上是<code>路由协议</code>替它选的，<code>packet</code>每到一个路由器，都会根据<code>路由器的配置</code>，被动的选择一条适合自己的线路。<code>路由协议</code>会控制路由器，路由器每收到一个数据包，都会对照下数据包的目的地与自己的路由表，从而得到数据包目的地。</p>
<blockquote>
<p><code>路由协议</code>：如果路由表中的某个目的地的线路断了，当前路由器就会把数据传输给另一个路由器，由另一个路由器决定数据的走向，这种路由器与路由器之间的沟通就叫做路由协议。</p>
</blockquote>
</li>
</ul>
<h3 id="存储转发机制"><a href="#存储转发机制" class="headerlink" title="存储转发机制"></a>存储转发机制</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223259.png" alt="image-20210211113515327" style="zoom:50%;">
</li>
<li><p>等到所有数据都收到了，再判断数据的正误，数据有误（被人劫持污染）则被丢弃，如果是<code>TCP</code>协议，就会重传（重传的两种机制）。如果数据无误，则会被转发机制发送给目标。</p>
<ul>
<li><p>超时重传：发送方如果没收到对方确认信息，则会重新再发一次同样的数据包补救。</p>
</li>
<li><p>三次冗余ACK重传：发送方三次发送数据后，接收方均回复信息表示需要同一个数据包，则表面该数据包丢失，需要重新传送。</p>
<blockquote>
<p>两种机制只会出现一个，不会同时出现，超时是后面的数据包完全不见，意味着整个网络出现了问题，可能是中间某个路由器坏了；<code>冗余ACK</code>则是中途有一个数据包丢失，后续的数据包并没丢失。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="排队时延和分组丢失："><a href="#排队时延和分组丢失：" class="headerlink" title="排队时延和分组丢失："></a>排队时延和分组丢失：</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223306.png" alt="image-20210211114731608" style="zoom:50%;">
</li>
<li><p>中间部分属于路由器。</p>
</li>
<li><p>路由器本身存在很多的网卡，每个网卡中都有一个<code>输入缓冲区、输出缓冲区</code>， 当短时间内有太多的数据，超过<code>输入缓冲区</code>的容量，数据处理速度跟不上数据到来速度，这个时候，<code>路由器</code>只能丢弃多余的数据包，丢弃的方式有两种，一种是直接丢弃后面到来的数据，一种是从存放数据的队列中选一个丢弃； 数据被丢掉后，就会触发<code>重传</code>的两种机制<code>超时重传</code>、<code>三次ACK重传</code>，在这种情况下，大多数都是超时重传。</p>
</li>
<li><p>如果在数据传输的多个路由器中，有一个路由器出现问题导致效率较低，其输入队列与输出队列有排队现象，使得信息到达的时间超过预期，比如，正常信息传输<code>30ms</code>即可，<code>100ms</code>超时，由于出现问题，超时了，这个时候，发送方在<code>重传</code>的同时，也会增加超时时间，变成<code>200ms</code>，再超时，再增加等待时间，直到最后无法交付任务为止。</p>
<blockquote>
<p>如果不增加时长，可能出现一开始发送的包最终都能到达目的地，但是发送方不知道，每次超过<code>100ms</code>就重新发，一直不断重复，而使得中间出问题的<code>路由器</code>问题加剧，原本处理信息效率慢会变得更慢，最终导致整个<code>网络瘫痪</code>。所以<code>tcp</code>协议会自动调整<code>超时时长</code>，保证如果数据最终能到达目的地，不会损坏中间处理效率较慢的路由器。</p>
</blockquote>
</li>
<li><p>排队时延：整个数据包，从发送出去，到对方发送确认收到信息，整个过程延迟了。</p>
<blockquote>
<p>排队时延是整个时延中，最不可控，并且出现波动最多的时延。</p>
<p>游戏使用的协议是<code>UDP</code>协议，因为游戏追求的是<code>时效</code>，讲究<code>时间效率</code>，需要的是<code>快速交付</code>，所以不能搞得像<code>tcp</code>那样复杂，出现丢包现象也无所谓，只要不会延迟特别特别长就行。</p>
</blockquote>
</li>
</ul>
<h3 id="转发表、路由显示协议"><a href="#转发表、路由显示协议" class="headerlink" title="转发表、路由显示协议"></a>转发表、路由显示协议</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223313.png" alt="image-20210211174113224" style="zoom:50%;">
</li>
<li><p>当数据包到达路由器时，路由器会通过转发表（路由显示协议）会根据这个数据包的目的地从而判断出该数据包应该从当前的哪条网络线路出发。</p>
</li>
<li><p>转发表：<code>局部</code>概念</p>
</li>
<li><p>路由选择协议：<code>宏观</code>概念</p>
</li>
</ul>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223351.png" alt="image-20210213113216047" style="zoom:50%;">
</li>
<li><p>类似早期的电话，中间依次有<code>接线员</code>把接通前往目的地的电路，使得起点与终点最终相连</p>
</li>
<li><p>现在的是通过中间的路由器来维护这个状态，即路由器起到了中间接线员的工作</p>
</li>
<li><p>特点：可以看到资源有否优先，比如图中的四条线路一旦被占满，则无法再分配资源（缺陷）</p>
</li>
</ul>
<h2 id="频分复用（FTM）"><a href="#频分复用（FTM）" class="headerlink" title="频分复用（FTM）"></a>频分复用（FTM）</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223400.png" alt="image-20210213113736972" style="zoom:50%;">

<ul>
<li>根据频率的不同划分可以传达什么信息，上面图中的四条分界线是<code>0451</code></li>
</ul>
<h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2> <img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223431.png" alt="image-20210213114037117" style="zoom: 50%;">

<ul>
<li><p>把时间段分成一个个小片</p>
</li>
<li><p>优点：确定了时间段，即该时间段归谁使用</p>
</li>
<li><p>缺点：可能某个资源在当时的时间段里无需使用，而另外的资源迫切需要用到资源，则另外的资源只能被迫等到当前时间段过去了才能使用。</p>
<blockquote>
<p>对比<code>电路交换</code>，时分复用还是有希望可以用到资源，而<code>电路交换</code>的，则可能资源一直被人霸占着，用不了。</p>
<p><code>时分复用</code>之后就是<code>分组交换</code>，即有数据就丢出去，不管数据包怎么走，只要数据包能到<code>目的地</code>就行。</p>
</blockquote>
</li>
</ul>
<h2 id="分组交换与电路交换的对比："><a href="#分组交换与电路交换的对比：" class="headerlink" title="分组交换与电路交换的对比："></a>分组交换与电路交换的对比：</h2><ul>
<li>分组交换有更好的<code>带宽共享</code>，比电路交换更好，同时实现的<code>成本</code>更低。</li>
</ul>
<h2 id="时延、丢包和吞吐率"><a href="#时延、丢包和吞吐率" class="headerlink" title="时延、丢包和吞吐率"></a>时延、丢包和吞吐率</h2><h3 id="时延："><a href="#时延：" class="headerlink" title="时延："></a>时延：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223446.png" alt="image-20210213121215837" style="zoom:50%;">

<ul>
<li>结点处理时延：数据包到达某一个节点，先被拆开看看目的地是哪，再加入新的信息并重新包装发出去。</li>
<li>排队时延：从数据包进去到正式处理的过程中，会先被放到缓冲区排队等待，直到轮到数据包被处理。</li>
<li>传输时延：从开始发数据，到数据最终被发出去的时间<ul>
<li>时延是一个网络状态的评判标准，而传输时延会使得这个标准变得不可琢磨。</li>
<li>如果数据极大，就会使得传输时延极大，这样就不好作为一个评判标注，所以，建议讲传输时延的时候，就<code>只讲究一个数据包</code></li>
</ul>
</li>
<li>传播时延：信号从当前主机发送到目标主机，并回来的过程中，信号经历的传输介质中传输的时间。</li>
</ul>
<h3 id="排队时延与丢包："><a href="#排队时延与丢包：" class="headerlink" title="排队时延与丢包："></a>排队时延与丢包：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223455.png" alt="image-20210213122206034" style="zoom:50%;">

<ul>
<li><code>a</code>：分组到达出队列的平均速率</li>
<li><code>L</code>：所有分组都由<code>L</code>比特构成</li>
<li><code>R</code>：传输速率</li>
<li>平均排队时延最长，越容易丢包</li>
</ul>
<h3 id="吞吐量："><a href="#吞吐量：" class="headerlink" title="吞吐量："></a>吞吐量：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223505.png" alt="image-20210213122502660" style="zoom:50%;">

<ul>
<li><p>所有线路中，最小的传输速率<code>R</code>。</p>
</li>
<li><p>如果一开始数据量较大，可是后面的线路能容纳的数据量较小，则<code>tcp</code>协议会发送负反馈，反过来抑制一开始的发送量，直到最终发送量是所有线路中，最小的传输速率<code>R</code>。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>运输层协议</title>
    <url>/2021/01/11/0026.%20%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="运输层协议（重要）"><a href="#运输层协议（重要）" class="headerlink" title="运输层协议（重要）"></a>运输层协议（重要）</h1><blockquote>
<p>应用层协议大部分只是用，不会做太多的深入，但是运输层协议是计算机网络中最核心的部分，也是跟程序员最息息相关的部分。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084428.png" alt="image-20210214150950405" style="zoom:50%;">

<p>图中展示的是，左边的主机想跟右边的主机进行通讯，在<code>应用层</code>看来就是两个应用在通讯；而在<code>运输层</code>呢？</p>
<blockquote>
<p>网络层：一个<code>IP</code>到另一个<code>IP</code>，即主机到主机之间的逻辑通信；</p>
<p>应用层：工作在主机之上的进程之间的逻辑通信，<code>套接字</code>（四元组）跟<code>套接字</code>之间的通信；</p>
<p>运输层：<code>端口</code>到<code>端口</code>之间的通信。</p>
</blockquote>
<h3 id="运输层的协议概述"><a href="#运输层的协议概述" class="headerlink" title="运输层的协议概述"></a>运输层的协议概述</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084437.png" alt="image-20210214152000511" style="zoom:50%;">

<ul>
<li><p>被<code>IP</code>地址到<code>IP</code>地址之间的沟通方式扩展到运输层中。</p>
</li>
<li><p>不管是<code>TCP</code>还是<code>UDP</code>，他们的最低限度的<code>运输层服务</code>则是<code>交付</code>与<code>差错检验</code>。</p>
<blockquote>
<p>不是说<code>UDP</code>不可靠就没有<code>差错检验</code>。可不可靠的评判标准是有没有丢包，没有丢包则说明可靠；但是无论有没有丢包，接收到的数据包，必须是准确的。</p>
<p><code>差错检验</code>与<code>纠错</code>：如果数据包存在错误，则可能可以通过算法或者现有的数据实现<code>纠错</code>。</p>
</blockquote>
<blockquote>
<p>使用<code>UDP</code>的时候，往往需要在<code>UDP</code>上面再封装一层，即对应用层进行封装，否则，如果对方不在线，那数据不止到不了对方，还会给网络造成压力。</p>
<p><code>UDP</code>对整个网络来说并不友好，因为另一端如果下线不收取数据了，这一端还能继续发送数据。</p>
</blockquote>
</li>
</ul>
<h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084451.png" alt="image-20210214154536090" style="zoom: 50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084456.png" alt="image-20210214154604591" style="zoom:50%;">

<ul>
<li>运输层：只关注<code>目的端口</code>与<code>源端口</code></li>
<li>网络层：只关注<code>目的地</code>与<code>来源地</code></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084503.png" alt="image-20210214154912818" style="zoom:50%;">

<h3 id="为什么会选择无连接运输：UDP"><a href="#为什么会选择无连接运输：UDP" class="headerlink" title="为什么会选择无连接运输：UDP"></a>为什么会选择无连接运输：UDP</h3><ul>
<li>关于何时、发送什么数据的应用层控制更为精细</li>
<li>无需建立连接</li>
<li>无状态连接</li>
<li>分组开销小</li>
</ul>
<blockquote>
<p><code>SNMP</code>：简单网络管理协议。</p>
<p>网络风暴：数据中心有大量的数据在转圈出不去。</p>
</blockquote>
<h3 id="UDP报文段"><a href="#UDP报文段" class="headerlink" title="UDP报文段"></a>UDP报文段</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084512.png" alt="image-20210214160154511" style="zoom:50%;">

<h3 id="怎么构建一个可靠的传输协议？"><a href="#怎么构建一个可靠的传输协议？" class="headerlink" title="怎么构建一个可靠的传输协议？"></a>怎么构建一个可靠的传输协议？</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084517.png" alt="image-20210214163516288" style="zoom:50%;">

<ul>
<li>信道：底层传输的逻辑或者链路</li>
</ul>
<ol>
<li>如果是基于<code>可靠信道（tcp）</code>建立的传输，则无需在上层考虑<code>丢包以及乱序</code>的问题。</li>
<li>如果是基于<code>不可靠信道</code>建立的传输，则需要在这个基础上，考虑在上层应该做什么事情才能使得传输变得可靠，即基于<code>不可靠信道</code>建立的<code>可靠发送与接收</code>的封装（图中绿色部分）。</li>
</ol>
<h4 id="第一版：基于完全可靠信道（tcp）"><a href="#第一版：基于完全可靠信道（tcp）" class="headerlink" title="第一版：基于完全可靠信道（tcp）"></a>第一版：基于完全可靠信道（tcp）</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084525.png" alt="image-20210214164246923" style="zoom:50%;">

<ul>
<li>虚线：默认位置；</li>
<li>实线：状态转换</li>
<li>实线旁边：真实做的事，蓝线上方是封装的功能，下方是封装的具体细节。</li>
<li>流程：创建一个数据包并发送给对方，对方接收到数据包，解析数据包并提交给上层。</li>
</ul>
<h4 id="第二版：基于不可靠信道"><a href="#第二版：基于不可靠信道" class="headerlink" title="第二版：基于不可靠信道"></a>第二版：基于不可靠信道</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084533.png" alt="image-20210214164906937" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084539.png" alt="image-20210214165550506" style="zoom:50%;">

<ul>
<li>能够感知到<code>比特级</code>的错误信息，具有一定差错控制的信道</li>
<li>刚开始协议处于<code>阻塞</code>状态，等着上层的调用，上层通过<code>rdt_send</code>来调用协议，给协议传了一个<code>data</code>，协议会把<code>data</code>跟<code>校验和checksum</code>一起打包封装成一个数据包发给对方（可能会创建很多包，发送很多包，这里以单次为例）。</li>
<li>对方收到之后，发送方就会处于<code>等待状态</code>，等待来自下层的调用，当下层数据来临时，会通知让其对数据进行解析并提交给上层。</li>
<li>对方一开始处于<code>等待状态</code>，当对方收到数据时，会对数据的校验和进行检验，如果不对，会返回一个<code>NAK（错误回馈）</code>；如果检验无误，则会将数据包拆开，舍弃校验和，读取数据，将数据提交给上层，并给发送方返回一个<code>ACK（成功）</code>。</li>
<li>此时发送方处于<code>等待状态</code>，收到对方的反馈后，如果是<code>NAK</code>，则会重新发送数据包；如果是<code>ACK</code>，则什么都不做，继续处于<code>等待状态</code>。</li>
</ul>
<blockquote>
<p>这样虽然确保了数据的可靠传输，但是效率较慢，因为需要等待对方反馈。</p>
</blockquote>
<h4 id="第三版：基于不可靠信道（RDT2-1）"><a href="#第三版：基于不可靠信道（RDT2-1）" class="headerlink" title="第三版：基于不可靠信道（RDT2.1）"></a>第三版：基于不可靠信道（RDT2.1）</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084548.png" alt="image-20210214170640861" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084556.png" alt="image-20210214174626714" style="zoom:50%;">

<ul>
<li><p>与上一版的差别在于多了编号，可以<code>0 1</code>这样的发，这样话，可以明确对方的每次反馈是给谁的，同时也能发送更多的信息。</p>
</li>
<li><p>好处：保证可靠的两点要素，一点是能够到达目的地，另一点是接收的顺序是准确的，即将<code>所有的数据</code>都要<code>按顺序</code>到达。而这一版，可以保证数据的<code>到达顺序</code>。</p>
<blockquote>
<p>单单01是不够的，后续的实现过程中，像<code>TCP</code>这种，它的序号是连续的，每个字节都有一个序号，这个序号就单次连接的字节流，即字节的位置。</p>
</blockquote>
</li>
</ul>
<h4 id="第四版：基于不可靠信道（RDT2-2）"><a href="#第四版：基于不可靠信道（RDT2-2）" class="headerlink" title="第四版：基于不可靠信道（RDT2.2）"></a>第四版：基于不可靠信道（RDT2.2）</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084603.png" alt="image-20210214175242593" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084609.png" alt="image-20210214175531244" style="zoom:50%;">

<ul>
<li>少了<code>NAK</code>，只保留<code>ACK</code>，只确认收到的东西，不确认错误的数据。</li>
<li>如果<code>等待ACK0</code>没有收到回复，而<code>等待ACK1</code>收到了回复，则说明数据不对，<code>ACK0</code>会重新发送一份数据，直到<code>等待ACK0</code>收到回复。</li>
<li>接收方如果收到的数据没错，编号对应，则回一个<code>ACK</code>；而如果，比如接收方的<code>1</code>收到<code>0</code>包，则会再发送一个<code>ACK1</code>，此时发送方的<code>等待ACK0</code>没有收到回复，而<code>等待ACK1</code>收到了回复，则会触发机制，使得<code>ACK0</code>重发一份数据。（冗余<code>ACK</code>）</li>
<li>缺陷：等待时间可能过长</li>
</ul>
<h4 id="第五版：基于不可靠信道（RDT3-0）"><a href="#第五版：基于不可靠信道（RDT3-0）" class="headerlink" title="第五版：基于不可靠信道（RDT3.0）"></a>第五版：基于不可靠信道（RDT3.0）</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084618.png" alt="image-20210214180309300" style="zoom:50%;">

<ul>
<li><p>加上定时器，避免等待时间过长</p>
</li>
<li><p>此时基本已经是一个可靠的传输协议，只不过效率依然较低。</p>
</li>
<li><p>每次发送数据包，则会启动计时器，如果超时没收到回应，立马重发数据包，一直循环，直到收到确认信息，才会停止计时器，并发送下一个包。</p>
</li>
<li><p>问题：</p>
<ul>
<li><p>如果传输时间较长，以至于超时一直重新发送，而对方都会收到并返回<code>ACK</code>，这样的话，就会使得<code>等待ACK</code>收到很多回复，需要在收到第一个回复之后，丢弃后续的回复</p>
</li>
<li><p>可能存在，当前的<code>等待ACK1</code>收到的是上一个循环的<code>ACK1</code>回复。这是序号太少的缘故，只有<code>0 1</code>两个序号，无法分辨，可以对序号进行一个扩展，使其变成跟<code>TCP</code>一样。</p>
<blockquote>
<p><code>TCP</code>刚开始的序号（即三次握手后的序号）是随机生成的，然后每发一个字节，序号增一，则序号从一开始就不是从零开始，而且每次序号都会往上加，这样发送冲突的可能性就大大降低。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="其余方法："><a href="#其余方法：" class="headerlink" title="其余方法："></a>其余方法：</h4><ul>
<li>回退N路法（<code>TCP</code>正常协议）</li>
<li>选择重传法（<code>TCP</code>正常协议）：效率较高</li>
<li>流量控制</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>运输层协议——TCP协议</title>
    <url>/2021/01/12/0027.%20%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="运输层协议——TCP协议"><a href="#运输层协议——TCP协议" class="headerlink" title="运输层协议——TCP协议"></a>运输层协议——TCP协议</h1><h3 id="TCP发送缓存和接收缓存"><a href="#TCP发送缓存和接收缓存" class="headerlink" title="TCP发送缓存和接收缓存"></a>TCP发送缓存和接收缓存</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084629.png" alt="image-20210214194742308" style="zoom:50%;">

<ul>
<li>应用层与运输层直接间隔着<code>套接字</code></li>
</ul>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084634.png" alt="image-20210214194902383" style="zoom:50%;">

<ul>
<li>序号（32位）：当前发的字节流序号，比方当前的序号是1000，需要发1000个字节，则下次发送时，下一次的序号则从2000开始，这个序号是字节流的号。对方可以通过序号知道发送方发送的是哪个包。</li>
<li><code>URG</code>：紧急数据</li>
<li><code>PSH</code>：立即上交</li>
<li><code>ACK</code>：确认</li>
<li><code>RST</code>：这个端口不存在，选择其他端口连接</li>
<li><code>SYN</code>：三次握手，建立连接</li>
<li><code>FIN</code>：四次挥手，断开连接</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084642.png" alt="image-20210214195915981" style="zoom:50%;">

<ul>
<li>在终端上打开远程云主机，然后输入一个字符（”X”），从确认输入到终端显示这个字符的这段时间，发生了什么？（基础面试题目）</li>
<li>从本地按了<code>X</code>之后，键盘感知到电流波动之后，键盘驱动程序（内核）感知到，然后在内核里面查询这个程序（标准输入）被谁打开了，知道了是被<code>itemto</code>发起了请求，则把<code>X</code>交给<code>itemto</code>，然后由<code>itemto</code>发送给远程云主机，远程云主机收到之后，回一个<code>ACK</code>，附带着把<code>X</code>给传输回来，本地收到<code>X</code>之后，就知道远程云主机已经收到了<code>X</code>， 就会在终端显示出<code>X</code>。</li>
</ul>
<h3 id="TCP往返时间估算"><a href="#TCP往返时间估算" class="headerlink" title="TCP往返时间估算"></a>TCP往返时间估算</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084649.png" alt="image-20210214201020087" style="zoom:50%;">

<ul>
<li><code>SampleRTT</code>：样本时间，单个包的往返时间；样本时间在整个交互过程中一直可以拿到。</li>
<li><code>EstimatedRTT</code>：估算时间</li>
<li><code>DevRTT</code>：真实时间与预估时间的差值，即容差</li>
<li><code>TimeoutInterval</code>：超时时间</li>
</ul>
<p>如果只有一次样本时间比较长，并不会对超时时间有多大影响；如果由持续的样本超时，才会对超时时间造成影响。</p>
<h3 id="流量控制：针对发送方来抑制发送速度"><a href="#流量控制：针对发送方来抑制发送速度" class="headerlink" title="流量控制：针对发送方来抑制发送速度"></a>流量控制：针对发送方来抑制发送速度</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084653.png" alt="image-20210214202148472" style="zoom:50%;">

<ul>
<li><p>两个缓冲区：发送缓冲区、接收缓冲区</p>
</li>
<li><p><code>rwnd</code>：接收缓冲区</p>
</li>
</ul>
<h3 id="三次握手（面试常考）"><a href="#三次握手（面试常考）" class="headerlink" title="三次握手（面试常考）"></a>三次握手（面试常考）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084659.png" alt="image-20210214202647656" style="zoom:50%;">

<ul>
<li><p>客户端发起，发送<code>SYN</code>包</p>
</li>
<li><p>服务端原本阻塞在<code>accept</code>，感知到数据来临时，查看数据，发现是<code>SYN</code>包，即对方要跟自己<code>握手</code>，则服务端发送回一个<code>SYN+ACK</code>报文</p>
</li>
<li><p>客户端收到<code>SYN+ACK</code>报文，表明服务端已经是确认该客户端可以对服务端进行连接，此时连接就基本确定，则客户端给服务端回发一个<code>ACK</code>。</p>
<blockquote>
<p>记住发送的每个包的名字</p>
<p>回答为什么是三次握手，不是两次握手，四次握手？</p>
<ul>
<li><p>从发起方的角度，三次握手中，客户端可以确认发送的信息能被服务端收到，服务端发送的信息，客户端能收到；</p>
</li>
<li><p>从接收方的角度，三次握手中，服务端可以确认发送的信息能被客户端收到，客户端发送的信息，服务端能收到；</p>
<p>两端发送的信息，都能确认被收到，就成功了。</p>
<p>假设最后一次握手取消，则服务端并不能确认自己发的数据，客户端有没有接收到，充满不确定性。</p>
<p>至于超过三次的握手，其实是可以的，但是三次握手已经足够证明双方确认收到信息了，也就没什么必要握手超过三次了，不然就是没用的冗余操作了。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="四次挥手（面试常考）"><a href="#四次挥手（面试常考）" class="headerlink" title="四次挥手（面试常考）"></a>四次挥手（面试常考）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084706.png" alt="image-20210214204239720" style="zoom:50%;">

<ul>
<li><p>发起方（客户端）发送<code>FIN</code>给接收方（服务端）。</p>
</li>
<li><p>接收方收到<code>FIN</code>，确认了对方的<code>分手信息</code>后，会根据自己的情况，确定是否<code>分手</code>，如果确定则会回发一个<code>ACK</code>同意对方的操作；如果选择<code>不分手</code>，会出现异常，即客户端断开连接，但服务端没断开连接，这种叫<code>半关闭连接（半连接）</code>，会生成一种<code>有害的特殊状态的套接字</code>。</p>
<blockquote>
<p>假如一开始有100个连接断并形成这种半连接状态，而服务器只能维护1024个连接，则如果半连接的数目一直增多，最终服务器只能维护这些半连接，而无法建立新连接，从而无法与新连接进行交互。</p>
<p>所以，<code>切记不能写出半连接联系方式！！！！</code></p>
</blockquote>
</li>
<li><p>同时，接收方也会发送<code>FIN</code>给发起方，表明自己也会<code>断开连接</code></p>
</li>
<li><p>发起方收到<code>FIN</code>后，也会回发一个<code>ACK</code>同意对方的操作，同时等待<code>两个最大生存周期（30s到120s不等）</code>时间</p>
<blockquote>
<p>为什么要四次挥手呢？</p>
<p>为什么最后发起方要等待<code>两个最大生存周期（30s到120s不等）</code>？</p>
<ul>
<li>因为最后的<code>ACK</code>可能会丢包，如果丢包失效，服务器会重新发送一个<code>FIN</code>信号给客户端确认，没有确认就一直发，所以需要等待，以防最后的<code>ACK</code>丢包失效，避免损耗服务器资源。同时，假如断开连接后，客户端的另一个进程恰巧重新打开这个端口，同时上次连接服务器发送的包延迟了，导致当前客户端收到了上一个客户端应该收到的包。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="TCP-状态转换序列"><a href="#TCP-状态转换序列" class="headerlink" title="TCP 状态转换序列"></a>TCP 状态转换序列</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084715.png" alt="image-20210214210354730" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084728.png" alt="image-20210214210442417" style="zoom:50%;">

<ul>
<li>写程序很有用</li>
<li>默认状态（初始状态）为：<code>closed</code>，然后调用<code>connect</code>函数，发送<code>SYN</code></li>
<li>切换成为<code>SYN_SENT</code>状态，表明已发送<code>SYN</code>，然后接收<code>SYNACK</code>，并发送<code>ACK</code></li>
<li>切换成<code>ESTABLISHED</code>，此时三次握手已经完成，直到这里，都是<code>connect</code>函数在操作；</li>
<li>连接之后就是关闭（四次挥手），发送<code>FIN</code>（第一次挥手），切换成<code>FIN_WAIT_1</code>，；</li>
<li>接收<code>ACK</code>，切换成<code>FIN_WAIT_2</code>，然后等着对方继续发送（第二次挥手）；</li>
<li>接收<code>FIN</code>并发送<code>ACK</code>，切换成<code>FIN_WAIT</code>，然后等待两个最大生存周期（第三、四次挥手）；</li>
<li>恢复成默认状态（初始状态）<code>closed</code></li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084734.png" alt="image-20210214211805183" style="zoom:50%;">

<ul>
<li>默认状态（初始状态）为：<code>closed</code>，然后调用<code>bind与listen</code>函数</li>
<li>切换成为<code>LISTEN</code>状态，此时就是<code>accept</code>函数阻塞中，然后接收<code>SYN</code>，并发送<code>SYNACK</code></li>
<li>切换成<code>SYN_RCVD</code>，接收<code>ACK</code>（带着数据<code>data</code>），此时三次握手已经完成，切换成<code>ESTABLISHED</code>连接状态</li>
<li>连接之后就是关闭（四次挥手），接收<code>FIN</code>，发送<code>ACK</code>（第一、二次挥手），切换成<code>CLOSE_WAIT</code>（等待时间极短，等待调用<code>close</code>函数）</li>
<li>发送<code>FIN</code>，切换成<code>LAST_ACK</code>状态，然后等着对方继续发送（第三次挥手）</li>
<li>接收<code>ACK</code>，切换成默认状态（初始状态）<code>closed</code>状态（第四次挥手）</li>
</ul>
<blockquote>
<p><code>CLOSE_WAIT</code>、<code>TIME_WAIT</code>比较重要，用得比较多，并且两者均有实际意义。</p>
</blockquote>
<h3 id="拥塞控制方法："><a href="#拥塞控制方法：" class="headerlink" title="拥塞控制方法："></a>拥塞控制方法：</h3><p>在网络中，如果通过协议的方式，尽量减少当网络延迟、波动、网络断开之后，数据暴增或减少而引起的网络更加影响网络的情况。</p>
<ul>
<li>端到端拥塞控制：<code>TCP</code><ul>
<li>超时：增加时延</li>
<li>冗余ACK</li>
<li>减小发送窗口来让数据变小</li>
<li>流量控制，使得发送窗口减小</li>
</ul>
</li>
<li>网络辅助的拥塞控制</li>
</ul>
<blockquote>
<p>在底层<code>网络层</code>也支持这样的控制。</p>
</blockquote>
<h4 id="ATM、ABR拥塞控制"><a href="#ATM、ABR拥塞控制" class="headerlink" title="ATM、ABR拥塞控制"></a>ATM、ABR拥塞控制</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084742.png" alt="image-20210214221637878" style="zoom: 50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084747.png" alt="image-20210214221616763" style="zoom:50%;">

<ul>
<li>ATM是不同于分组网络之外的另一种网络。</li>
<li>把数据包分成<code>数据信元</code>和<code>资源管理信元RM</code>，比例是32 ：1，即32个数据信元后就有一个管理信元</li>
<li><code>资源管理信元RM</code>：夹杂在<code>数据信元</code>中，一起从客户端移动到服务器端，并记录下这一段路程哪里阻塞了，哪里不会，然后再原封不动的从服务器端返回客户端，通知客户端这段路是否阻塞。同时，没经过一个路由器的时候，都会被路由器感知到，并查看接下来的路是否发送阻塞，如果阻塞，则路由器会调整自己线路。<ul>
<li>显示转发拥塞指示：<code>EFCI(1bit)</code>，只要这条链路中其中有一个点拥塞了，则会被置为1，让发送方、接收方跟路由器都知道这条链路已经存在问题。</li>
<li>当目标主机收到大多数为<code>EFCI</code>，则会将其收到的<code>RM信元</code>的<code>CI（拥塞指示比特）</code>设置为<code>1</code></li>
<li>显示速率<code>ER</code>（两字节）：指示整个链路的速度，经过每个交换机，都会被更新，目的是为了找到网络的吞吐量。</li>
</ul>
</li>
</ul>
<h3 id="TCP拥塞窗口"><a href="#TCP拥塞窗口" class="headerlink" title="TCP拥塞窗口"></a>TCP拥塞窗口</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084753.png" alt="image-20210214223217108" style="zoom:50%;">

<h3 id="TCP拥塞控制的指导思想"><a href="#TCP拥塞控制的指导思想" class="headerlink" title="TCP拥塞控制的指导思想"></a>TCP拥塞控制的指导思想</h3><ul>
<li><p>一个丢失的报文段意味着拥塞，丢包就应该减小发送端的发送速率</p>
</li>
<li><p>一个确认的报文段表示网络正在向接收方交付报文段，因此，当收到对之前的报文段的<code>ACK</code>后，应该增加发送方速率</p>
</li>
<li><p>带宽探测（动态调整）：每次都应该尽可能的加大带宽，直到出现丢包现象才抑制。</p>
<blockquote>
<p>几个实验方式如下。</p>
</blockquote>
</li>
</ul>
<h3 id="实验方式一：拥塞控制之慢启动"><a href="#实验方式一：拥塞控制之慢启动" class="headerlink" title="实验方式一：拥塞控制之慢启动"></a>实验方式一：拥塞控制之慢启动</h3><ul>
<li><p><code>TCP</code>连接建立之初，<code>cwnd</code>被设置为<code>1MSS</code>（一个最大报文段长度），每收到一个确认，将<code>cwnd</code>增加一个<code>MSS</code>。</p>
</li>
<li><p>在慢启动过程中，刚开始速度慢，但是会以指数级增长（1、2、4、8）</p>
</li>
<li><p>结束慢启动：</p>
<ul>
<li><p><code>timeout</code>：重新开始慢启动，慢启动阈值被设置为<code>cwnd/2</code></p>
<blockquote>
<p>就比如现在发送了16个MSS，其中一个超时（带宽探测），说明发送量太大，重新设置为8</p>
</blockquote>
</li>
<li><p><code>cwnd &gt;= ssthresh</code>：进入拥塞避免模式</p>
<blockquote>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul>
<li>在拥塞避免状态下，<code>cwnd</code>每一个<code>RTT</code>增加一个<code>MSS</code>，线性增加（<code>指数增变成线性增</code>）</li>
<li>结束：<ul>
<li><code>timeout</code>：重新开始慢启动，慢启阈值被设置为<code>cwnd/2</code></li>
<li>3个冗余<code>ACK</code>：快速重传，进入快速恢复模式</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>3个冗余<code>ACK</code>：快速重传，进入快速恢复模式（网络没问题，数据包可能出现异常）</p>
<blockquote>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul>
<li>对收到的每一个<code>冗余ACK</code>，<code>cwnd</code>增加一个<code>MSS</code>（类似指数）</li>
<li>结束：<ul>
<li>收到<code>new ACK, cwnd = ssthresh</code>，并进入拥塞避免</li>
<li><code>timeout</code>：重新开始慢启动，慢启阈值被设置为<code>cwnd/2</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084800.png" alt="image-20210214225741896" style="zoom:50%;">

<h2 id="面试考点"><a href="#面试考点" class="headerlink" title="面试考点"></a>面试考点</h2><p>运输层核心重点：TCP、 UDP</p>
<p>面试喜欢问的问题：</p>
<ul>
<li>TCP为主</li>
<li>UDP：TCP与UDP有哪些区别，为什么有时选TCP，有时选UDP；<ul>
<li>时间敏感</li>
<li>丢包影响不大</li>
<li>成本低</li>
<li>对何时发数据，发什么数据，有更加精细的控制（想发就发，无须受到协议的限制）</li>
<li>如果产生了网络风暴，想要发信息给局域网内的其他机器，让其停止转发一切消息，好停止网络风暴，这个时候，就需要用到UDP，否则用TCP的效率太低</li>
<li>从整个网络来说，UDP对整个网络是不友好的，因为UDP从不考虑网络处于什么状态，自顾自的发送信息。</li>
</ul>
</li>
</ul>
<p>用远程终端，输入一个字符时，会发生什么事情？</p>
<p>SYN攻击：<br>        在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV</p>
<p>四次挥手：不管时服务端还是客户端，都可以发起挥手</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2021/01/13/0028.%20%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="01-IP地址"><a href="#01-IP地址" class="headerlink" title="01 IP地址"></a>01 IP地址</h2><h3 id="IP地址的基本结构"><a href="#IP地址的基本结构" class="headerlink" title="IP地址的基本结构"></a>IP地址的基本结构</h3><ul>
<li>IP地址由32位二进制组成</li>
<li>为了方便记忆，增加可读性，使用<code>点分十进制</code>表示</li>
<li>目前IPV6已经扩展位128位，国内教育网中已有使用</li>
<li>国内现阶段IPV6为过渡阶段，面试笔试中极少出现</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084813.png" alt="image-20210302201156342" style="zoom: 50%;">

</li>
</ul>
<h3 id="MAC地址（物理地址、网卡地址）"><a href="#MAC地址（物理地址、网卡地址）" class="headerlink" title="MAC地址（物理地址、网卡地址）"></a>MAC地址（物理地址、网卡地址）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084817.png" alt="image-20210302201329716" style="zoom:50%;">



<ul>
<li>原则上，每个网卡地址都有一个唯一的编号 </li>
<li>MAC地址用 ：分割；</li>
<li>MAC地址作用与数据链路层</li>
<li>以太网协议，APR协议；</li>
<li>相关命令ifconfig，ARP</li>
<li>与MAC地址相关的设备：网卡交换机</li>
</ul>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084824.png" alt="image-20210302201709853" style="zoom: 50%;">

<ul>
<li><p>早些年IP地址有分类</p>
</li>
<li><p>近些年已经不需要了，因为这个分类麻烦。</p>
</li>
<li><p>现在都是使用无类别分支法，就是直接通过掩码的长度来设置IP地址，掩码掩盖住的就是网络号，掩码没掩盖住的就是主机号。</p>
</li>
<li><p>子网掩码：用来区分大家是不是在同一个局域网中</p>
<blockquote>
<p>如果大家都是在同一个局域网中，则双方的沟通只需在局域网内喊一声即可；</p>
<p>如果不在同一个局域网，则需要使用更加复杂的线路，此时就需要通过网关</p>
</blockquote>
</li>
<li><p>网关：出口路由，如果需要将信息传递给非本地局域网的另一个用户，就需要经由网关来选择。具备一个公网IP。</p>
</li>
<li><p>广播（boardcast）： 向所有具有特定广播号的主机发送信息</p>
<blockquote>
<p>192.168.1.255就是一个广播，表示要给所有具有192.168.1这个网络号的主机发送信息。</p>
</blockquote>
</li>
</ul>
<h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084830.png" alt="image-20210302203224011" style="zoom: 50%;">

<ul>
<li>ARP协议、RARP协议：实现 IP地址 与 MAC地址的相互转换</li>
<li>ARP协议的工作位置：<ul>
<li>网络层：因为是对IP地址的处理</li>
<li>数据链路层：因为是转为MAC地址 </li>
</ul>
</li>
</ul>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><ul>
<li>写程序比如QQ、微信等跟网络层均没有任何关系，网络层的变化跟我们并无多大联系。我们需要做到的就是理解网络层，理解数据怎么通过网络从A主机到达B主机</li>
</ul>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul>
<li>当一个分组到达路由器的一条输入链路时，路由器必须将其移动到合适的输出链路，这个移动的过程称为转发</li>
<li>每台路由器都有一个转发表，路由器通过检查到达分组的首部字段的值（最长前缀匹配）来转发分组</li>
</ul>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><ul>
<li>当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为<code>路由选择算法</code>。</li>
<li>路由选择算法：<ul>
<li>核心：更新迭代<code>路由转发表</code>，因为路由器就是从<code>路由转发表</code>中为数据包选择传递路线的。决定整个网络范围内的端到端的路劲选择</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084837.png" alt="image-20210302210111672" style="zoom: 50%;"></li>
<li>路由选择算法如果不好，可能会造成<code>网络风暴</code>，甚至更严重，会使得所有的主机都没法收到准确的数据包</li>
<li><code>转发表</code>决定本地路由器内部转发的出口</li>
</ul>
</li>
</ul>
<h3 id="一个简单的虚电路网络"><a href="#一个简单的虚电路网络" class="headerlink" title="一个简单的虚电路网络"></a>一个简单的虚电路网络</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084849.png" alt="image-20210302210701358" style="zoom: 50%;">

<h3 id="虚电路建立"><a href="#虚电路建立" class="headerlink" title="虚电路建立"></a>虚电路建立</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084855.png" alt="image-20210302210925885" style="zoom:50%;">

<ul>
<li>最后记得断开连接</li>
</ul>
<h3 id="数据报网络（分组网络）"><a href="#数据报网络（分组网络）" class="headerlink" title="数据报网络（分组网络）"></a>数据报网络（分组网络）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084859.png" alt="image-20210302211024220" style="zoom:50%;">

<ul>
<li><p>每个数据报的路线可能都不一样，最终到达目的地就行，丢了则重传</p>
</li>
<li><p>每个数据报到达路由器的那一刻，路由转发表的值决定了这个数据报应该怎么走</p>
<blockquote>
<p>路由转发表的更新速度特别特别快</p>
</blockquote>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084904.png" alt="image-20210302211348177" style="zoom:50%;">
</li>
<li><p>真实的路由转发表，其IP地址是一个<code>IP范围</code>（最长前缀匹配）</p>
</li>
</ul>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084910.png" alt="image-20210302211745788" style="zoom:50%;">

<ul>
<li>家里常见的路由器属于个人路由器，是一种及其低端的产品，工业级的路由器，全身都是网口</li>
<li>虚线上面：路由选择、管理控制平面，<code>不负责转发数据</code></li>
<li>虚线下面：数据转发平面</li>
<li>每个路由器都应该具备接收、给其他同类发送信息的功能，这个功能就是路由选择处理器做的</li>
</ul>
<h3 id="路由器——输入端口"><a href="#路由器——输入端口" class="headerlink" title="路由器——输入端口"></a>路由器——输入端口</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084923.png" alt="image-20210302212108764" style="zoom:50%;">

<ul>
<li>线路端接：实现光电转换，把电信息转为光信息，通过光纤传递。</li>
<li>数据链路处理：协议的拆封</li>
<li>查找、转发、排队：查找目的地，进入排队等待发出，队列满员时，会丢弃多余的包，至于丢弃的是最开始的包还是最后的包，说不准。</li>
</ul>
<h3 id="路由器——交换结构"><a href="#路由器——交换结构" class="headerlink" title="路由器——交换结构"></a>路由器——交换结构</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084928.png" alt="image-20210302212449606" style="zoom:50%;">

<ul>
<li>内存：家庭常用的路由器就是这种</li>
<li>总线：速度快，但可能会发生冲突，如果两个数据的目的地相同，就可能线路撞线，如果在数据及其繁忙的时候，其效率就会直线下降</li>
<li>纵横式：红点是控制器，数据传输过程中，红点会按需打开线路，减少冲突。企业级用得多，成本高。</li>
</ul>
<h3 id="路由器——输出端口"><a href="#路由器——输出端口" class="headerlink" title="路由器——输出端口"></a>路由器——输出端口</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084933.png" alt="image-20210302212823501" style="zoom:50%;">

<ul>
<li>输出端口的排队更常见，排队时，也会出现丢包</li>
</ul>
<h3 id="网络层的协议族"><a href="#网络层的协议族" class="headerlink" title="网络层的协议族"></a>网络层的协议族</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084938.png" alt="image-20210302212941109" style="zoom:50%;">

<ul>
<li>转发表最重要，因为它决定了网络层能提供什么服务，以及选择的路径是否最优化</li>
</ul>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084943.png" alt="image-20210302213107689" style="zoom:50%;">

<ul>
<li>寿命：没经过一个路由器，寿命减一，避免数据报找不到目的地，一直在网络中游荡。</li>
</ul>
<h3 id="DHCP协议（面试常考题目）"><a href="#DHCP协议（面试常考题目）" class="headerlink" title="DHCP协议（面试常考题目）"></a>DHCP协议（面试常考题目）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084948.png" alt="image-20210302213218482" style="zoom:50%;">

<ul>
<li>题目：在腾讯的会客室，用自己的电脑连上对方的wify时，发生了什么事情？</li>
<li>不考虑接入wify时需要认证等，只考虑连上网络后，是怎么接入网络，或者是拿到一个有效的IP地址</li>
</ul>
<ol>
<li>当连入wify时，相当于已经可以借助某种特殊的介质，能跟网络中的所有电脑进行通讯</li>
<li>电脑有一个确定MAC地址，现在需要通过MAC地址拿到一个可以使用的IP地址（DHCP的任务）</li>
<li>当电脑到一个新网络的时候，会发生一个广播（目的地：255.255.255.255， 端口：67），整个网络的所有主机都会收到这个数据报，都已经知道有<code>新朋友</code>加入网络了，而且<code>新朋友</code>没有IP地址，再向他们请求一个IP地址</li>
<li>所有主机都收到数据报，但仅有少部分会回应，这部分主机会给<code>新朋友</code>发送一个<code>DHCP offer</code>，里面包含该主机的IP地址（223.1.2.5，端口：67），、能用IP地址（223.1.2.4），并广播所有人，通知其他所有主机，它已经给<code>新朋友</code>一个IP地址</li>
<li><code>新朋友</code>会在收到的多个<code>offer</code>中选择一个，然后给发送该<code>offer</code>的主机发送信息，通知对方，此时<code>新朋友</code>的IP地址还是0（0.0.0.0，68），并广播</li>
<li>发送<code>offer</code>的主机收到信息后，会回发一个同意申请的<code>ACK</code>，并广播，此时整个网络中的所有人都会知道<code>新朋友</code>的IP地址是多少，MAC地址是多少</li>
</ol>
<h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084954.png" alt="image-20210302214847819" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084958.png" alt="image-20210302215431748" style="zoom:50%;">

<ul>
<li>拿到的IP地址都是局域网的IP地址，并不是公网的IP地址，公网的IP地址比较珍贵</li>
<li>那为什么能上百度（公网IP）呢？<ul>
<li>局域网内的主机想要连接局域网外的IP，需要局域网内的主机主动发起请求，请求会经过<code>传达室（网关，具备公网IP）</code>，被网关记录下相关地址信息，然后发送出去，信息回来时，也会先经过网关，网关会在记录中查找回信的目的地信息，然后转发给局域网的发送方</li>
<li>因为多了网关，局域网，所以局域网内的主机不会那么容易就被黑客入侵；而云主机经常遭受攻击，是因为云主机的IP地址是一个公网的IP地址，是任何人在任何时候任何地点都可以进入的。</li>
</ul>
</li>
<li>信息的传递是经过多个路由器的。如果有防火墙，则数据在经过防火墙时，会被拆开检查，检查里面的信息是否合规，如果不合规，会被直接丢弃，同时，可以通过IP地址找到对应的MAC地址，从而得知是谁发的不合规信息。</li>
</ul>
<h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><ul>
<li>ICMP协议被主机和路由器用来彼此沟通网络层的信息<ul>
<li>差错报告</li>
<li>ICMP位于IP之上，报文由IP分组承载</li>
</ul>
</li>
<li>ping命令：ICMP协议的一个子命令，进行主机之间的探测，探测对方是否存在<ul>
<li>依赖于主机的端口开发</li>
</ul>
</li>
<li>报文类型：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085002.png" alt="image-20210302221227875" style="zoom:50%;">

</li>
</ul>
</li>
</ul>
<h3 id="因特网中自治系统内部路由选择协议-RIP"><a href="#因特网中自治系统内部路由选择协议-RIP" class="headerlink" title="因特网中自治系统内部路由选择协议 RIP"></a>因特网中自治系统内部路由选择协议 RIP</h3><ul>
<li><p>互联网是一个大拼图，由许多小拼图构成</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085145.png" alt="image-20210306085143962"></p>
</li>
<li><p>hops：跳，就是到某个路由器最短需要经过几个路由器</p>
</li>
<li><p>每个路由器都应该及时的获取其他路由器的信息（集群服务）</p>
<blockquote>
<p>很多时候，写集群服务/分布式应用的时候，最核心的内容就是节点与节点之间能不能进行<code>协同工作</code>，即每个节点都能动态的获取其他节点的信息，使得负载均衡。</p>
<p>分布式：把应用或者服务分布在不同的机器上，让其去执行，利用每个机器的并发性，来增加业务的吞吐量、响应能力、支撑能力。</p>
</blockquote>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085103.png" alt="image-20210306085101570"></p>
</li>
<li><p>RIP协议：只跟自己的邻居交换路由表，然后计算获取的路由表，从而更新自己的路由表</p>
<blockquote>
<p>这个思想可以用来写一个小的集群服务。</p>
<p>缺陷：需要一段时间，才能更新到边缘部分的路由器，不及时</p>
</blockquote>
</li>
</ul>
<h3 id="因特网中自治系统内部路由选择协议-OSPF（最短路优先）"><a href="#因特网中自治系统内部路由选择协议-OSPF（最短路优先）" class="headerlink" title="因特网中自治系统内部路由选择协议 OSPF（最短路优先）"></a>因特网中自治系统内部路由选择协议 OSPF（最短路优先）</h3><ul>
<li>RIP的后继者</li>
<li>向整个As内部所有的路由器广播</li>
<li>使用Dijkstra最短路径树</li>
</ul>
<h3 id="自治系统间的路由选择-BGP"><a href="#自治系统间的路由选择-BGP" class="headerlink" title="自治系统间的路由选择 BGP"></a>自治系统间的路由选择 BGP</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085157.png" alt="image-20210302223119583" style="zoom:50%;">

<ul>
<li>在每一个自治系统之间（自己与邻居之间）多一条扩展的会话（真实的TCP连接）， 两个边境上的主机会通过TCP连接，时时刻刻不断的交换自己的路由信息。 </li>
</ul>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul>
<li>DHCP</li>
<li>数据报结构</li>
<li>路由器结构</li>
<li>转发表</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2021/01/14/0029.%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="网络设配器（链路层最常见的设备）"><a href="#网络设配器（链路层最常见的设备）" class="headerlink" title="网络设配器（链路层最常见的设备）"></a>网络设配器（链路层最常见的设备）</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085205.png" alt="image-20210302223703487" style="zoom:50%;">

<h2 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h2><ul>
<li><p>成帧（数据传输单元）</p>
</li>
<li><p>链路接入</p>
<blockquote>
<p>MAC：媒体访问，硬件地址</p>
</blockquote>
</li>
<li><p>可靠交付</p>
<blockquote>
<p>如果链路层可靠了，应用层等都一定可靠，因为底层可靠，上层一定可靠。所以为什么不在链路层实现可靠交付？</p>
<ul>
<li>因为数据出错的可能性较小，如果为了小概率的出错，而在数据链路层实现可靠交付，做到需要对方确认、超时重传等，这个成本就会变得特别大，而且效率会降低</li>
</ul>
</blockquote>
</li>
<li><p>差错检测和纠正</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085211.png" alt="image-20210302224604140" style="zoom:50%;">
</li>
<li><p>检测差错的三种技术：</p>
<ul>
<li><p>奇偶校验（常用，高效）</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085253.png" alt="image-20210306085252264" style="zoom: 67%;">
</li>
<li><p>大部分是一维的，如果是二维的，就可以直接定位是哪里出错从而直接纠正</p>
<blockquote>
<p>检测错误较为简单，而纠正则比较麻烦，需要纠正码等，所以通常只要发现错误，就直接丢掉数据报，等待重传。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>检验和</p>
</li>
<li><p>循环冗余检测</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085302.png" alt="image-20210302225014932" style="zoom:50%;">

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="链路层协议集（在链路层的协议描述了什么）"><a href="#链路层协议集（在链路层的协议描述了什么）" class="headerlink" title="链路层协议集（在链路层的协议描述了什么）"></a>链路层协议集（在链路层的协议描述了什么）</h2><ul>
<li>给每个人一个讲话的机会</li>
<li>该你讲话时才讲话</li>
<li>不要一个人独占整个谈话</li>
<li>如果有问题请举手</li>
<li>当有人讲话时不要打断</li>
<li>当其他人讲话时不要睡觉</li>
</ul>
<h3 id="信道划分协议-TDMA（时分复用）、FDMA（频分复用）"><a href="#信道划分协议-TDMA（时分复用）、FDMA（频分复用）" class="headerlink" title="信道划分协议 TDMA（时分复用）、FDMA（频分复用）"></a>信道划分协议 TDMA（时分复用）、FDMA（频分复用）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085307.png" alt="image-20210303082938152" style="zoom:50%;">

<ul>
<li><p>时分复用：按时间段分割</p>
<blockquote>
<p>并发、并行</p>
<p>时分复用到底是增加了并发性还是并行性呢？</p>
</blockquote>
</li>
<li><p>频分复用：按频率分割</p>
</li>
</ul>
<h3 id="信道划分协议-CDMA（重要）"><a href="#信道划分协议-CDMA（重要）" class="headerlink" title="信道划分协议 CDMA（重要）"></a>信道划分协议 CDMA（重要）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085312.png" alt="image-20210303084215553" style="zoom:50%;">

<ul>
<li><p>wify、手机信号都是基于该信号</p>
</li>
<li><p>现在手机跟电脑都在用无线网络，两者共用的是一个信道，其电磁波在空间中传递。这两种电磁波会相互影响，而<code>CDMA</code>协议就是为了解决如果在不互相影响的情况下，两者并行，同时工作</p>
</li>
<li><p>以一个发送者为例：</p>
<ol>
<li>发送发：发送code两个比特（slot1、slot0）的信息，一个高电位（$ d_0 $）、一个低电位（$ d_1 $），为了方便计算，设置$ d_1 = -1 $（原本是低位0，高位1，但为了方便计算，才这么设置，因为负负得正，算起来比较容易），通过 $ Z_{i,m} = d_i * c_m $计算得到一个信道传输的真实数据</li>
<li>接收方：收到发送方的<code>信道传输的真实数据</code>，同时接收方需要知道发送方的<code>code</code>， 通过$ D_i = \frac{\sum_{m=1}^{n}{Z_{i,m}*c_m}}{b} $ 获得真实的两个比特信息</li>
<li>缺陷：原本只需传递两比特的数据，现在需要变成传递code的16比特信息，数据量上升了.</li>
</ol>
</li>
<li><p>两个发送者就需要由两个不同的<code>code</code></p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085358.png" alt="image-20210306085356113" style="zoom: 67%;">
</li>
<li><p>所以，如果想要保证很多的用户在同一个网络空间中去发送自己的信息的话，编码（code）的长度应该足够，因为用户一多，每个用户的code都不同，使得code长度增加，同时处理的效率也会降低。</p>
</li>
</ul>
<h3 id="随时接入协议-时隙ALOHA（看成是总线型，时分复用）"><a href="#随时接入协议-时隙ALOHA（看成是总线型，时分复用）" class="headerlink" title="随时接入协议 时隙ALOHA（看成是总线型，时分复用）"></a>随时接入协议 时隙ALOHA（看成是总线型，时分复用）</h3><ul>
<li>所有帧 由L比特组成</li>
<li>时间被划分为长度为L/R秒的时隙（R为信道全部的速率）</li>
<li>结点只在时隙起点开始传输帧</li>
<li>结点是同步的，每个结点都知道时隙何时开始</li>
<li>如果时隙中有两个或者多个帧碰撞，则所有结点在该时隙结束之前检测到该碰撞事件</li>
<li>令p是一个概率，在每个结点中，时隙ALOHA的操作是：<ul>
<li>当结点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧</li>
<li>如果没有碰撞，该结点成功传输它的帧</li>
<li>如果有碰撞，该结点在时隙结束之前检测到该碰撞事件。该节点在后续的时隙中以p的概率重传这个帧，直到成功重传 </li>
</ul>
</li>
<li>发送的数据的真实情况<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085414.png" alt="image-20210303092352707" style="zoom:50%;">
- 为了在碰撞的情况下还能成功发送，在三个结点传输三个数据的时候，在这种随机的情况下，需要发送很多次才能成功发送。
- 结点少的时候已经这样，如果结点一多，肯定网络延迟，差评！

</li>
</ul>
</li>
</ul>
<h3 id="载波侦听多路访问-CSMA-CD"><a href="#载波侦听多路访问-CSMA-CD" class="headerlink" title="载波侦听多路访问 CSMA/CD"></a>载波侦听多路访问 CSMA/CD</h3><ul>
<li><p>说话之前先听（载波侦听）</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085420.png" alt="image-20210303093104299" style="zoom:50%;">
</li>
<li><p>如果与他人同时开始说话，停止说话（碰撞检测）</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085426.png" alt="image-20210303093132969" style="zoom:50%;">

</li>
</ul>
<h3 id="轮流协议、轮询协议"><a href="#轮流协议、轮询协议" class="headerlink" title="轮流协议、轮询协议"></a>轮流协议、轮询协议</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085431.png" alt="image-20210303093236399" style="zoom:50%;">

<ul>
<li>slaves发起请求，master才发送数据</li>
<li>缺点：单点故障，只要master端断了，则立马出故障</li>
</ul>
<h3 id="轮流协议、令牌传递协议"><a href="#轮流协议、令牌传递协议" class="headerlink" title="轮流协议、令牌传递协议"></a>轮流协议、令牌传递协议</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085436.png" alt="image-20210303093416313" style="zoom:50%;">

<ul>
<li>请求循环一周，谁需要谁发送</li>
</ul>
<h3 id="以太网技术、以太网帧结构"><a href="#以太网技术、以太网帧结构" class="headerlink" title="以太网技术、以太网帧结构"></a>以太网技术、以太网帧结构</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085441.png" alt="image-20210303093510394" style="zoom:50%;">

<ul>
<li>前同步码：网卡感知到这个的时候，就会知道这是一个正经的数据，才会接收</li>
<li>目的地址：MAC地址，如果是<code>FFFFFF</code>就是广播地址</li>
</ul>
<h3 id="交换机表"><a href="#交换机表" class="headerlink" title="交换机表"></a>交换机表</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306085445.png" alt="image-20210303093800569" style="zoom:50%;">

<ul>
<li><p>交换机工作在二层（一层是物理层，三层是IP层）</p>
<blockquote>
<p> 三层交换机（有点路由器的作用）、多层交换机，通常说的交换机指的是数据链路层交换机</p>
</blockquote>
</li>
<li><p>地址：MAC地址</p>
</li>
<li><p>接口：交换机连接的机器是谁</p>
</li>
<li><p>总线连接网络，主机一多，就容易发生碰撞。<code>hub集线器</code>只起到了信号的加强，多个设备通过<code>hub集线器</code>连接在一起，势必会发生冲突，这个时候，就需要交换机了！</p>
<blockquote>
<p><code>hub集线器</code>：把多个设备连接在一起。</p>
</blockquote>
</li>
<li><p>交换机：本质上就是解决碰撞问题，通过检测信息目的地，然后直接传给接收方，而不是用广播，从而减少冲突。</p>
</li>
<li><p>过滤：去除不是信息接收方的主机，减少冲突</p>
</li>
<li><p>交换机的自学习：</p>
<ul>
<li>问题：停电了，在来电的那一刻，整个局域网发生了什么事情？</li>
<li>来电的时候，交换机、wify等各种设备都已经苏醒了（以有线网络为例子），交换机检测到链路正常，此时它检测自己缺一个IP地址，否则无法跟其他人通讯，所以会通过<code>DHCP</code>协议由网络中申请一个<code>IP地址</code>，通过广播寻找<code>DHCP服务器</code>，这是应用层，最终数据报会落到数据链路层， 然后再交给交换机，交换机会得知该服务器的地址，最终交换机会得到一个IP地址。</li>
<li>此时有一台主机如果访问百度，首先会先做DNS解析，如果本地由house文件，会直接从house文件中解析出百度的网址，如果没有，就会使用DNS；DNS的来源是在一开始申请IP地址时的DHCP服务器。这个时候就是跟DHCP服务器进行通讯，DHCP拿到的可能是一个外网IP。通过子网掩码判断是不是在通过局域网，如果不是，则需要前往网关（路由器），但路由器无法直接访问，则需要前往交换机，加入交换机不知道路由器在哪，则会通过广播得到百度的IP地址，然后再经过同样的请求，发起一个http请求（底层tcp）。</li>
<li>tcp层面贴上目标端口——IP层（网络层）贴上目标IP地址——本地网络通过子网掩码判断IP地址是在外网——数据链路层贴报文头部（真头部，网关地址）——通过ARP协议找到网关——通过有线连接直接到达交换机的某一个口，这个口只跟该主机相连接——交换机通过查询得知目标地址在交换机的某个结点上，把数据包直接转到对应的路由器——路由器通过判断，再经由链路层转发到目的地</li>
<li>到达百度服务器后，假设到机房，路由器收到数据检测目的地之后，交给交换机，再经由交换机转发给目标主机，目标主机检测收到的数据报后，会看到目的地址就是他自己，源地址是发送方的<code>公网IP地址以及端口</code>，处理后再交给运输层，再交给http服务器，检测请求之后（比如访问首页），就会读取自己的磁盘（更多的时候是在缓存中），拿到数据后，重新封装，贴上头部信息等再交给网络层，再交给数据链路层，逐步回到发送方的NAT服务器，NAT服务器检测后就一层一层传回到发送方的手上，这个时候百度的主页就显示在浏览器中。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/2021/01/15/0030.%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">            fd_set *exceptfds, <span class="keyword">const</span> struct timespec *timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_nsec;        <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>fd_set *readfds：文件描述符类型的指针，读文件</p>
</li>
<li><p>fd_set *writefds：文件描述符类型的指针，写文件</p>
</li>
<li><p>fd_set *exceptfds：文件描述符类型的指针，异常文件</p>
</li>
<li><p>struct timeval *timeout：时间结构体的超时</p>
</li>
<li><p>select 和 pselect 允许一个程序监控多个文件描述符，等待直到一个或者多个文件描述符的状态变成<code>ready</code>，即准备可以进行一些IO操作，比如非阻塞的读取文件。</p>
</li>
<li><p>select 和 pselect除了以下三个操作之外，其他操作均想通过：</p>
<ul>
<li>时间结构体不一样</li>
<li> select没有信号掩码（sigmask）参数</li>
<li>select可以更新timeout时间结构体，用来映射当前还有多少时间剩余（只在linux支持），pselect则不会</li>
</ul>
</li>
<li><p>三个独立的文件描述符集合被监视。readfds文件描述符会被查看是否有些字符变成就绪，当一个文件结束EOF时，就会变成ready；writefds文件描述符会被查看是否有空间可以写； exceptfds查看文件是否异常</p>
</li>
<li><p>退出的时候，每一个文件描述符将被原地修改，表明哪一个文件描述符已经改变了状态 ，所以如果使用一个循环来调用select时，每次都需要进行初始化。</p>
</li>
<li><p>如果没有任何一个文件描述符需要被监控，可以把所有的文件描述符指定为NULL</p>
</li>
<li><p>四个宏定义用来处理三个集合。</p>
<ul>
<li>FD_CLR：从一个集合中删除一个文件描述符</li>
<li>FD_ISSET：从一个集合中添加一个文件描述符</li>
<li>FD_SET：测试一个文件描述符是否是这个集合的一部分</li>
<li>FD_ZERO：清空集合</li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li><p>int nfds：文件描述符的数量，文件描述符最大的值+1</p>
</li>
<li><p>fd_set *readfds：</p>
</li>
<li><p>fd_set *writefds：</p>
</li>
<li><p>fd_set *exceptfds：</p>
</li>
<li><p>struct timeval *timeout：间隔时间，select监控等待的最长时间</p>
<ul>
<li>如果所有的timeval结构体为0，则select会立即返回</li>
<li>如果timeout为NULL，则select将会无期限的阻塞下去</li>
</ul>
</li>
<li><p>sigmask：信号掩码 </p>
<blockquote>
<p>程序收到信号，有三种操作：</p>
<ol>
<li>忽略</li>
<li>自杀</li>
<li>执行特定任务</li>
</ol>
<p>信号掩码就是选择性的忽略一些信息，底层感知不到这些信息。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功则返回三个文件描述符集合中，文件描述符的总数。</li>
<li>如果失败返回-1，并设置errno，同时该文件描述符不会被修改，timeout变成未定义</li>
</ul>
</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同步IO多路复用，实现IO的多路传输</p>
</li>
<li><p>本质：一个线程或者处理器，能够在很短的时间内响应很多事件</p>
<blockquote>
<p>很短的时间内响应很多事件大多数是多线程、多进程的任务，但是在一个线程的情况下，也可以模拟出来。</p>
</blockquote>
</li>
<li><p>检查文件描述符的集合里面有哪些是已经<code>ready</code>准备进行IO操作的</p>
<blockquote>
<p>指针和数组有什么区别？</p>
<p>数组如果作为一个函数的参数，会退化成一个指针；如果想把整个数组传递给函数，必须传递加上数组的大小。</p>
</blockquote>
</li>
<li><p>events与revents的子网掩码event bitmasks有以下操作可以当作掩码：</p>
<ul>
<li>PLLERR：设备或套接字发生异常的情况。只在revents使用与展示</li>
<li>POLLHUP：设备或者套接字被断开连接。与POLLOUT互斥，不可能一起在revents出现</li>
<li>POLLIN：数据优先读取，非阻塞的读取</li>
<li>POLLNVAL：文件描述符未打开，对这个文件做操作的话，是一个非法的val</li>
<li>POLLOUT：正常的数据可以无阻塞的出去</li>
<li>POLLPRI：读取紧急数据</li>
<li>POLLRDBAND：无阻塞的读取高优先级数据</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回<code>ready</code>的文件描述符数量</li>
<li>-1：出现错误</li>
<li>0：超时</li>
</ul>
</li>
</ul>
<h2 id="epoll（面试重点）"><a href="#epoll（面试重点）" class="headerlink" title="epoll（面试重点）"></a>epoll（面试重点）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>与poll类似，检查文件描述符的集合里面有哪些是已经<code>ready</code>准备进行IO操作的</p>
</li>
<li><p>下面的系统调用被用来提供创建和管理epoll实例：</p>
<ul>
<li><p>epoll_create：创建一个新的epoll实例，并返回一个文件描述符，该文件描述符关联到创建的新实例</p>
</li>
<li><p>epoll_ctl：感兴趣的事件将通过它来注册到创建的实例中</p>
<blockquote>
<p>epoll实例本质上是一个文件。</p>
</blockquote>
</li>
<li><p>epoll_wait： 等待一个IO事件变成<code>ready</code>，如果没有则是会处于阻塞状态</p>
</li>
</ul>
</li>
<li><p>Level-triggered 、edge-triggered：水平模式与边缘模式</p>
<ul>
<li><p>epoll事件分发的接口可以在边缘模式与水平模式进行分发，两者的区别如下（假设设想的情况发生）：</p>
<ul>
<li>管道读取数据的一段被注册到epoll实例中</li>
<li>管道的另一端会把2kb的数据写到管道中</li>
<li>一个epoll_wait完成，同时将会返回管道读数据端（rfd）作为一个<code>ready</code>文件描述符</li>
<li> 管道的读端会从<code>rfd</code>中读走1kb文件</li>
<li>一个epoll_wait完成</li>
</ul>
</li>
<li><p>边缘模式：类似向水中投石子。向管道中写入2kb文件，数据到了读端，触发了一次事件，管道读端会读取1kb文件，不会完全读完，而这剩余的1kb文件不会重新从管道写端到达读端，所以，这1kb文件就已经没法读取出来，只能一直阻塞着</p>
</li>
<li><p>水平模式：不管来了几波数据，只要管道里有数据就读取，直到没有数据 </p>
<blockquote>
<p>水平模式比较可靠，但是边缘模式也有用武之地，因为有些时候不想对某些行为响应两次，比如，按照正常逻辑，一次读取就应该把数据都读完，如果没读完，说明该数据有问题，所以无需响应两次。所以，在高并发、响应时间小的情况下，必须使用<code>et边缘模式</code>。如果是为了保证数据的可靠性，可以使用<code>LT模式</code>  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>推荐用法：</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">  <span class="keyword">int</span> listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Code to set up listening socket, &#x27;listen_sock&#x27;,</span></span><br><span class="line"><span class="comment">                (socket(), bind(), listen()) omitted */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//epoll实例，用最新的epoll_create1创建实例</span></span><br><span class="line">  epollfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//感兴趣的事件</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line">  ev.data.fd = listen_sock;</span><br><span class="line">  <span class="comment">//把套接字注册到实例中，监控</span></span><br><span class="line">  <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;epoll_ctl: listen_sock&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//等待epoll中的ready</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">      <span class="comment">//出错</span></span><br><span class="line">      <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">          perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">      &#125;</span><br><span class="line">  	</span><br><span class="line">      <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">          <span class="comment">//监听到新用户来临</span></span><br><span class="line">          <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">              conn_sock = accept(listen_sock, (struct sockaddr *) &amp;addr, &amp;addrlen);</span><br><span class="line">              <span class="keyword">if</span> (conn_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">                  perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">              &#125;</span><br><span class="line">              setnonblocking(conn_sock);</span><br><span class="line">              ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">              ev.data.fd = conn_sock;</span><br><span class="line">              <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                  perror(<span class="string">&quot;epoll_ctl: conn_sock&quot;</span>);</span><br><span class="line">                  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//不等，说明是以前监听的、接受过的用户</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              do_use_fd(events[n].data.fd);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>相比select的提升：从用户态下沉到内核态，从内核态返回用户态，都是在一个空间中，压根不需要任何调度。 同时，对于epoll来说，所管理的文件数量是没有限制的，因为epoll所关注的重点是epoll实例，文件只有一个，即在用户进程中只打开了一个文件，剩下的不会关联到epoll实例中。监控的文件数量增加，也可以及时返回文件，用O(1)的时间复杂度就可以拿出</p>
<blockquote>
<p>怎么用红黑树实现epoll</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">epoll_create, epoll_create1 - open an epoll file descriptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个epoll实例</li>
<li>返回一个文件描述符，所有的后续操作都可以使用</li>
<li>如果返回的文件描述符不需使用了，应该使用close关闭，避免对系统造成负担，系统会在关闭后销毁释放相关的资源</li>
</ul>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">epoll_ctl - control interface <span class="keyword">for</span> an epoll file descriptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对一个epoll文件的控制</li>
<li>合法的op参数：<ul>
<li>EPOLL_CTL_ADD：注册目标文件符到epoll实例，并关联epoll文件与实例</li>
<li>EPOLL_CTL_MOD： 修改对文件符的关注重点</li>
<li>EPOLL_CTL_DEL：从epoll实例中删除目标文件符，此时的event被忽略，或者直接写NULL</li>
</ul>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">epoll_wait, epoll_pwait - wait <span class="keyword">for</span> an I/O event on an epoll file descriptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>有加个p的，说明有个<code>信号掩码</code>，其他都一样</li>
<li>等待事件</li>
</ul>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ul>
<li>修改多进程聊天室，将其改成epoll，实现一个进程就可以多人聊天</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port, epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create(<span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = server_listen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, server_listen, &amp;ev) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_listen) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogIn&gt; : %s login...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                make_nonblock(sockfd);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sockfd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do_use_fd(events[i].data.fd);</span></span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> rsize = <span class="number">0</span>, fd = events[i].data.fd;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                getpeername(fd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> ((rsize = recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogOut&gt; : %s logout...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s \n&quot;</span>, inet_ntoa(client.sin_addr), buff);</span><br><span class="line">                    send(fd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议栈</title>
    <url>/2021/01/19/0034.TCP%E3%80%81IP%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="深入浅出-TCP-IP-协议栈"><a href="#深入浅出-TCP-IP-协议栈" class="headerlink" title="深入浅出 TCP/IP 协议栈"></a>深入浅出 TCP/IP 协议栈</h1><p>TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是<strong>应用层、传输层、网络层和链路层</strong>，每一层都呼叫它的下一层所提供的协议来完成自己的需求。由于我们大部分时间都工作在应用层，下层的事情不用我们操心；其次网络协议体系本身就很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理，通俗一点讲就是，<strong>一个主机的数据要经过哪些过程才能发送到对方的主机上</strong>。 接下来，我们就来探索一下这个过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232913.jpeg" alt="img"></p>
<h3 id="0、物理介质"><a href="#0、物理介质" class="headerlink" title="0、物理介质"></a><strong>0、物理介质</strong></h3><p>物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。</p>
<p>TCP/IP协议栈分为四层，每一层都由特定的协议与对方进行通信，而<strong>协议之间的通信最终都要转化为 0 和 1 的电信号，通过物理介质进行传输才能到达对方的电脑</strong>，因此物理介质是网络通信的基石。</p>
<p>下面我们通过一张图先来大概了解一下TCP/IP协议的基本框架：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232917.png" alt="img"></p>
<p>当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的<strong>首部</strong>，最终在链路层生成<strong>以太网数据包</strong>，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p>
<p>网络通信就好比送快递，商品外面的一层层包裹就是各种协议，协议包含了商品信息、收货地址、收件人、联系方式等，然后还需要配送车、配送站、快递员，商品才能最终到达用户手中。</p>
<p>一般情况下，快递是不能直达的，需要先转发到对应的配送站，然后由配送站再进行派件。</p>
<p>配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 </p>
<p>快递员负责把包裹转发到各个配送站，配送站根据收获地址里的省市区，确认是否需要继续转发到其他配送站，当包裹到达了目标配送站以后，配送站再根据联系方式找到收件人进行派件。 </p>
<p>有了整体概念以后，下面我们详细了解一下各层的分工。</p>
<h3 id="1、链路层"><a href="#1、链路层" class="headerlink" title="1、链路层"></a>1、链路层</h3><p>网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送 0 和 1 是没有意义的，要传输有意义的数据，就需要以字节为单位对 0 和 1 进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为<strong>一帧，</strong> 制定这个规则的协议就是<strong>以太网协议</strong>。一个完整的以太网数据包如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232924.png" alt="img"></p>
<p>整个数据帧由<strong>首部</strong>、<strong>数据</strong>和<strong>尾部</strong>三部分组成，首部固定为14个字节，包含了目标MAC地址、源MAC地址和类型；数据最短为46个字节，最长为1500个字节，如果需要传输的数据很长，就必须分割成多个帧进行发送；尾部固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏。因此，以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方。那么以太网如何来识接收方的身份呢？</p>
<p>以太网规协议定，接入网络的设备都必须安装网络适配器，即<strong>网卡，</strong> 数据包必须是从一块网卡传送到另一块网卡。而<strong>网卡地址</strong>就是数据包的发送地址和接收地址，也就是帧首部所包含的<strong>MAC地址，</strong>MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。MAC地址采用十六进制标识，共6个字节， 前三个字节是厂商编号，后三个字节是网卡流水号，例如 <strong>4C-0F-6E-12-D2-19</strong></p>
<p>有了MAC地址以后，以太网采用<strong>广播</strong>形式，把数据包发给该<strong>子网内</strong>所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的<strong>目标MAC地址</strong>，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。</p>
<p>所以链路层的主要工作就是<strong>对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</strong></p>
<h3 id="2、网络层"><a href="#2、网络层" class="headerlink" title="2、网络层"></a><strong>2、网络层</strong></h3><p>对于上面的过程，有几个细节问题值得我们思考：</p>
<blockquote>
<p>发送者如何知道接收者的MAC地址？</p>
<p>发送者如何知道接收者和自己同属一个子网？</p>
<p>如果接收者和自己不在同一个子网，数据包如何发给对方？</p>
</blockquote>
<p>为了解决这些问题，网络层引入了三个协议，分别是<strong>IP协议</strong>、<strong>ARP协议</strong>、<strong>路由协议。</strong></p>
<h4 id="【1】IP协议"><a href="#【1】IP协议" class="headerlink" title="【1】IP协议"></a>【1】IP协议</h4><p>通过前面的介绍我们知道，MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。</p>
<p>因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的<strong>IP地址。</strong></p>
<p>IP地址目前有两个版本，分别是<strong>IPv4</strong>和<strong>IPv6</strong>，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分法不尽相同，以C类地址<strong>192.168.24.1</strong>为例<strong>，</strong>其中前24位就是网络地址，后8位就是主机地址。因此， <strong>如果两个IP地址在同一个子网内，则网络地址一定相同。</strong>为了判断IP地址中的网络地址，IP协议还引入了<strong>子网掩码，</strong> IP地址和子网掩码通过<strong>按位与</strong>运算后就可以得到网络地址。</p>
<p>由于发送者和接收者的IP地址是已知的(应用层的协议会传入)， 因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。</p>
<h4 id="【2】ARP协议"><a href="#【2】ARP协议" class="headerlink" title="【2】ARP协议"></a>【2】ARP协议</h4><p>即地址解析协议，是根据<strong>IP地址</strong>获取<strong>MAC地址</strong>的一个网络层协议。其工作原理如下：</p>
<p>ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成<strong>以太网数据包，</strong>最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。cmd输入 arp -a 就可以查询本机缓存的ARP数据。</p>
<h4 id="【3】路由协议"><a href="#【3】路由协议" class="headerlink" title="【3】路由协议"></a>【3】路由协议</h4><p>通过ARP协议的工作原理可以发现，<strong>ARP的MAC寻址还是局限在同一个子网中</strong>，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的<strong>网关</strong>进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。</p>
<p>而完成这个路由协议的物理设备就是<strong>路由器，</strong>在错综复杂的网络世界里，路由器扮演者<strong>交通枢纽</strong>的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。</p>
<h4 id="【4】IP数据包"><a href="#【4】IP数据包" class="headerlink" title="【4】IP数据包"></a>【4】IP数据包</h4><p>在网络层被包装的数据包就叫<strong>IP数据包，</strong>IPv4数据包的结构如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232933.png" alt="img"></p>
<p>IP数据包由首部和数据两部分组成，首部长度为20个字节，主要包含了目标IP地址和源IP地址，目标IP地址是网关路由的线索和依据；数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节，而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送。</p>
<p>所以，网络层的主要工作是<strong>定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。</strong></p>
<h3 id="3、传输层"><a href="#3、传输层" class="headerlink" title="3、传输层"></a>3、传输层</h3><p>链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。</p>
<p>因此传输层引入了<strong>UDP协议</strong>来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了<strong>端口</strong>，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP定义的数据包就叫做UDP数据包，结构如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232940.png" alt="img"></p>
<p>UDP数据包由首部和数据两部分组成，首部长度为8个字节，主要包括源端口和目标端口；数据最大为65527个字节，整个数据包的长度最大可达到65535个字节。</p>
<p>UDP协议比较简单，实现容易，但它没有确认机制， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，<strong>TCP协议</strong>就诞生了，TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说<strong>TCP就是有确认机制的UDP协议，</strong>每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。</p>
<p>为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了<strong>三次对话</strong>的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。由于建立过程较为复杂，我们在这里做一个形象的描述：</p>
<blockquote>
<p>主机A：我想发数据给你，可以么？</p>
<p>主机B：可以，你什么时候发？</p>
<p>主机A：我马上发，你接着！</p>
</blockquote>
<p>经过三次对话之后，主机A才会向主机B发送正式数据，而UDP是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发过去了。所以 TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。</p>
<p>TCP 数据包和 UDP 一样，都是由首部和数据两部分组成，唯一不同的是，TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过IP数据包的长度，以确保单个 TCP 数据包不必再分割。</p>
<p>总结一下，传输层的主要工作是<strong>定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性</strong>。</p>
<h3 id="4、应用层"><a href="#4、应用层" class="headerlink" title="4、应用层"></a>4、应用层</h3><p>理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信，其报文格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232945.png" alt="img"></p>
<p>在 Resquest Headers 中，Accept 表示客户端期望接收的数据格式，而 ContentType 则表示客户端发送的数据格式；在 Response Headers 中，ContentType 表示服务端响应的数据格式，这里定义的格式，一般是和 Resquest Headers 中 Accept 定义的格式是一致的。</p>
<p>有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。</p>
<p>所以应用层的主要工作就是<strong>定义数据格式并按照对应的格式解读数据。</strong></p>
<h3 id="5、全流程"><a href="#5、全流程" class="headerlink" title="5、全流程"></a>5、全流程</h3><p>首先我们梳理一下每层模型的职责：</p>
<ul>
<li><strong>链路层</strong>：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；</li>
<li><strong>网络层</strong>：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；</li>
<li><strong>传输层</strong>：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；</li>
<li><strong>应用层</strong>：定义数据格式，并按照对应的格式解读数据。</li>
</ul>
<p>然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是：</p>
<blockquote>
<p>当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。</p>
</blockquote>
<h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>以上内容是对TCP/IP四层模型做了简单的介绍，而实际上每一层模型都有很多协议，每个协议要做的事情也很多，但我们首先得有一个清晰的脉络结构，掌握每一层模型最基本的作用，然后再去丰富细枝末节的东西，也许会更容易理解。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2021/01/20/0035.%20%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><ul>
<li>当两个线程相互等待对方释放资源时，就会发生死锁。</li>
<li>一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。</li>
<li>死锁是很容易发生的，尤其是在系统中出现多个同步监视器的情况下，</li>
<li>比如：主线程保持着 A 对象的锁，等待对 B 对象加锁，而副线程保持着 B对象的锁，等待对 A 对象加锁，两个线程互相等待对方先释放锁，所以就出现了死锁。</li>
</ul>
<h2 id="怎么避免死锁？"><a href="#怎么避免死锁？" class="headerlink" title="怎么避免死锁？"></a>怎么避免死锁？</h2><p>死锁是不应该在程序中出现的，在编写程序时应该尽量避免出现死锁。下面有几种常见的方式用来解决死锁问题：</p>
<ol>
<li>避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。例如上面的死锁程序，主线程要对 A、B 两个对象的 Lock 进行锁定，副线程也要对 A、B 两个对象的 Lock 进行锁定，这就埋下了导致死锁的隐患。</li>
<li>具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序，主线程先对 A 对象的 Lock 加锁，再对 B 对象的 Lock 加锁；而副线程则先对 B 对象的 Lock 加锁，再对 A 对象的 Lock 加锁。这种加锁顺序很容易形成嵌套锁定，进而导致死锁。如果让主线程、副线程按照相同的顺序加锁，就可以避免这个问题。</li>
<li>使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了。</li>
<li>死锁检测。死锁检测是一种依靠算法机制来实现的死锁预防机制，它主要是针对那些不可能实现按序加锁，也不能使用定时锁的场景的。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入URL后发生了什么</title>
    <url>/2021/01/22/0037.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="浏览器输入URL后发生了什么"><a href="#浏览器输入URL后发生了什么" class="headerlink" title="浏览器输入URL后发生了什么"></a>浏览器输入URL后发生了什么</h1><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235911.png" alt="图片描述"></p>
<p>当我们在浏览器输入网址并回车后，一切从这里开始。</p>
<h2 id="一、DNS域名解析"><a href="#一、DNS域名解析" class="headerlink" title="一、DNS域名解析"></a>一、DNS域名解析</h2><p>我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器IP地址这项工作，是由DNS服务器来完成的。</p>
<p>客户端收到你输入的域名地址后，它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235914.png" alt="图片描述"><br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235926.png" alt="图片描述"></p>
<p>浏览器客户端向本地DNS服务器发送一个含有域名<a href="http://www.cnblogs.com的dns查询报文.本地dns服务器把查询报文转发到根dns服务器,根dns服务器注意到其com后缀,于是向本地dns服务器返回comdns服务器的ip地址.本地dns服务器再次向comdns服务器发送查询请求,comdns服务器注意到其www.cnblogs.com后缀并用负责该域名的权威dns服务器的ip地址作为回应.最后,本地dns服务器将含有www.cnblogs.com的ip地址的响应报文发送给客户端./">www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端。</a></p>
<p>从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。</p>
<p>正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。</p>
<h2 id="二、建立TCP链接"><a href="#二、建立TCP链接" class="headerlink" title="二、建立TCP链接"></a>二、建立TCP链接</h2><p>费了一顿周折终于拿到服务器IP了，下一步自然就是链接到该服务器。对于客户端与服务器的TCP链接，必然要说的就是『三次握手』。<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235936.png" alt="图片描述"></p>
<p>三次握手</p>
<p>客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。</p>
<p>上图也可以这么理解：</p>
<p>客户端：“你好，在家不，有你快递。”</p>
<p>服务端：“在的，送来就行。”</p>
<p>客户端：“好嘞。”</p>
<h2 id="三、发送HTTP请求"><a href="#三、发送HTTP请求" class="headerlink" title="三、发送HTTP请求"></a>三、发送HTTP请求</h2><p>与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235942.png" alt="图片描述"></p>
<p>在浏览器中查看报文首部（以google浏览器为例）：<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330235947.png" alt="图片描述"></p>
<p>请求行包括请求方法、URI、HTTP版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。</p>
<h2 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h2><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210331000017.png" alt="图片描述"></p>
<p>服务器处理请求</p>
<h2 id="五、返回响应结果"><a href="#五、返回响应结果" class="headerlink" title="五、返回响应结果"></a>五、返回响应结果</h2><p>在HTTP里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210331000142.png" alt="图片描述"></p>
<p>在响应结果中都会有个一个HTTP状态码，比如我们熟知的200、301、404、500等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。</p>
<p>状态码由3位数字和原因短语组成。根据首位数字，状态码可以分为五类：<br><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210331000102.png" alt="图片描述"></p>
<h2 id="六、关闭TCP连接"><a href="#六、关闭TCP连接" class="headerlink" title="六、关闭TCP连接"></a>六、关闭TCP连接</h2><p>为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210331000116.png" alt="图片描述"><br>上图可以这么理解：</p>
<p>客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”</p>
<p>服务端：“收到，我看看我这边有木有数据了。”</p>
<p>服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”</p>
<p>客户端：“好嘞。”</p>
<h2 id="七、浏览器解析HTML"><a href="#七、浏览器解析HTML" class="headerlink" title="七、浏览器解析HTML"></a>七、浏览器解析HTML</h2><p>准确地说，浏览器需要加载解析的不仅仅是HTML，还包括CSS、JS。以及还要加载图片、视频等其他媒体资源。</p>
<p>浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</p>
<p>要注意的是，浏览器的解析过程并非是串连进行的，比如在解析CSS的同时，可以继续加载解析HTML，但在解析执行JS脚本时，会停止解析后续HTML，这就会出现阻塞问题，关于JS阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。</p>
<h2 id="八、浏览器布局渲染"><a href="#八、浏览器布局渲染" class="headerlink" title="八、浏览器布局渲染"></a>八、浏览器布局渲染</h2><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p>
<p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。<br>所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p>
<p>最后浏览器绘制各个节点，将页面展示给用户。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>http与https</title>
    <url>/2021/01/21/0036.%20http%E4%B8%8Ehttps/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="http-与-https"><a href="#http-与-https" class="headerlink" title="http 与 https"></a>http 与 https</h1><p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<h2 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a><strong>一、HTTP和HTTPS的基本概念</strong></h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h2 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a><strong>二、HTTP与HTTPS有什么区别？</strong></h2><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p>
<p>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h2 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a><strong>三、HTTPS的工作原理</strong></h2><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p>
<p><strong>1、客户端发起HTTPS请求</strong></p>
<p>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</p>
<p><strong>2、服务端的配置</strong></p>
<p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。</p>
<p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>
<p><strong>3、传送证书</strong></p>
<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>
<p><strong>4、客户端解析证书</strong></p>
<p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<p><strong>5、传送加密信息</strong></p>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p><strong>6、服务段解密信息</strong></p>
<p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p><strong>7、传输加密后的信息</strong></p>
<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<p><strong>8、客户端解密信息</strong></p>
<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>
<h2 id="四、HTTPS的优点"><a href="#四、HTTPS的优点" class="headerlink" title="四、HTTPS的优点"></a><strong>四、HTTPS的优点</strong></h2><p>正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，从站长的角度来说，HTTPS的优点有以下2点：</p>
<p><strong>1、SEO方面</strong></p>
<p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<p><strong>2、安全性</strong></p>
<p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<p>（1）、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>（2）、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>（3）、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<h2 id="五、HTTPS的缺点"><a href="#五、HTTPS的缺点" class="headerlink" title="五、HTTPS的缺点"></a><strong>五、HTTPS的缺点</strong></h2><p>虽然说HTTPS有很大的优势，但其相对来说，还是有些不足之处的，具体来说，有以下2点：</p>
<p><strong>1、SEO方面</strong></p>
<p>据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。</p>
<p>而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p>
<p>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<p><strong>2、经济方面</strong></p>
<p>（1）、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>（2）、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。</p>
<p>（3）、HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。</p>
<p>（4）、HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。</p>
<p>（5）、HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从C到C++</title>
    <url>/2021/02/01/0038.%E4%BB%8E%20C%20%E5%88%B0%20C++/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="从-C-到-C-（C-11）"><a href="#从-C-到-C-（C-11）" class="headerlink" title="从 C 到 C++（C++11）"></a>从 C 到 C++（C++11）</h1><h2 id="c的超集"><a href="#c的超集" class="headerlink" title="c的超集"></a>c的超集</h2><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111521.png" alt="image-20210228082000069"></p>
<ul>
<li><p>C++继承了C语言大部分的语法规则与关键字</p>
</li>
<li><p>头文件（总共130个）：</p>
<ul>
<li><p>标准：cppreference.com 里面 C 的header 中就是29个头文件，就是标准头文件</p>
</li>
<li><p>非标准：特定环境下才有的头文件，比如win有，linux没有这种</p>
<blockquote>
<p>工程开发时，是标准头文件+非标准头文件混合开发的场景</p>
</blockquote>
</li>
</ul>
</li>
<li><p>STL：sort，map等现成的数据结构与算法</p>
</li>
<li><p>异常处理：因为数据某些特殊情况，导致程序运行失败（比如空指针），这个机制可以挽回一部分这些运行失败的情况</p>
</li>
<li><p>C++语言联邦：</p>
<ul>
<li><p>C语言（面向过程）</p>
</li>
<li><p>类和对象（面向对象）</p>
</li>
<li><p>模板（泛型编程）</p>
</li>
<li><p>Lambda（函数式编程）</p>
<blockquote>
<p>很多时候，可能只用到面向过程与对象两种编程范式，学习其他编程范式，其实是为了提高效率，有时其他的编程范式会更有效率。</p>
<p>效率包括写代码、维护、找bug</p>
</blockquote>
</li>
</ul>
</li>
<li><p>编程范式：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111527.png" alt="image-20210228084115129"></li>
</ul>
</li>
</ul>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111533.png" alt="image-20210228090443465"></p>
<ul>
<li>存放任意数据类型（data_type）</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111538.png" alt="image-20210228090149781"></p>
<h3 id="deque：双端队列"><a href="#deque：双端队列" class="headerlink" title="deque：双端队列"></a>deque：双端队列</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111543.png" alt="image-20210228090610177"></p>
<ul>
<li>可以用来模拟：<ul>
<li>单调队列（尾部出入，头部出）</li>
</ul>
</li>
</ul>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111550.png" alt="image-20210228090807931"></p>
<ul>
<li>重载了很多运算符</li>
<li>substr：截取字符串</li>
</ul>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111556.png" alt="image-20210228090938672"></p>
<ul>
<li>提供了非排序的映射表，底层是哈希表</li>
<li>map是排序的映射表，底层是红黑树</li>
</ul>
<h2 id="读书分享（Efective-C-第三版）"><a href="#读书分享（Efective-C-第三版）" class="headerlink" title="读书分享（Efective C++ 第三版）"></a>读书分享（Efective C++ 第三版）</h2><h3 id="条款01：视-C-为一个语言联邦（学习C-的方法）"><a href="#条款01：视-C-为一个语言联邦（学习C-的方法）" class="headerlink" title="条款01：视 C++ 为一个语言联邦（学习C++的方法）"></a>条款01：视 C++ 为一个语言联邦（学习C++的方法）</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111601.png" alt="image-20210228092151692"></p>
<ul>
<li><p>泛型编程、元编程：模板</p>
<ul>
<li>元编程：模板元编程，STL</li>
</ul>
</li>
<li><p>C语言</p>
</li>
<li><p>类和对象</p>
</li>
<li><p>lambda</p>
</li>
</ul>
<h3 id="条款02：尽量以-const-enum-inline-替换-define"><a href="#条款02：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02：尽量以 const/enum/inline 替换 #define"></a>条款02：尽量以 const/enum/inline 替换 #define</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111608.png" alt="image-20210228092627183"></p>
<ul>
<li>C++ 出bug的时候，需要用到调试工具，而调试工具对<code>编译器</code>具有强烈的依赖性（g++  -g），而宏是在预编译阶段，在调试bug的时候，对于宏，很难定位到错误之处，所以需要把 define 替换成编译器可见的元素，方便后续调试</li>
</ul>
<h3 id="条款03：尽可能使用-const"><a href="#条款03：尽可能使用-const" class="headerlink" title="条款03：尽可能使用 const"></a>条款03：尽可能使用 const</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111614.png" alt="image-20210228095015134"></p>
<ul>
<li><p>数据意义上的 const ：</p>
<ul>
<li><p> 数据本身不可以修改，一修改，编译器就报错，如下例，a = 1，就是数据意义上的 const </p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111619.png" alt="image-20210228095552201"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111625.png" alt="image-20210228095630270"></p>
</li>
<li><p>真正数据意义上的 const 很难实现，因为涉及到了指针，比如指针指向的内容不能改变，但是我们可以通过其他方式改变指针指向的内容。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111630.png" alt="image-20210228100359239"></p>
</li>
<li><p>当成员方法用 <code>const</code>修饰之后，表示这个成员方法内部不修改任何成员属性；</p>
</li>
<li><p>当声明一个对象 a 为 <code>const</code>时，即<code>当前对象内部的任何属性都不能修改</code>，所以，只能调用 <code>say1</code>，而<code>say2</code>因为是<code>非const</code>类型方法，其内部<code>可能</code>会修改对象成员属性的值，所以不能调用，即有任何一丝可能修改的可能都不行。</p>
<blockquote>
<ul>
<li>const 类型，可以读取，但不能修改。</li>
<li>非 const 类型，可以修改。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111636.png" alt="image-20210228101145175"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>逻辑意义上的 const ：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111641.png" alt="image-20210228101533429"></li>
<li>用一个 y 值统计 say1 调用的次数，逻辑上合理，但程序上不合理，所以需要给 int y 前面加一个 mutable 即可，这种在 const 方法里面修改成员变量的，就是逻辑上的 const，就是逻辑上没有改动，实际上是已经改动了的，但<code>不影响程序</code>，只要<code>关键变量</code>没变，其他<code>附属变量</code>改变了也可以在逻辑上当成没有改变</li>
</ul>
</li>
</ul>
<h3 id="条款04：确定对象被使用前已经先被初始化"><a href="#条款04：确定对象被使用前已经先被初始化" class="headerlink" title="条款04：确定对象被使用前已经先被初始化"></a>条款04：确定对象被使用前已经先被初始化</h3><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111646.png" alt="image-20210228102616889"></p>
<ul>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111652.png" alt="image-20210228102854661"></p>
</li>
<li><p>在 C++ 中，构造跟赋值是两个概念，构造函数就是负责对象初始化，而赋值不是负责初始化，所以逻辑上、本质上就有区别了。</p>
</li>
<li><p>先声明的先初始化，避免出现逻辑上的BUG ，比如下面</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111657.png" alt="image-20210228103420380"></li>
<li>逻辑上没有任何问题，但实际上，无论怎么写，都会先初始化 x，再初始化 y，所以这个程序一运行，x 的值就是奇奇怪怪的值。</li>
</ul>
</li>
<li><p>跨编译单元之初始化次序：比如 A 文件中有个静态变量 a，B 文件中有个静态变量 b，如果 b 是依赖 a 来初始化的，则如果不能保证 a 先初始化的话，b 可能会出错，应该把 a 移到 B 文件中，尽量避免跨文件的初始化依赖关系。 </p>
</li>
</ul>
<h2 id="C-STL-刷题"><a href="#C-STL-刷题" class="headerlink" title="C++  STL 刷题"></a>C++  STL 刷题</h2><h3 id="HZOJ256"><a href="#HZOJ256" class="headerlink" title="HZOJ256"></a>HZOJ256</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><p><code>微扰</code>算法思想 </p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306111704.png" alt="image-20210228163503783"></p>
</li>
<li><p>金币数量$ C_i = A_{i - 1} / b_i $</p>
</li>
<li><p>假设$ C_i $最多，当与$ C_{i - 1} $的位置交换之后，$ C_i $得到的金币数量为$ C_i’ $，$ C_{i - 1} $得到的金币数量为$ C_{i - 1} ‘ $，如果满足$ C_i  &gt; C_i’ ，C_i  &gt; C_{i - 1}’$的话，则新排列的所有值都小于$ C_i $</p>
</li>
<li><p>$ C_i’ = A_{i - 2} / b_i $</p>
</li>
<li><p>$ C_{i - 1}’ = A_{i - 2} / b_{i - 1} $</p>
</li>
<li><p>因为没有小数，所以$ C_i &gt; C_i’ $</p>
</li>
<li><p>所以只需求 $ C_i &gt; C_{i - 1}’ $，即$ C_{i - 1}’ = A_{i - 2} / b_{i - 1} &lt; A_{i - 2} * a_i/ b_i $，即$ a_i * b_i &lt; a_{i - 1} * b {i - 1}$</p>
</li>
<li><p>即只要当前左右两个数的乘积小于前一个人左右两个数的乘积，两个人的位置交换，这就是排序依据  </p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类和对象——继承</title>
    <url>/2021/02/03/0040.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="类和对象——继承"><a href="#类和对象——继承" class="headerlink" title="类和对象——继承"></a>类和对象——继承</h1><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200241.png" alt="image-20210306183818907" style="zoom:50%;">

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200247.png" alt="image-20210306183938567" style="zoom:50%;"></li>
<li><p>cat ：子类/派生类</p>
</li>
<li><p>Animal ：父类/基类</p>
</li>
<li><p>继承语法： 子类：父类</p>
</li>
<li><p>关键点：</p>
<ul>
<li>继承父类的<strong>所有属性与方法</strong>（涉及到访问控制权限）</li>
<li>拥有不代表能访问：<ul>
<li>cat类肯定也有__name，但是能访问吗？并不能</li>
</ul>
</li>
</ul>
</li>
<li><p>父类前面的权限是继承权限（如public ： Animal 的public）</p>
</li>
</ul>
<h2 id="子类的访问权限"><a href="#子类的访问权限" class="headerlink" title="子类的访问权限"></a>子类的访问权限</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200252.png" alt="image-20210306184435065" style="zoom:50%;">

<ul>
<li><p>继承权限不影响子类对父类内容的访问权限</p>
<ul>
<li><p>子类是父类的类外部，所以子类只能访问父类的public 与 protected（受保护的），私有权限private 访问不了（无论什么权限）。</p>
<blockquote>
<p>protected ：只有子类或友元函数可以访问，其他类外部是不能访问的</p>
<p>private：虽然无论继承什么权限都不能访问父类的私有属性，但如果把子类声明为父类的友元类型（friend class Son），则可以访问。（儿子变隔壁老王。）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200257.png" alt="image-20210306184908985" style="zoom:50%;">

<ul>
<li><p>外部想访问一个类的属性，先查看继承权限，如果继承权限有，则再看该属性在类的权限</p>
</li>
<li><p>继承权限影响类外部访问一个子类内部继承自父类属性的访问权限。</p>
<ul>
<li>多了protected的话：父类的public权限会降级变为protected</li>
<li>即取两个权限的最小值</li>
</ul>
</li>
<li><p>上表：</p>
<ul>
<li>第一行：继承权限</li>
<li>第一列：属性在基类中的权限</li>
</ul>
</li>
<li><p>子类地址<strong>可以隐式转为</strong>父类地址：</p>
<ul>
<li><p>前提：必须<strong>公有继承</strong>父类</p>
<blockquote>
<p>如果是私有继承，从逻辑上来说，就是子类的内容，外部无法访问，而转为父类地址之后，就可能造成子类的内容可以被访问了，这样的话，子类私有继承的目的就不复存在了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>子类Cat 继承了 父类 Animal 的所有属性跟方法，即子类Cat 继承了Animal 之后，如果里面不写任何内容，则Cat的属性跟方法都跟Animal一样，同时，子类有一块存储区域存储着父类的数据。</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">string</span> name = <span class="string">&quot;tom&quot;</span>) : name(name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal(<span class="keyword">const</span> Animal &amp;a) : name(a.name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal &amp;a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = a.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rename</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Animal() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat() : Animal(<span class="string">&quot;Cat MIMI&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat(<span class="keyword">const</span> Cat &amp;c) : Animal(c) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Cat &amp;c) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Animal::<span class="keyword">operator</span>=(c); <span class="comment">// 显示性调用父类赋值运算符（也是拷贝）</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;miaomiaomiao, my name isv&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Cat() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> :</span> <span class="keyword">public</span> Cat &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;huhuhu, my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Animal) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Cat) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Cat c;</span><br><span class="line">    Cat a = c;</span><br><span class="line">    c.say1();</span><br><span class="line">    Animal *p = &amp;c;</span><br><span class="line">    p-&gt;say();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="继承——构造函数"><a href="#继承——构造函数" class="headerlink" title="继承——构造函数"></a>继承——构造函数</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200303.png" alt="image-20210306190305856" style="zoom:50%;">

<ul>
<li><strong>子类有一部分数据区属于父类</strong>，所以构造子类时，需要对父类的数据区一同构造，同时是<strong>先构造父类</strong>，再构造子类</li>
<li>构造流程：先调用子类的父类数据区，从而调用父类的构造函数，接着再调用子类的构造函数</li>
<li>构造与析构顺序：先构造父类再构造子类，先析构子类再析构父类</li>
</ul>
<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200315.png" alt="image-20210306193409200" style="zoom:50%;">

<ul>
<li>A类派生出B类与C类</li>
<li>D类同时继承了B类与C类</li>
<li>问题：如果B类跟C类有同个成员方法，D类调用该方法时，不能确定是调用B类还是C类的方法，这是未定义的。</li>
</ul>
<h3 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h3><ul>
<li>构造与析构顺序</li>
<li>菱形继承</li>
<li>B类有获取数据的方法，C类有修改数据的方法，D类继承B类与C类<ul>
<li>D类对象d先获取数据，再修改数据，再获取数据</li>
<li>理论上D的两次获取数据应该不一样了，但是！还是一样！！</li>
<li>原因：B类有A类的数据区，C类也有A类的数据区，即D类继承了两个A类的数据区，所以改了C类的数据区，对B类数据区没有影响</li>
</ul>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">string</span> name = <span class="string">&quot;tom&quot;</span>) : name(name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal(<span class="keyword">const</span> Animal &amp;a) : name(a.name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal &amp;a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = a.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rename</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Animal() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat() : Animal(<span class="string">&quot;Cat MIMI&quot;</span>) &#123; <span class="comment">// 显示调用父类构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat(<span class="keyword">const</span> Cat &amp;c) : Animal(c) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Cat &amp;c) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Animal::<span class="keyword">operator</span>=(c); <span class="comment">// 显示性调用父类赋值运算符（也是拷贝）</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;miaomiaomiao&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Cat() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : x(<span class="number">123</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Father(<span class="keyword">const</span> Father &amp;f) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 虽然是私有继承，但是拷贝操作并不影响，只是无法调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">private</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son(<span class="keyword">const</span> Son &amp;s) : Father(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Animal) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Cat) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Cat c;</span><br><span class="line">    Cat a = c;</span><br><span class="line">    c.say1();</span><br><span class="line">    Animal *p = &amp;c;</span><br><span class="line">    p-&gt;say();</span><br><span class="line"></span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get X : &quot;</span> &lt;&lt; d.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    d.setX(<span class="number">12345</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get X : &quot;</span> &lt;&lt; d.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="基类与派生类的构造顺序"><a href="#基类与派生类的构造顺序" class="headerlink" title="基类与派生类的构造顺序"></a>基类与派生类的构造顺序</h2><ul>
<li>一定要先有<strong>爸爸</strong>，再有<strong>儿子</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200320.png" alt="image-20210306201015676" style="zoom:50%;">

<h2 id="继承——拷贝-amp-赋值"><a href="#继承——拷贝-amp-赋值" class="headerlink" title="继承——拷贝&amp;赋值"></a>继承——拷贝&amp;赋值</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309200400.png" alt="image-20210306203531655" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309215819.png" alt="image-20210309215814414" style="zoom: 50%;">

<ul>
<li>如果<strong>不显示调用父类的构造函数</strong>，则只有属于<strong>子类的数据区</strong>完成了<strong>正确的拷贝行为</strong>，而<strong>父类的数据区</strong>并<strong>没有正确拷贝</strong><ul>
<li>解决：需要显示调用父类的拷贝构造函数</li>
</ul>
</li>
<li>代码演示在上方</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>要么不要多继承，如果非要多继承，就一个真实基类，多个功能性基类</p>
<ul>
<li><p>一个真实基类</p>
<ul>
<li>比如Animal，有自己的方法与属性</li>
</ul>
</li>
<li><p>多个功能性基类</p>
<ul>
<li>为了完成某些功能而设计的基类</li>
</ul>
</li>
<li><p>假设要设置A、B、C类均不能被拷贝，可以如下设置：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309220557.png" alt="image-20210309220236790" style="zoom:50%;">
</li>
<li><p>功能上没任何问题，但是设计上很不好，如果类的数目少还可以，但是如果类多呢？所以，可以设置一个<strong>功能性类</strong>，该<strong>功能性类是父类</strong>，设置为<strong>不允许被拷贝</strong>。</p>
<blockquote>
<p><strong>父类不允许被拷贝，则子类也不允许被拷贝</strong></p>
</blockquote>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309220547.png" alt="image-20210309220542483" style="zoom:50%;">
</li>
</ul>
</li>
<li><p>virtual：虚继承，表明一种继承关系</p>
<ul>
<li>如果B虚继承A，C虚继承A，则系统会把两个A合并成同一个A</li>
</ul>
</li>
</ul>
<h3 id="最终代码演示："><a href="#最终代码演示：" class="headerlink" title="最终代码演示："></a>最终代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">string</span> name = <span class="string">&quot;tom&quot;</span>) : name(name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal(<span class="keyword">const</span> Animal &amp;a) : name(a.name) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Animal &amp;a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = a.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rename</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Animal() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat() : Animal(<span class="string">&quot;Cat MIMI&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat(<span class="keyword">const</span> Cat &amp;c) : Animal(c) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cat &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Cat &amp;c) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Animal::<span class="keyword">operator</span>=(c); <span class="comment">// 显示性调用父类赋值运算符（也是拷贝）</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;miaomiaomiao&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Cat() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Tiger : public Cat &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void say2() &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;huhuhu, my name is &quot; &lt;&lt; name &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : x(<span class="number">123</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;   <span class="comment">//虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;    <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Father(<span class="keyword">const</span> Father &amp;f) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">private</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son(<span class="keyword">const</span> Son &amp;s) : Father(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Animal) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(Cat) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Cat c;</span><br><span class="line">    Cat a = c;</span><br><span class="line">    c.say1();</span><br><span class="line">    Animal *p = &amp;c;</span><br><span class="line">    p-&gt;say();</span><br><span class="line"></span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get X : &quot;</span> &lt;&lt; d.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    d.setX(<span class="number">12345</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;get X : &quot;</span> &lt;&lt; d.getX() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎大家来到我的博客</title>
    <url>/2021/01/01/hello/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center>欢迎大家来到 Alin's Blog，与 Alin 一起记录自己的学习与生活！</center>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>C语言测试框架</title>
    <url>/2021/01/01/0001.%20%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="函数的声明与定义"><a href="#函数的声明与定义" class="headerlink" title="函数的声明与定义"></a>函数的声明与定义</h2><ul>
<li>声明：告诉系统有这个东西</li>
<li>定义：实现方式</li>
<li>函数未声明和未定义暴露在<strong>两个时期</strong><ul>
<li>函数未声明错误——<code>编译</code>过程（语法检查）<ul>
<li><em>g++ -c \</em>.cpp*生成编译后的对象文件</li>
</ul>
</li>
<li>函数未定义错误——<code>链接</code>过程<ul>
<li><em>g++ \</em>.o*链接生成可执行程序</li>
</ul>
</li>
</ul>
</li>
<li>函数声明可以多次，但定义只能一次！</li>
</ul>
<h2 id="头文件与源文件"><a href="#头文件与源文件" class="headerlink" title="头文件与源文件"></a>头文件与源文件</h2><ul>
<li>规范<ul>
<li>头文件放声明，源文件放定义</li>
<li>头文件与对应的源文件名称一致</li>
</ul>
</li>
<li>头文件中条件式编译，可以避免<strong>一次</strong>编译过程中<strong>重复包含头文件</strong>的问题</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEADER1_  <span class="comment">// 名称最好与头文件名对应，虽没有硬性要求</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEADER1_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>              <span class="comment">// 可以没有</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>             <span class="comment">// 必须有  </span></span></span><br></pre></td></tr></table></figure>
<h2 id="工程开发规范与静态链接库"><a href="#工程开发规范与静态链接库" class="headerlink" title="工程开发规范与静态链接库"></a>工程开发规范与静态链接库</h2><ul>
<li><p>#include后的双引号<code>&quot;&quot;</code>改成尖角号<code>&lt;&gt;</code></p>
<ul>
<li>双引号””：从<strong>执行代码所在目录下</strong>搜索</li>
<li>尖角号&lt;&gt;：从<strong>系统库路径</strong>下搜索</li>
<li>使用g++/gcc -I添加头文件路径到系统库路径下</li>
</ul>
</li>
<li><p>向上开发时</p>
<ul>
<li><p>给别人<strong>头文件</strong>(include文件夹)、源文件对应的<strong>对象文件的包</strong>(lib文件夹)即可</p>
</li>
<li><p>对象文件打包</p>
<ul>
<li><p>静态链接库（.a）</p>
</li>
<li><p>```c++<br>// 打包<br>ar -r lib<strong>xxx</strong>.a header1.o header2.o header3.o<br>// 链接 g++ *.o -L -l<br>g++ test.o -L./lib -l<strong>xxx</strong><br><strong>// xxx对应</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 动态链接库（.so）</span><br><span class="line"></span><br><span class="line">    - 两者实现的功能一致，都是打包</span><br><span class="line"></span><br><span class="line">    - [静态库与动态库的区别](https:&#x2F;&#x2F;www.nowcoder.com&#x2F;questionTerminal&#x2F;d16d0fe0e49448f5a24d10de08b27d53)</span><br><span class="line"></span><br><span class="line">## makefile工具</span><br><span class="line"></span><br><span class="line">- 封装编译流程，减小程序开发时编译的复杂度</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;juTPX1lFMtcgA64.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;juTPX1lFMtcgA64.png)</span><br><span class="line">  - .PHONY开一个&#96;虚拟的环境&#96;，避免使用&#96;make clean&#96;时与路径中存在的clean文件&#96;冲突&#96;</span><br><span class="line">  - 可以有封装变量替换操作</span><br><span class="line"></span><br><span class="line">## 初识谷歌测试框架</span><br><span class="line"></span><br><span class="line">- 单元测试</span><br><span class="line">  - 又称模块测试，是对程序模块（软件设计的最小单位）来进行&#96;正确性检验&#96;的测试工作</span><br><span class="line">    - 在过程化编程中，&#96;一个单元就是单个程序、函数、过程等&#96;</span><br><span class="line">  - 框架跟着语言走：C++、Python、Java...</span><br><span class="line">- C++实现的</span><br><span class="line">- cmake工具</span><br><span class="line">  - 可根据本机的**环境**生成makefile文件</span><br><span class="line">  - makefile对环境的要求很强，所以不直接使用</span><br><span class="line">  - 谷歌测试框架先cmake再make即可完成编译，注意打包库的位置</span><br><span class="line">- **代码（main.cpp）**</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;FfdEBxbuHphLRjs.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;FfdEBxbuHphLRjs.png)</span><br><span class="line">  - 用的尖括号&lt;&gt;包含的gtest.h头文件</span><br><span class="line">  - add2只是一个标识</span><br><span class="line">  - 断言：</span><br><span class="line">    - 用来捕捉程序员自己的错误，假设某情况发生，如果没发生则作相应处理，</span><br><span class="line">    - ASSERT_*版本的断言失败时会产生致命失败，并结束当前函数</span><br><span class="line">    - EXPECT_*版本的断言产生非致命失败，而不会中止当前函数</span><br><span class="line">- makefile</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;EXMxZaJQHUYORDP.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;EXMxZaJQHUYORDP.png)</span><br><span class="line">  - 可以用 -std&#x3D;xxx 指定C++版标准，本机其实不需要指定</span><br><span class="line">  - 需要使用-I 添加头文件路径.&#x2F;lib</span><br><span class="line">  - 使用&#96;-lpthread&#96;额外连接&#96;pthread库&#96;，mac系统会自动连接</span><br><span class="line">  - 疑问</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;GSgNa9hce4ETYD7.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;GSgNa9hce4ETYD7.png)</span><br><span class="line">    - ①根据编译器支持的不同标准，c++11是比较低的版本了，要向下支持</span><br><span class="line">    - ②可能用了make install之类的操作，将头文件包含到系统库目录里了</span><br><span class="line">- 结果</span><br><span class="line">- [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;xdba3vH19peQz4w.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;xdba3vH19peQz4w.png)</span><br><span class="line"></span><br><span class="line">## 实现自己的C语言测试框架</span><br><span class="line"></span><br><span class="line">|             |                         **TEST**                          |   **EXPECT_EQ**    | **RUN_ALL_TEST** |</span><br><span class="line">| :---------: | :-------------------------------------------------------: | :----------------: | :--------------: |</span><br><span class="line">|  **功能**   |                     代表一个测试用例                      | 测试用例里的测试点 |   运行所有TEST   |</span><br><span class="line">| **宏&#x2F;函数** |                            宏                             |      函数或宏      |     函数或宏     |</span><br><span class="line">| **注意点**  | 没有返回值类型； 与后面的花括号&#123;&#125;组成合法的函数定义的形式 |      一种断言      |    返回值是0     |</span><br><span class="line"></span><br><span class="line">### 版本一：通过编译，显示测试结果</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.h（haizei目录下）</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;aoDr8iP1xgQEl9W.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;aoDr8iP1xgQEl9W.png)</span><br><span class="line">  - 无法使用a##.##b</span><br><span class="line">    - 函数名中只能是下划线、字母和数字，不能有&quot;.&quot;！</span><br><span class="line">  - a##*haizei*##b</span><br><span class="line">    - 使用_haizei_或之类的特殊标识是为了防止a与b直接连接产生函数重名情况</span><br><span class="line">    - 如(test, funcadd)与(testfunc, add)</span><br><span class="line">  - &#96;__attribute__((constructor))&#96;</span><br><span class="line">    - **设置函数属性**，在&#96;函数声明或定义&#96;时使用</span><br><span class="line">    - 让它后面的**第一个函数**在主函数执行前被自动**调用**执行</span><br><span class="line">    - 否则在[main.cpp](https:&#x2F;&#x2F;shimo.im&#x2F;docs&#x2F;NJkbE0p7WzuKm2qR#anchor-FxUW)中执行RUN_ALL_TESTS()后直接结束程序，不会经过TEST</span><br><span class="line">    - 参考[函数属性__attribute__((constructor))和__attribute__((destructor))](https:&#x2F;&#x2F;blog.csdn.net&#x2F;tianmohust&#x2F;article&#x2F;details&#x2F;45310349)</span><br><span class="line"></span><br><span class="line">- ####  haizei&#x2F;test.cc（haizei目录下）</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;sZ1guoldtecF9KQ.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;sZ1guoldtecF9KQ.png)</span><br><span class="line">  - 象征性定义，通过编译验证一下即可</span><br><span class="line"></span><br><span class="line">- #### main.cpp</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;Jq5c4mnb3xldYrC.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;Jq5c4mnb3xldYrC.png)</span><br><span class="line">  - 三组TEST</span><br><span class="line"></span><br><span class="line">- #### makefile</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;lXYmz413Sify67T.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;lXYmz413Sify67T.png)</span><br><span class="line">  - 使用make可以快速编译</span><br><span class="line">  - 注意-o的使用，让对象文件、可执行程序自定义命名放在指定目录下</span><br><span class="line">  - 注意路径中文件所在文件夹的指明</span><br><span class="line"></span><br><span class="line">- 测试结果</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;xgBjvpNUMmYXeGr.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;xgBjvpNUMmYXeGr.png)</span><br><span class="line"></span><br><span class="line">  &gt; 当前，main()函数里return的无论是RUN_ALL_TESTS()还是0都会显示测试结果，应该修改为让RUN_ALL_TESTS()控制显示的输出</span><br><span class="line"></span><br><span class="line">### 版本二：RUN_ALL_TESTS()开关</span><br><span class="line"></span><br><span class="line">- 需记录的点</span><br><span class="line"></span><br><span class="line">  - 有多少组测试用例</span><br><span class="line">  - 测试用例对应的函数名字</span><br><span class="line">  - 测试用例对应的函数</span><br><span class="line">    - 使用函数指针变量</span><br><span class="line">    - 用数组记录函数指针</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.h</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;dQIPSRG3UnvAVKN.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;dQIPSRG3UnvAVKN.png)</span><br><span class="line">  - TEST中，在main函数执行前使用add_function将函数记录到全局变量里</span><br><span class="line">  - typedef的第二种用法：将变量提升为类型</span><br><span class="line">  - **结构体的使用：封装函数指针和函数名**</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.cc</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;l8GjynOH1Udu3Eq.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;l8GjynOH1Udu3Eq.png)</span><br><span class="line"></span><br><span class="line">  - 全局变量的使用</span><br><span class="line"></span><br><span class="line">  - strdup的使用：参考[C语言strdup()函数：复制字符串](http:&#x2F;&#x2F;c.biancheng.net&#x2F;cpp&#x2F;html&#x2F;166.html)</span><br><span class="line"></span><br><span class="line">    &gt; 使用malloc()开辟空间拷贝字符串，最后记得使用free()释放</span><br><span class="line"></span><br><span class="line">  - 已经实现了开关控制，下面可以对显示、断言等进行优化！</span><br><span class="line"></span><br><span class="line">### 版本三：美观优化</span><br><span class="line"></span><br><span class="line">#### 1. 给输出添加颜色</span><br><span class="line"></span><br><span class="line">- [带颜色的printf](http:&#x2F;&#x2F;moilk.org&#x2F;blog&#x2F;2016&#x2F;05&#x2F;21&#x2F;linuc01&#x2F;)</span><br><span class="line">- 将颜色定义&#96;封装成宏&#96;，在头文件&#96;haizei&#x2F;test.h&#96;里定义</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;7LBR3ehnHkozFQG.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;7LBR3ehnHkozFQG.png)</span><br><span class="line">  - 多个字符串之间&#96;用空格即可连接&#96;</span><br><span class="line">  - 注意！颜色控制字符中 &quot;;&quot; 左右&#96;不能有空格&#96;</span><br><span class="line"></span><br><span class="line">#### 2. 添加断言宏</span><br><span class="line"></span><br><span class="line">- 判断不等于、大于、大于等于、小于、小于等于</span><br><span class="line">  - 方案一：对每个宏单独实现</span><br><span class="line">  - 方案二：类似定义颜色宏，把共同的代码再封装一次（掌握#的使用）</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;jJuW2NMDfZlK8L4.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;jJuW2NMDfZlK8L4.png)</span><br><span class="line"></span><br><span class="line">#### 3. 统计每组测试的成功和失败的测试个数</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.h</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;8AZ9gyKpQBefnMj.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;8AZ9gyKpQBefnMj.png)</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;uq4XoiRBfUSHeEZ.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;uq4XoiRBfUSHeEZ.png)</span><br><span class="line"></span><br><span class="line">  - 定义统计的结构体，统一管理，封装性更好</span><br><span class="line"></span><br><span class="line">  - 在断言处进行统计</span><br><span class="line"></span><br><span class="line">  - **这里使用extern声明结构体变量**，因为</span><br><span class="line"></span><br><span class="line">    - 头文件的断言处用到了该变量，需要有该变量的&#96;声明&#96;</span><br><span class="line"></span><br><span class="line">      &gt; int i 既是声明也是定义，extern int i&#96;只是声明&#96;</span><br><span class="line">      &gt; struct FunctionInfo haizei_test_info 既是声明也是定义</span><br><span class="line">      &gt; 只是声明需在前面加&#96;extern&#96;</span><br><span class="line"></span><br><span class="line">    - 但在头文件不能定义变量，否则易导致**重定义**问题</span><br><span class="line">    - 参考[C语言正确使用extern关键字](https:&#x2F;&#x2F;blog.csdn.net&#x2F;xingjiarong&#x2F;article&#x2F;details&#x2F;47656339)</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.cc</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;NjDZQTSgPKqzxhX.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;NjDZQTSgPKqzxhX.png)</span><br><span class="line">  - 定义并声明haizei_test_info变量</span><br><span class="line">  - 1.0提升类型，100.0放前面可能会溢出</span><br><span class="line">  - 100%情况判断：用一个极小值和fabs进行浮点数判等；成功数&#x3D;&#x3D;统计数</span><br><span class="line">  - 居中对齐效果</span><br><span class="line">    - %m.nf：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格</span><br><span class="line">    - %-m.nf：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格</span><br><span class="line"></span><br><span class="line">#### 4.  显示失败测试点的详细信息</span><br><span class="line"></span><br><span class="line">- 主要编写&#96;头文件&#96;中，断言宏中要执行的LOG宏</span><br><span class="line"></span><br><span class="line">- #### haizei&#x2F;test.h</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;NiMb58InopmOdhF.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;NiMb58InopmOdhF.png)</span><br><span class="line">  - actual部分的结果值类型不确定，定义&#96;泛型宏&#96;</span><br><span class="line">    - &#96;_Generic(a, 替换规则)&#96;：根据a的返回类型实现对应的替换</span><br><span class="line">    - _Generic是&#96;C语言中的关键字&#96;，不是宏！在预处理阶段不会替换成对应类型</span><br><span class="line">      - 在与COLOR宏连用时要十分小心！</span><br><span class="line">        - 在编译阶段，字符串与一个不知道是什么的东西(_Generic())无法拼接</span><br><span class="line">      - 不能使用C++编译器</span><br><span class="line">      - 详见下面的**报错一**和报错二</span><br><span class="line">    - 参考[cpp_reference](https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;generic)</span><br><span class="line">  - 使用typeof定义额外变量</span><br><span class="line">    - 所有运算部分通过额外变量，避免**++操作**带来的多次运算</span><br><span class="line">  - 报错一（编译阶段 -c）</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;p9BsgAKfeVnX8PN.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;p9BsgAKfeVnX8PN.png)</span><br><span class="line">    - 对应错误写法：把TYPE(a)写在YELLOW_HL宏里</span><br><span class="line">      - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;kYtVLfRDNnw1cz8.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;kYtVLfRDNnw1cz8.png)</span><br><span class="line">      - 红框②可以正常输出，但是会没有颜色</span><br><span class="line">      - 如果像红框①那样在外层套一个颜色宏，编译会报错</span><br><span class="line">        - 对main.c进行预处理，不会报错</span><br><span class="line">        - 查看上面红框②预处理后的代码，如下</span><br><span class="line">        - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;kGfo3P961mvRBEb.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;kGfo3P961mvRBEb.png)</span><br><span class="line">        - </span><br><span class="line">      - 原因：对于宏替换后的代码，(&quot;字符串&quot; _Generic() &quot;字符串&quot;)在编译时报错，连接不上，因为编译器此时并不知道_Generic()是啥</span><br><span class="line">        - _Generic()需要在&#96;运行时才能知道结果&#96;，语法检查时字符串和莫名的东西连接，所以报错</span><br><span class="line">        - 和printf()的原型的第一个输入参数类型为const char*没有很大关系，但是&#96;类型不匹配&#96;会报警告</span><br><span class="line">        - 看下面这个简单的例子也许就明白了：</span><br><span class="line">          - 头文件</span><br><span class="line">            - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;3xyWdCbtIAJu9gU.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;3xyWdCbtIAJu9gU.png)</span><br><span class="line">          - 源文件</span><br><span class="line">            - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;fGmUD6EAiClzJ7I.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;fGmUD6EAiClzJ7I.png)</span><br><span class="line">          - 编译</span><br><span class="line">            - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;RKu9fZnG4gxaF7J.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;RKu9fZnG4gxaF7J.png)</span><br><span class="line">          - 同样的报错</span><br><span class="line">          - 因为在编译检查语法阶段，编译器不知道s是个啥，和字符串&quot;a&quot;连接就会出错</span><br><span class="line">          - 报错提示的是想让你把s踢出去，直接在s前面加括号</span><br><span class="line">    - 所以通过**sprintf**()将_Generic()包装起来的方式很巧妙，在编译阶段没有问题，在运行阶段有值了自然也正常</span><br><span class="line">  - 报错二（编译阶段 -c）</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;JEZbioezlvIsP2F.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;JEZbioezlvIsP2F.png)</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;yngQlcpfmjswK2I.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;yngQlcpfmjswK2I.png)</span><br><span class="line">    - 关键信息在第二张图的error</span><br><span class="line">    - _Generic只支持C语言（C11），不支持C++</span><br><span class="line">    - 参考[如何启用_Generic关键字](https:&#x2F;&#x2F;www.thinbug.com&#x2F;q&#x2F;28253867)</span><br><span class="line">    - 将所有文件后缀改为C语言的</span><br><span class="line">      - main.cpp → main.c；test.cc→test.c</span><br><span class="line"></span><br><span class="line">- #### main.c</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;52gp9lAJOBMSEvx.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;52gp9lAJOBMSEvx.png)</span><br><span class="line">  - 测试double类型数据，验证泛型宏作用</span><br><span class="line">    - 修改了函数的参数类型为double</span><br><span class="line">    - double判等不能直接用&#x3D;&#x3D;，在头文件里要判等方式，用&#96;差值与极小值&#96;</span><br><span class="line"></span><br><span class="line">- #### makefile</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;eZPRaXN3FIifpys.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;eZPRaXN3FIifpys.png)</span><br><span class="line"></span><br><span class="line">- #### 输出</span><br><span class="line"></span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;4bIZkDOvGHLazpt.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;4bIZkDOvGHLazpt.png)</span><br><span class="line"></span><br><span class="line">#### 5. 存储函数的全局变量没有测试用例数量限制</span><br><span class="line"></span><br><span class="line">- 静态数组：在运行之前就开辟好了固定的空间大小，且存储的物理空间连续</span><br><span class="line"></span><br><span class="line">- 链表：思维上是顺序的，但在物理存储上不需要顺序</span><br><span class="line"></span><br><span class="line">  - 由节点组成，包含：数据域、指针域</span><br><span class="line">  - 占用空间动态变化</span><br><span class="line">  - 但是更厉害是的是下面的方式：可以给&#96;任何结构体安上链表的外骨骼&#96;</span><br><span class="line"></span><br><span class="line">- 链表外骨骼</span><br><span class="line"></span><br><span class="line">  - #### haizei&#x2F;test.h</span><br><span class="line"></span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;LK8kImz95rCPQOv.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;LK8kImz95rCPQOv.png)</span><br><span class="line">    - 直接在一个结构体中添加节点结构体变量node，即链表结构的外骨骼</span><br><span class="line">    - node记录下一个节点（下一个TEST的node）的地址</span><br><span class="line">    - 包含链表节点的头文件&#96;haizei&#x2F;linklist.h&#96;</span><br><span class="line"></span><br><span class="line">  - #### haizei&#x2F;linklist.h</span><br><span class="line"></span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;ucTPZQ6mIhn31S4.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;ucTPZQ6mIhn31S4.png)</span><br><span class="line">    - next指向下一个节点的地址</span><br><span class="line">      - 但实际是想访问下一个TEST的func和str字段</span><br><span class="line">      - 可以通过**访问下一个结构体的首地址再间接访问两个字段**来完成</span><br><span class="line">    - 如何得到一个结构体的首地址</span><br><span class="line">      - 通过指针p对应字段name在结构体T中的偏移量来计算</span><br><span class="line">      - offset宏</span><br><span class="line">        - 用空指针得到name字段所在的地址</span><br><span class="line">          - (T *)(NULL)-&gt;name得到的是name变量</span><br><span class="line">          - &amp;得到的是T *类型指针，存的是地址</span><br><span class="line">        - 转long long整型即可得到偏移量</span><br><span class="line">          - **long** long类型会根据系统位数改变其范围，对应指针大小</span><br><span class="line">      - Head宏</span><br><span class="line">        - 将p指针的地址转成**char ***类型</span><br><span class="line">        - 这样±1是按照最小单位1字节来偏移的</span><br><span class="line">        - p是一个指针，name是指针p在结构体T中对应的字段名</span><br><span class="line"></span><br><span class="line">  - #### haizei&#x2F;test.c</span><br><span class="line"></span><br><span class="line">    - ![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;AJWhNZCcqfDGtxi.png)</span><br><span class="line"></span><br><span class="line">    - 尾插法，定义一个尾节点指针func_tail</span><br><span class="line"></span><br><span class="line">    - 得到结构体首地址，利用-&gt;间接访问变量</span><br><span class="line"></span><br><span class="line">    - malloc() 和calloc()的主要区别</span><br><span class="line"></span><br><span class="line">      - 前者不能初始化所分配的内存空间，而后者默认将开辟的空间初始化为0</span><br><span class="line"></span><br><span class="line">        &gt; 在堆区动态地分配一块指定大小 size 的内存空间，用来存放数据</span><br><span class="line">        &gt; void* malloc (size_t size);</span><br><span class="line">        &gt; 在堆区动态地分配 num 个长度为 size 的连续空间，并将每一个字节都始化为 0</span><br><span class="line">        &gt; void* calloc (size_t num, size_t size);</span><br><span class="line"></span><br><span class="line">    - 同样适用strdup，复制一份字符串在新开辟的空间上，并返回其地址</span><br><span class="line"></span><br><span class="line">    - strdup中malloc开辟的空间&#96;别忘记释放&#96;：[危险的strdup函数](https:&#x2F;&#x2F;book.51cto.com&#x2F;art&#x2F;201311&#x2F;419443.htm)</span><br><span class="line"></span><br><span class="line">    - calloc、strdup的空间需要自己去free</span><br><span class="line"></span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;5QlHUrLkhY1sF2C.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;5QlHUrLkhY1sF2C.png)</span><br><span class="line"></span><br><span class="line">    - free calloc的func空间前先保存下一节点的地址</span><br><span class="line"></span><br><span class="line">      - 利用p-&gt;next即可</span><br><span class="line"></span><br><span class="line">    - 从里到外free结构体变量</span><br><span class="line"></span><br><span class="line">      - func-&gt;str strdup通过malloc出来的</span><br><span class="line">      - func calloc出来的</span><br><span class="line"></span><br><span class="line">    - free完让指针指向NULL，&#96;避免成为野指针&#96;</span><br><span class="line"></span><br><span class="line">    - 释放strdup的func-&gt;str指向的空间时，需使用(void *)强转一下</span><br><span class="line"></span><br><span class="line">      - 否则会有free const char*的警告，参考：[In C, why do some people cast the pointer before freeing it?](https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;34019977&#x2F;in-c-why-do-some-people-cast-the-pointer-before-freeing-it&#x2F;34023762)</span><br><span class="line"></span><br><span class="line">    - free结构体要注意细节：</span><br><span class="line"></span><br><span class="line">      - free(p)只能释放指针p所在的内存，而p指向的内存（不是动态分配的）无法free</span><br><span class="line">        - 参考[C语言free()函数：释放动态分配的内存空间](http:&#x2F;&#x2F;c.biancheng.net&#x2F;cpp&#x2F;html&#x2F;135.html)</span><br><span class="line">      - 所有动态分配的空间都需单独释放，从结构体里到外释放</span><br><span class="line">        - 结构体在堆空间，而结构体内也有变量在堆空间，需要先free成员变量，最后free这个结构体</span><br><span class="line"></span><br><span class="line">    - 查看func里变量的地址</span><br><span class="line"></span><br><span class="line">      - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;QThaBiWVX9NA7sD.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;QThaBiWVX9NA7sD.png)</span><br><span class="line">      - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;DT152XJwPzudCox.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;DT152XJwPzudCox.png)</span><br><span class="line">      - 按8字节对齐</span><br><span class="line">      - 打印func-&gt;str打印的是strdup出来的地址，打印&amp;(func-&gt;str) 打印的是结构体对象中成员str的地址</span><br><span class="line"></span><br><span class="line">#### 函数指针变量和函数名定义时的宏优化</span><br><span class="line"></span><br><span class="line">- 方式一：宏替换优化 NAME、STR2</span><br><span class="line">  - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;opRVAYOmaEG6yDU.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;opRVAYOmaEG6yDU.png)</span><br><span class="line">- 方式二：宏嵌套 NAME、STR、_STR</span><br><span class="line">  - STR(NAME(a, b, _))</span><br><span class="line">  - 但是无法使用 &#39;.&#39; 连接生成函数名，可以使用 &#39;_&#39;</span><br><span class="line">  - a##.##b在预处理阶段报错如下：</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;Mrbns4athuTDedQ.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;Mrbns4athuTDedQ.png)</span><br><span class="line">    - 把a.b作为参数、变量名是非法的→.有特殊含义</span><br><span class="line">    - 参考[error: pasting “.” and “red” does not give a valid preprocessing token](https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;13216423&#x2F;error-pasting-and-red-does-not-give-a-valid-preprocessing-token)</span><br><span class="line"></span><br><span class="line"># 附加：</span><br><span class="line"></span><br><span class="line">- 简易工程文件结构规范</span><br><span class="line">  - 使用tree工具</span><br><span class="line">- [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;J3bAH2zrBwu4SKO.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;J3bAH2zrBwu4SKO.png)</span><br><span class="line">- make的规律</span><br><span class="line">  - 如果makefile中有依赖文件做了修改</span><br><span class="line">    - 直接make，相关文件就会自动重新编译，而可以不需要make clean做清理</span><br><span class="line">  - 如果只是修改了makefile，而想重新生成对象文件</span><br><span class="line">    - 一般要先make clean，再使用make重新生成新的对象文件，否则只是重新生成最顶层all的输出</span><br><span class="line">- 可执行程序一般放在一个固定的目录下：**bin**</span><br><span class="line">- 宏内注释</span><br><span class="line">  - 单行宏：可以在后面直接使用 &#x2F;&#x2F; 注释</span><br><span class="line">  - 多行宏：只能使用 &#96;&#x2F;*...*&#x2F;&#96; 注释</span><br><span class="line">- 宏嵌套宏</span><br><span class="line">  - 当有#或##的时候，宏嵌套宏&#96;不能有效的展开&#96;，此时需要多加一层宏进行转换</span><br><span class="line">    - 但只是#和##的地方停止了展开，其它地方会继续展开</span><br><span class="line">  - 参考：[C&#x2F;C++中的宏的使用技巧(宏嵌套&#x2F;宏展开&#x2F;可变参数宏)](https:&#x2F;&#x2F;blog.csdn.net&#x2F;Pillary&#x2F;article&#x2F;details&#x2F;53705158)</span><br><span class="line">- 宏定义中#的细节</span><br><span class="line">  - 字符串化操作符</span><br><span class="line">  - 作用：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串</span><br><span class="line">  - 只能用于有传入参数的宏定义中，且必须置于**宏定义体中的参数名前**</span><br><span class="line">- [_*typeof*_()、__typeof()、typeof() 的区别](https:&#x2F;&#x2F;blog.csdn.net&#x2F;Qsir&#x2F;article&#x2F;details&#x2F;86496346)</span><br><span class="line"></span><br><span class="line"># 思考点</span><br><span class="line"></span><br><span class="line">- 宏函数可以重复定义</span><br><span class="line"></span><br><span class="line">  - 宏函数重复定义没问题，如下</span><br><span class="line">    - [![图片](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;2uHD4BU3gSayoGX.png)](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;11&#x2F;17&#x2F;2uHD4BU3gSayoGX.png)</span><br><span class="line">    - 对于这种情况，不要发生函数重名（a##*haizei_*##b）的情况</span><br><span class="line"></span><br><span class="line">  - **但是**！宏不可以重定义，即&#96;不能修改之前的定义&#96;</span><br><span class="line"></span><br><span class="line">- 宏定义不用考虑先后顺序！&amp;&amp;宏嵌套问题</span><br><span class="line"></span><br><span class="line">  - 当调用了一个宏时，直接替换宏即可</span><br><span class="line">  - 宏嵌套情况，参考[C语言宏替换的顺序](https:&#x2F;&#x2F;blog.csdn.net&#x2F;feichideche&#x2F;article&#x2F;details&#x2F;39521753)-CSDN</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#define _ToStr(x) #x </span><br><span class="line">#define __ToStr(x) _ToStr(x) </span><br><span class="line">#define EarthQuake 9.0 </span><br><span class="line">  </span><br><span class="line">int main()&#123; </span><br><span class="line">    printf(&quot;%s\n&quot;, _ToStr(EarthQuake);   &#x2F;&#x2F; EarthQuake</span><br><span class="line">    printf(&quot;%s\n&quot;, __ToStr(EarthQuake);  &#x2F;&#x2F; 9.0</span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>替换顺序</p>
<ul>
<li><p>从外层到里层，但遇到#或者##就会停止展开</p>
</li>
<li><p>第一种：→#EarthQuake→”EarthQuake”</p>
</li>
<li><p>第二种</p>
<ul>
<li>先替换第一层：→_ToStr(EarthQuake)→_ToStr(9.0)</li>
<li>再替换第二层：_ToStr(9.0)→”9.0”</li>
</ul>
</li>
<li><p>嵌套定义：#define __ToStr(x) _ToStr(x)</p>
</li>
<li><p>嵌套调用：__ToStr(EarthQuake)</p>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>工程项目</category>
      </categories>
      <tags>
        <tag>工程项目</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉查找树——BS树</title>
    <url>/2021/01/07/0008.%20BS%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="平衡二叉查找树——BS树"><a href="#平衡二叉查找树——BS树" class="headerlink" title="平衡二叉查找树——BS树"></a>平衡二叉查找树——BS树</h2><p>又名： 二叉排序树，二叉查找树</p>
<h3 id="结构定义-："><a href="#结构定义-：" class="headerlink" title="结构定义 ："></a>结构定义 ：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214353.png" alt="image-20201220214835836" style="zoom:50%;">

<p>性质： </p>
<ol>
<li>左子树 &lt; 根节点</li>
<li>右子树 &gt; 根节点</li>
<li>中序遍历的结果，是一个有序序列</li>
</ol>
<p><code>数据结构，就是定义一种性质，并且维护这种性质。</code></p>
<p>用途 ： 解决与<code>排名</code>相关的检索需求（中序遍历）</p>
<blockquote>
<p>思考 ： <code>树形结构的查找入口为什么一定是根节点？</code></p>
<p>树形结构 ： 点（集合）， 边 （关系）</p>
<p>根节点：代表全集，所以一定得从根节点开始查找</p>
</blockquote>
<h3 id="结构操作（增删查）-："><a href="#结构操作（增删查）-：" class="headerlink" title="结构操作（增删查） ："></a>结构操作（增删查） ：</h3><ol>
<li><p>支持<code>动态扩容</code></p>
</li>
<li><p>维护 ： 二叉排序树的每一步操作，都要维护二叉排序树的性质</p>
</li>
<li><p>插入 ： </p>
<ol>
<li>插入的新节点，一定会做为叶子结点</li>
<li>通过对比每个节点的值，大就右子树，小就左子树，直到遇到空白节点，则补上！</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214402.png" alt="image-20201220215611737" style="zoom:50%;">
</li>
<li><p>删除 ： </p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214409.png" alt="image-20201220215926328" style="zoom:50%;">

<ol>
<li><p>删除度为0的节点，直接删除</p>
</li>
<li><p>删除度为1的节点，把『孤儿子树』挂到其父节点上面去</p>
</li>
<li><p>删除度为2的节点，可以转化成删除度为1的节点：</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214409.png" alt="image-20201220224241364" style="zoom:50%;">

<p>对于度为2的节点：</p>
<ol>
<li><p>前驱 ：左子树的最大值</p>
</li>
<li><p>后继 ：右子树的最小值</p>
</li>
<li><p>前驱后继的性质 ： <code>只有左子树（右子树）</code>，没有右子树（左子树），则一定不是度为2 的节点。</p>
</li>
<li><p>删除度为2 的节点的方法 ： 让前驱或者后继<code>替换掉根节点</code>，然后<code>删除相应的度为1</code> 的前驱或者后继节点。</p>
</li>
<li><p>平均查找效率 ： 期望值（每个节点的查找次数相加，再除以总节点数）</p>
</li>
<li><p>如果不维护，那插入顺序不同，会导致查找效率不一样</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>查找 ： </p>
</li>
</ol>
<h2 id="代码演示-bug版本"><a href="#代码演示-bug版本" class="headerlink" title="代码演示(bug版本)"></a>代码演示(bug版本)</h2><p>bug : </p>
<ol>
<li>这一版的bug 体现在前驱后继是针对<code>度为2</code>的节点。</li>
<li><code>注意 ： 对整体来说，只找度为2的节点，并没有任何的问题！！！！！！</code></li>
<li>度为1 或者为0的节点，前驱后继，<code>不一定在自己的子树里面</code>！</li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; val) <span class="keyword">return</span> search(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predcessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理度为 1 的情况，这一部分可以去除，不影响</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 处理度为 0 的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predcessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d)\n&quot;</span>, KEY(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h2><ol>
<li><code>插入顺序</code>会<code>影响</code>最终的<code>树形结构</code></li>
<li>不同的树形结构，查找效率不同</li>
</ol>
<p>平均查找效率：节点查找次数的<code>期望值</code>，$\frac{总次数}{节点数量}$，假设每个节点等概率的被查找</p>
<h2 id="扩张内容"><a href="#扩张内容" class="headerlink" title="扩张内容"></a>扩张内容</h2><h4 id="1-二叉排序树的删除代码优化"><a href="#1-二叉排序树的删除代码优化" class="headerlink" title="1. 二叉排序树的删除代码优化"></a>1. 二叉排序树的删除代码优化</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214450.png" alt="image-20201221101007826" style="zoom: 67%;">

<p>这段代码可以去除，因为度为1跟度为0的判别，都是通过判别子节点是否为空，只不过一个是判别一个，一个是判别两个，不过，无论是一个还是两个，都可以删除，所以直接去掉就行了。</p>
<h4 id="2-如何解决-排名-相关的检索需求"><a href="#2-如何解决-排名-相关的检索需求" class="headerlink" title="2.如何解决==排名== 相关的检索需求"></a>2.如何解决==排名== 相关的检索需求</h4><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214441.png" alt="image-20201221101452588" style="zoom:67%;">

<p>想知道排名，只要直到节点的左右节点数量即可，不过目前的版本没有跟节点数量有关的数据，所以，扩展一下。</p>
<h5 id="代码修改演示"><a href="#代码修改演示" class="headerlink" title="代码修改演示"></a>代码修改演示</h5><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;  <span class="comment">//加入表示节点数量的size</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加与删除操作的节点数量维护一样，直接写成一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; val) <span class="keyword">return</span> search(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    update_size(root); <span class="comment">//节点数量维护</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predcessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predcessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root); <span class="comment">//节点数量维护</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="comment">//节点数量展示</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210108214425.png" alt="image-20201221103213939" style="zoom: 50%;">

<p>排名第 k 位的元素 ： </p>
<ol>
<li>修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量， LS为左子树的节点数量</li>
<li>$k = LS - 1$，根节点就是排名第 k 位的元素</li>
<li>$k \le LS$，排名第 k 位的元素在左子树中</li>
<li>$k \gt LS，search_k(root-&gt;rchild, k - LS - 1)$</li>
<li>代码演示：</li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(L(root)) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="3-解决Tok-k-问题-：输出排名前-k-位的值"><a href="#3-解决Tok-k-问题-：输出排名前-k-位的值" class="headerlink" title="3. 解决Tok - k 问题  ：输出排名前 k 位的值"></a>3. 解决Tok - k 问题  ：输出排名前 k 位的值</h4><ol>
<li>根节点就是第 k 位元素的话，就把左子树中的值全部输出出来</li>
<li>第 k 位在左子树中，前 k 位元素全都在左子树中</li>
<li>第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值</li>
<li>代码演示 </li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void printf(Node *root) &#123;</span><br><span class="line">    printf(&quot;(%d[%d], %d, %d)\n&quot;, KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output(Node *root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) return ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    printf(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void output_k(Node *root, int k) &#123;</span><br><span class="line">    if (k &#x3D;&#x3D; 0 || root &#x3D;&#x3D; NULL) return;</span><br><span class="line">    if (k &lt;&#x3D; SIZE(L(root))) &#123;</span><br><span class="line">        output_k(root-&gt;lchild, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        output(root-&gt;lchild);</span><br><span class="line">        printf(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(L(root)) - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="4-二叉排序树与快速排序的关系"><a href="#4-二叉排序树与快速排序的关系" class="headerlink" title="4. 二叉排序树与快速排序的关系"></a>4. 二叉排序树与快速排序的关系</h4><ol>
<li>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</li>
<li>思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系<ul>
<li>其实是一码事，建树过程类似多个Partirion过程。</li>
</ul>
</li>
<li>思考2：快速选择算法和二叉排序树之间的关系<ul>
<li>两者本质也一样，前者表现为算法，后者表现为数据结构</li>
</ul>
</li>
<li>程序=算法+数据结构</li>
</ol>
<blockquote>
<p>所谓算法设计及分析能力：分类讨论及归纳总结的能力</p>
</blockquote>
<h2 id="最终代码演示"><a href="#最终代码演示" class="headerlink" title="最终代码演示"></a>最终代码演示</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key &gt; val) <span class="keyword">return</span> search(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(L(root)) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild,key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//度为2 的前驱</span></span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        output_k(root-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        output(root-&gt;lchild);</span><br><span class="line">        print(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : <span class="built_in">printf</span>(<span class="string">&quot;search_k %d, result : %d\n&quot;</span>, val, search_k(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;output top-%d elements\n&quot;</span>, val);</span><br><span class="line">                output_k(root, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">2</span>) &#123;</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="修改版本："><a href="#修改版本：" class="headerlink" title="修改版本："></a>修改版本：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n-&gt;size)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n-&gt;lchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(n) (n-&gt;rchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n-&gt;key)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL) </span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = NIL-&gt;size = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;size = SIZE(L(root)) + SIZE(R(root)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;key) <span class="keyword">return</span> search(root-&gt;lchild, val);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(L(root)) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        output_k(root-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        output(root-&gt;lchild);</span><br><span class="line">        print(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : <span class="built_in">printf</span>(<span class="string">&quot;search_k %d, result : %d\n&quot;</span>, val, search_k(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;output top-%d elements\n&quot;</span>, val);</span><br><span class="line">                output_k(root, val);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">2</span>) &#123;</span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/01/09/0010.%20%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="红黑树——初中生必知必会系列"><a href="#红黑树——初中生必知必会系列" class="headerlink" title="红黑树——初中生必知必会系列"></a>红黑树——初中生必知必会系列</h2><ul>
<li>工程实践中，使用的大多数红黑树</li>
<li>红黑树可以动态的插入数据，其实就是二叉树的作用，只不过红黑树是平衡二叉树，照顾到了它的检索效率</li>
<li>当红黑树变大了之后，红色很难上浮</li>
<li>查找效率 ： AVL树 &gt; 红黑树</li>
<li>动态删除添加： 调整代价 ： 红黑树 &lt;&lt; AVL树</li>
</ul>
<h2 id="一、平衡条件（4跟5是关键，1-3基本是废话）"><a href="#一、平衡条件（4跟5是关键，1-3基本是废话）" class="headerlink" title="一、平衡条件（4跟5是关键，1-3基本是废话）"></a>一、平衡条件（4跟5是关键，1-3基本是废话）</h2><ol>
<li>节点非黑既红</li>
<li>根节点是黑色</li>
<li>叶子（NIL）结点是黑色（<code>虚拟叶子节点</code>，基本就是废话，相当于<code>NULL</code>）</li>
<li><code>红色节点</code>下面接<code>两个黑色节点</code></li>
<li>从根节点到叶子结点路径上，<code>黑色</code>节点<code>数量相同</code>（不考虑NIL节点，只考虑实际节点）</li>
</ol>
<h3 id="平衡条件的认识"><a href="#平衡条件的认识" class="headerlink" title="平衡条件的认识"></a>平衡条件的认识</h3><p><code>第4条和第5条条件</code>，注定了，红黑树中<code>最长路径</code>是<code>最短路径</code>的<code>长度的 2 倍</code>。</p>
<p>本质上，红黑树也是通过<code>树高</code>来控制平衡的，因为<code>最长路径最多是最短路劲的2倍</code>。</p>
<p>红黑树比 AVL 树<code>树高控制</code>条件要更<code>松散</code>，红黑树在发生<code>节点插入和删除</code>以后，发生<code>调整的概率</code>，比 AVL 树要更<code>小</code>。</p>
<h2 id="二、学习诀窍（插入调整与删除调整分开）"><a href="#二、学习诀窍（插入调整与删除调整分开）" class="headerlink" title="二、学习诀窍（插入调整与删除调整分开）"></a>二、学习诀窍（插入调整与删除调整分开）</h2><ol>
<li>理解红黑树的插入调整，要站在==祖父节点==向下进行调整<ol>
<li>向下查看<code>两层</code>，看<code>爸爸跟儿子</code>是否发生冲突</li>
<li>如果<code>站在父节点的位置</code>，发现<code>父节点与儿子发生冲突</code>，这个时候<code>不调整</code></li>
</ol>
</li>
<li>理解红黑树的删除调整，要站在==父节点==向下进行调整<ol>
<li>删除时，只需<code>向下看一层</code>，看两个孩子是否需要调整</li>
</ol>
</li>
<li>插入<code>调整</code>，主要就是为了解决<code>双红情况</code></li>
<li>新插入的节点<code>一定是红色</code>，插入<code>黑色节点</code>一定会产生冲突，<code>违反条件5</code>，插入<code>红色节点</code>，<code>不一定</code>产生冲突（即黑色节点<code>一定会</code>调整，红色节点<code>不一定会</code>调整）</li>
<li>把<code>每一种情况</code>，想象成一棵大的红黑树中的<code>局部子树</code></li>
<li>局部调整的时候，为了<code>不影响全局</code>，调整<code>前后</code>的<code>路径上黑色节点数量相同</code></li>
</ol>
<h2 id="三、插入策略（总共五种情况，插入2-删除-3）"><a href="#三、插入策略（总共五种情况，插入2-删除-3）" class="headerlink" title="三、插入策略（总共五种情况，插入2 + 删除 3）"></a>三、插入策略（总共五种情况，插入2 + 删除 3）</h2><ol>
<li><p><code>叔叔节点为红色</code>的时候，修改三元组小帽子，改成<code>红黑黑</code></p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309111129.png" alt="image-20201222200902510"></li>
</ol>
</li>
<li><p>叔叔节点为<code>黑色</code>的时候，参考 <code>AVL 树的失衡</code>情况，分成 $LL,LR,RL,RR$, 先参考 AVL 树的<code>旋转调整策略</code>，然后再修改三元组的颜色，有两种调整策略：<code>红色上浮，红色下沉</code>。 </p>
<ol>
<li><blockquote>
<p>红色下沉会和新插入的节点大概率产生冲突，红色上浮有可能和父节点产生冲突。两者没啥可比性，实际实现的时候，哪一种都可以。</p>
</blockquote>
</li>
<li></li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309111158.png" alt="image-20201224140622633"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309111204.png" alt="image-20201224140710253"></p>
</li>
</ol>
</li>
<li><p>两大类情况，包含 8 种小情况（4+4）</p>
</li>
</ol>
<h2 id="四、问题"><a href="#四、问题" class="headerlink" title="四、问题"></a>四、问题</h2><ul>
<li>根结点的手动染黑<ul>
<li>保证2nd条件：根结点为黑色</li>
<li>什么情况下，根结点会为红色<ul>
<li>插入的第一个结点 [插入的结点为红色]</li>
<li>情况一的红色上浮</li>
<li>情况二的红色上浮 [红色下沉则不会影响]</li>
</ul>
</li>
<li>❗ 只有手动染黑操作，会增加路径上黑色结点的数量<ul>
<li>在根结点处发生大旋转操作时，根结点会变成红结点，此时手动染黑生效</li>
</ul>
</li>
<li>通过代码封装处理：insert = __insert + 染黑</li>
</ul>
</li>
<li>❓ 情况一的偷懒操作对回溯时的调整有没有影响？<ul>
<li>不会对下面的路径产生冲突</li>
<li>不影响路径的黑色结点数量</li>
<li>可能会导致上层结点发生冲突<ul>
<li>但本身就是随机操作，当红黑树到了一定规模时，损耗可忽略不计</li>
</ul>
</li>
</ul>
</li>
<li>❓ 红色下沉和红色上浮的区别：各有各的好，都有冲突的可能<ul>
<li>红色下沉：容易和新插入的结点产生冲突</li>
<li>红色上浮：容易和父结点产生冲突<ul>
<li>[PS] 红黑树很大的时候，红色结点很难上浮</li>
</ul>
</li>
</ul>
</li>
<li>❓ AVL树与红黑树<ul>
<li>AVL树比红黑树更平衡</li>
<li>红黑树调整的代价低于AVL树<ul>
<li>红黑树约一半的调整都可以通过染色解决 [情况一]</li>
</ul>
</li>
<li>适合动态插入和删除结点，而查找可能稍逊于AVL</li>
</ul>
</li>
<li>[PS]<ul>
<li>插入调整，发生在递归的回溯阶段</li>
<li>插入调整的代码中，使用goto语句，减少了代码量；使用函数封装应该更标准</li>
</ul>
</li>
</ul>
<h2 id="五、代码演示"><a href="#五、代码演示" class="headerlink" title="五、代码演示"></a>五、代码演示</h2><ol>
<li>插入调整，发正在递归的回溯阶段</li>
<li>插入调整代码中，使用 goto 语句，8行代码，变成了4行</li>
<li>处理根节点一定是黑色，通过代码封装，$insert-&gt;__insert$</li>
</ol>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> color; <span class="comment">// 0 red, 1 black, 2 double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;color = <span class="number">0</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 偷懒的调整策略，没有去判断有没有真实发生双红冲突</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = __insert(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = __insert(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, key);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">          root-&gt;color, root-&gt;key,</span><br><span class="line">          root-&gt;lchild-&gt;key,</span><br><span class="line">          root-&gt;rchild-&gt;key</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="六、删除调整发生的前提"><a href="#六、删除调整发生的前提" class="headerlink" title="六、删除调整发生的前提"></a>六、删除调整发生的前提</h2><ol>
<li>删除<code>红色节点</code>，<code>不会</code>对红黑树的平衡<code>产生影响</code></li>
<li>度为1的黑色节点，<code>唯一子孩子</code>，一定是<code>红色</code>（如果不是红色，则该节点一定有另一个黑色孩子）</li>
<li>删除度为1的黑色节点，不会产生删除调整（局部）（把子节点改为黑色即可）</li>
<li>删除度为0的黑色节点，会产生一个<code>双重黑的 NIL 节点</code>（可能会向上传递，从而使得一些<code>真实节点</code>也变成<code>双重黑</code>）</li>
<li>删除调整，就是<code>为了干掉双重黑</code>（插入调整，为了<code>干掉双红</code>）</li>
</ol>
<h2 id="七、删除调整"><a href="#七、删除调整" class="headerlink" title="七、删除调整"></a>七、删除调整</h2><ol>
<li><code>双重黑</code>节点的<code>兄弟节点是黑色</code>，兄弟节点<code>下面的两个子节点也是黑色</code>，父节点<code>增加一重黑色</code>，双重黑与兄弟节点，分别<code>减少一重黑色</code>。</li>
<li><img src="/2021/01/09/0010/File\Library\Image\image-20201223183325109.png" alt="image-20201223183325109"></li>
<li>兄弟节点是黑色，并且，兄弟节点中有红色子节点<ol>
<li>R（兄弟）R（右子节点），左旋，新根改成原根的颜色，将新根的两个子节点，改成黑色<ol>
<li><img src="/2021/01/09/0010/File\Library\Image\image-20201223183540451.png" alt="image-20201223183540451"></li>
</ol>
</li>
<li>R（兄弟）L（左子节点），先小右旋，对调新根与原根的颜色，转成上一种情况<ol>
<li><img src="/2021/01/09/0010/File\Library\Image\image-20201223183610751.png" alt="image-20201223183610751"></li>
</ol>
</li>
<li>LL 同理 RR</li>
<li>LR 同理 RL</li>
</ol>
</li>
<li>兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况<ol>
<li><img src="/2021/01/09/0010/File\Library\Image\image-20201223184144712.png" alt="image-20201223184144712"></li>
</ol>
</li>
</ol>
<h2 id="八、代码演示"><a href="#八、代码演示" class="headerlink" title="八、代码演示"></a>八、代码演示</h2><ol>
<li><p>进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       <span class="keyword">int</span> color; <span class="comment">// 0 red, 1 black, 2 double black</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   &#125; Node;</span><br><span class="line">   </span><br><span class="line">   Node __NIL;</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">   __attribute__((constructor))</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       NIL-&gt;key = <span class="number">0</span>;</span><br><span class="line">       NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">       NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">       p-&gt;key = key;</span><br><span class="line">       p-&gt;color = <span class="number">0</span>;</span><br><span class="line">       p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       Node *temp = root-&gt;rchild;</span><br><span class="line">       root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">       temp-&gt;lchild = root;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       Node *temp = root-&gt;lchild;</span><br><span class="line">       root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">       temp-&gt;rchild = root;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 判断是否发生双红冲突（此处可以偷懒，即无论有没有冲突，都直接变成黑色）</span></span><br><span class="line">       <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (has_red_child(root-&gt;lchild) || has_red_child(root-&gt;rchild)) &#123;</span><br><span class="line">               <span class="keyword">goto</span> insert_end;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">               root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">           &#125;</span><br><span class="line">           root = right_rotate(root);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">               root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">           &#125;</span><br><span class="line">           root = left_rotate(root);</span><br><span class="line">       &#125;</span><br><span class="line">   insert_end:</span><br><span class="line">       root-&gt;color = <span class="number">0</span>;</span><br><span class="line">       root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node *__insert(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">           root-&gt;lchild = __insert(root-&gt;lchild, key);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           root-&gt;rchild = __insert(root-&gt;rchild, key);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> insert_maintain(root);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       root = __insert(root, key);</span><br><span class="line">       root-&gt;color = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       Node *temp = root-&gt;lchild;</span><br><span class="line">       <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;lchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;rchild-&gt;color != <span class="number">2</span>) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">if</span> (has_red_child(root)) &#123;</span><br><span class="line">           <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">           root-&gt;color = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">               root = right_rotate(root);</span><br><span class="line">               flag = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               root = left_rotate(root);</span><br><span class="line">               flag = <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           root-&gt;color = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) root-&gt;rchild = erase_maintain(root-&gt;rchild);</span><br><span class="line">           <span class="keyword">else</span> root-&gt;lchild = erase_maintain(root-&gt;lchild);</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((root-&gt;lchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;rchild)) ||</span><br><span class="line">           (root-&gt;rchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;lchild))) &#123;</span><br><span class="line">               root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">               root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">               root-&gt;color += <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">return</span> root;</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">               root-&gt;rchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">               root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">               root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">           root = left_rotate(root);</span><br><span class="line">           root-&gt;color = root-&gt;lchild-&gt;color;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">               root-&gt;lchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">               root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">               root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">           root = right_rotate(root);</span><br><span class="line">           root-&gt;color = root-&gt;rchild-&gt;color;</span><br><span class="line">       &#125;</span><br><span class="line">       root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Node *__erase(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">       <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">           root-&gt;lchild = __erase(root-&gt;lchild, key);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">           root-&gt;rchild = __erase(root-&gt;rchild, key);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">               Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">               temp-&gt;color += root-&gt;color;</span><br><span class="line">               <span class="built_in">free</span>(root);</span><br><span class="line">               <span class="keyword">return</span> temp;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Node *temp = predecessor(root);</span><br><span class="line">               root-&gt;key = temp-&gt;key;</span><br><span class="line">               root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> erase_maintain(root);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       root = __erase(root, key);</span><br><span class="line">       root-&gt;color = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">       clear(root-&gt;lchild);</span><br><span class="line">       clear(root-&gt;rchild);</span><br><span class="line">       <span class="built_in">free</span>(root);</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,</span><br><span class="line">             root-&gt;key, root-&gt;color,</span><br><span class="line">             root-&gt;lchild-&gt;key,</span><br><span class="line">             root-&gt;rchild-&gt;key</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span>;</span><br><span class="line">       output(root-&gt;lchild);</span><br><span class="line">       print(root);</span><br><span class="line">       output(root-&gt;rchild);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> op, val;</span><br><span class="line">       Node *root = NIL;</span><br><span class="line">       <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">           <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span> : root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">2</span> : root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">3</span> : output(root); <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>

</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
        <category>高级数据结构</category>
      </categories>
      <tags>
        <tag>手撕数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信（共享内存）</title>
    <url>/2021/01/06/0021.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程间的通信（共享内存）"><a href="#进程间的通信（共享内存）" class="headerlink" title="进程间的通信（共享内存）"></a>进程间的通信（共享内存）</h1><blockquote>
<p>不同的进程拥有同一块内存，可以共同对这块内存进行读写，分亲缘与非亲缘两种。 </p>
<ul>
<li>亲缘关系：父子，兄弟进程</li>
<li>非亲缘关系：除亲缘关系的其他关系</li>
</ul>
</blockquote>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget :"></a>shmget :</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过一个<code>key</code>值（通过<code>ftok</code>得到），返回一个<code>id</code>，只要<code>key相同</code>，返回的<code>id</code>也一定会<code>相同</code>。</p>
<ul>
<li><p><code>ipc</code> : 进程间通信 </p>
</li>
<li><p><code>size</code>：向上取整</p>
</li>
<li><p><code>shmflg</code> ：只要有<code>IPC_CREAT</code>存在，就会建立一个共享内存段</p>
<blockquote>
<p>如果<code>shmflg</code>中有<code>IPC_CREAT</code>与<code>IPC_EXCL</code>，并且已经存在一个共享内存段，则<code>shmget</code>会失败。</p>
<p>如果没有<code>IPC_CREAT</code>，则<code>shmget</code>会寻找在<code>key</code>里面寻找是否有与之对应的共享内存段并确定是否有<code>access</code>的权限，没有则会报错。 </p>
</blockquote>
<blockquote>
<p>需要一个东西，把 <code>id</code> 转化成<code>地址</code>——<code>shamat</code></p>
</blockquote>
</li>
</ul>
<h3 id="shmat："><a href="#shmat：" class="headerlink" title="shmat："></a>shmat：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>调度进程地址空间</li>
</ul>
<blockquote>
<p>每一个调度进程，调度同一个<code>id</code>（比如两个调度进程都调取2099），得到的地址可能是不同的，因为得到的地址，仅仅只是该<code>id</code>在这个进程中的地址。 </p>
</blockquote>
<ul>
<li>成功使用<code>shamt</code>之后，会更新<code>shmid_ds</code>这个结构体中的内容。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">A successful <span class="title">shmat</span><span class="params">()</span> call updates the members of the shmid_ds <span class="title">structure</span> <span class="params">(see shmctl(<span class="number">2</span>))</span> associated with the shared memory segment as follows:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">shm_atime is <span class="built_in">set</span> to the current time.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">   shm_lpid is set to the process-ID of the calling process.</span><br><span class="line"></span><br><span class="line">   shm_nattch is incremented by one.</span><br></pre></td></tr></table></figure>
<h3 id="shmdl："><a href="#shmdl：" class="headerlink" title="shmdl："></a>shmdl：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>去除附属在<code>shmat</code>地址上的共享内存段</p>
<blockquote>
<p>用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。</p>
</blockquote>
</li>
<li><p>成功使用后，会更新<code>shmid_ds</code>这个结构体中的内容。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">On a successful shmdt() call, the system updates the members of the shmid_ds structure associated with  the shared memory segment as follows:</span><br><span class="line"></span><br><span class="line">shm_dtime is <span class="built_in">set</span> to the current time.</span><br><span class="line"></span><br><span class="line">   shm_lpid is <span class="built_in">set</span> to the process-ID of the calling process.</span><br><span class="line"></span><br><span class="line">   shm_nattch  is decremented by one.  If it becomes <span class="number">0</span> <span class="keyword">and</span> the segment is marked <span class="keyword">for</span> deletion, the segment is deleted.</span><br></pre></td></tr></table></figure>
<h3 id="ftok："><a href="#ftok：" class="headerlink" title="ftok："></a>ftok：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>把一个<code>路径名与项目id</code> 转为一个<code>IPC的key</code>。</p>
<blockquote>
<p>不同用户的地址会变，但物理地址<code>id</code>是唯一的，不变的。</p>
</blockquote>
<blockquote>
<p>system V 的启动模式已经被淘汰，但是底层逻辑仍然继续被沿用。</p>
</blockquote>
<h4 id="shmctl："><a href="#shmctl：" class="headerlink" title="shmctl："></a>shmctl：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>控制共享内存。</p>
<ul>
<li><p><code>shmid</code>：<code>shmget()</code>函数返回的共享内存标识符。</p>
</li>
<li><p><code>cmd</code> ： 要采取的操作，它可以取下面的三个值 ：</p>
<ul>
<li><code>IPC_STAT</code>：把s<code>hmid_ds</code>结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖<code>shmid_ds</code>的值。</li>
<li><code>IPC_SET</code>：如果进程有足够的权限，就把共享内存的当前关联值设置为<code>shmid_ds</code>结构中给出的值</li>
<li><code>IPC_RMID</code>：当<code>nattch</code>为<code>0</code>的时候可以删除共享内存段</li>
</ul>
</li>
<li><p><code>buf</code>：一个结构指针，指向<code>共享内存模式和访问权限</code>的结构。</p>
</li>
</ul>
<blockquote>
<p><code>shmid_ds</code>结构 至少包括以下成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="keyword">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="代码演示（数字累加的改版）"><a href="#代码演示（数字累加的改版）" class="headerlink" title="代码演示（数字累加的改版）"></a>代码演示（数字累加的改版）</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>结果：编译没问题，执行第一次没问题，第二次开始就报错</p>
</li>
<li><p>分析：因为第一次执行时创建的共享内存段没有被删除，系统误以为还有用，还在等着别人的加入，这个时候还加入了 <code>IPC_EXCL</code>就会导致出错</p>
<blockquote>
<p><code>ipcs</code>：可以看到当前用户有权限读到的共享内存段</p>
<p><code>ipcrm -m id</code>：删除指定共享内存段</p>
<p><code>ipcs | grep alin | awk &#39;&#123;print $2&#125;&#39; | xargs ipcrm -m</code> ： 删除产生的共享内存段</p>
<p><code>0666</code>：因为该操作没有权限，所以给它赋予<code>可读可写</code>的权限，不赋予的话，可能会出现段错误</p>
</blockquote>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (share_memory-&gt;now &gt; <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">        share_memory-&gt;sum += share_memory-&gt;now;</span><br><span class="line">        share_memory-&gt;now++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; now = %d, sum = %d\n&quot;</span>, x, share_memory-&gt;now, share_memory-&gt;sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory-&gt;now = <span class="number">0</span>;</span><br><span class="line">    share_memory-&gt;sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        do_add(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share_memory-&gt;sum = %d\n&quot;</span>, share_memory-&gt;sum);</span><br><span class="line">    shmdt(share_memory);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>结果：最终结果不会报错，但数据可能会出错，就是竞争了</p>
</li>
<li><p>结果不出错的结果分析：cpu（而且还是多核心），计算速度太快了，可能来不及产生竞争就结束了。</p>
<blockquote>
<p>单个核心的时候，一般会是线性执行，但是可能出现时间片结束的时候，刚好处在进程执行一半的时候，这个时候，结果就不会更新，比如累加，还没累加就结束了。</p>
</blockquote>
</li>
<li><p>分析：之前是用<code>文件锁</code>解决问题，现在是直接在内存中干活，再用<code>文件锁</code>的话，效率会低下。现在可以使用<code>线程互斥锁（pthread_mutex_）</code>。</p>
<p><img src="/2021/01/06/0021/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210123112043911.png" alt="image-20210123112043911"></p>
<blockquote>
<p>做<code>并发</code>时，一定要实现<code>互斥</code>，否则<code>并发</code>就没有任何的意义，因为可能产生更大的错误。</p>
</blockquote>
</li>
</ul>
<h4 id="pthread-mutex-init：互斥锁的初始化"><a href="#pthread-mutex-init：互斥锁的初始化" class="headerlink" title="pthread_mutex_init：互斥锁的初始化"></a>pthread_mutex_init：互斥锁的初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> fastmutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>pthread_mutexattr_</code>：线程属性</p>
<p><img src="/2021/01/06/0021/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210123112353016.png" alt="image-20210123112353016"></p>
<ul>
<li><code>pthread_mutexattr_setpshared</code>：设置进程间共享，因为这个原本是线程之间使用，现在要在进程之间使用，所以需要设置。</li>
</ul>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="keyword">if</span> (share_memory-&gt;now &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这地方不解锁，就可能会发生死锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        share_memory-&gt;sum += share_memory-&gt;now;</span><br><span class="line">        share_memory-&gt;now++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; now = %d, sum = %d\n&quot;</span>, x, share_memory-&gt;now, share_memory-&gt;sum);</span><br><span class="line">        <span class="comment">//强制刷新一下内存，使得输出样式准确，都是单行输出。</span></span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory-&gt;now = <span class="number">0</span>;</span><br><span class="line">    share_memory-&gt;sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_setpshared(&amp;attr, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        do_add(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share_memory-&gt;sum = %d\n&quot;</span>, share_memory-&gt;sum);</span><br><span class="line">    shmdt(share_memory);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<blockquote>
<p>系统中最慢的操作是<code>IO</code>操作。</p>
<p>操作速度：cpu &gt; 高级缓存 &gt; 内存 &gt; 磁盘（IO）</p>
</blockquote>
<ul>
<li><code>ipcs | grep alin | awk &#39;&#123;print $2&#125;&#39; | xargs ipcrm -m &amp;&amp; ./a.out | cut -d = -f 2 | cut -d , -f 1 | cut -d &quot; &quot; -f 2 | grep -v fork | grep -v &quot;5000500&quot; | sort -n | uniq -c | awk &#39;&#123;print $1&#125;&#39; | sort -n</code>  ：查看每个进程每个数字被用了多少次，正常的话应该都是一次。</li>
<li>不是一次的原因：<code>printf</code>输出的时候，是多个进程往一个终端打印，导致终端的数据出现了错误，多个输出被写在了一起， 可以用<code>fflush(stdout);</code>在解锁之前强制刷新一下。</li>
</ul>
<h3 id="pthread-cond-（线程条件变量实现数量累加）"><a href="#pthread-cond-（线程条件变量实现数量累加）" class="headerlink" title="pthread_cond_: （线程条件变量实现数量累加）"></a>pthread_cond_: （线程条件变量实现数量累加）</h3><ul>
<li>比如 5 个进程累加 1000 个数，一个进程累加了 200 个数后，交给下一个进程继续计算。</li>
</ul>
<p><img src="/2021/01/06/0021/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210123134209627.png" alt="image-20210123134209627"></p>
<ul>
<li><p>允许线程挂起直到符合一些特定的要求之后才被唤醒执行</p>
</li>
<li><p>三种基础操作：</p>
<ul>
<li>条件满足的信号</li>
<li>等待条件满足的信号</li>
<li>挂起直到另一个线程通知的信号</li>
</ul>
</li>
<li><p>条件变量<code>必须关联</code>一个<code>互斥量</code></p>
</li>
<li><p><code>pthread_cond_signal</code> ： 发出信号时，如果没有一个线程在等待，则不会发生什么事；如果有多个线程在等待，则只能随机唤醒一个线程。</p>
</li>
<li><p><code>pthread_cond_broadcast</code>：唤醒所有线程</p>
</li>
<li><p><code>pthread_cond_wait</code>：会<code>自动解锁</code>并等待信号，线程会被挂起并不会消耗任何的资源，在进行这个操作之前，需要<code>先加锁</code>！再被唤醒之后，会<code>自动重新加锁</code>！</p>
</li>
<li><p><code>pthread_cond_timedwait</code>：延迟多久，即等待多久</p>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span> *<span class="title">share_memory</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;share_memory-&gt;cond, &amp;share_memory-&gt;mutex);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (share_memory-&gt;now &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">                sleep(<span class="number">0.1</span>); <span class="comment">// 因为是单核，所以这里最好也是睡眠一下，避免跟其他进程漏掉信号。</span></span><br><span class="line">                pthread_cond_signal(&amp;share_memory-&gt;cond); <span class="comment">// 这里需要給一个信号给其他的线程，通知他们可以进行下一次操作了。</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">             &#125;</span><br><span class="line">            share_memory-&gt;sum += share_memory-&gt;now;</span><br><span class="line">            share_memory-&gt;now++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; now = %d, sum = %d\n&quot;</span>, x, share_memory-&gt;now, share_memory-&gt;sum);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;share_memory-&gt;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, <span class="keyword">sizeof</span>(struct Num), IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory = (struct Num *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (share_memory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;share_memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    share_memory-&gt;now = <span class="number">0</span>;</span><br><span class="line">    share_memory-&gt;sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;attr, <span class="number">1</span>);</span><br><span class="line">    pthread_mutex_init(&amp;share_memory-&gt;mutex, &amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_condattr_t</span> c_attr;</span><br><span class="line">    pthread_condattr_init(&amp;c_attr);</span><br><span class="line">    pthread_condattr_setpshared(&amp;c_attr, <span class="number">1</span>);</span><br><span class="line">    pthread_cond_init(&amp;share_memory-&gt;cond, &amp;c_attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x = i;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        do_add(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        pthread_cond_signal(&amp;share_memory-&gt;cond);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= INS; i++) &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;share_memory-&gt;sum = %d\n&quot;</span>, share_memory-&gt;sum);</span><br><span class="line">    shmdt(share_memory);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>单核情况下，父进程发出的信号，子进程没有收到，导致程序从一开始就直接阻塞了</li>
<li>父进程发出的信号被子进程收到了，当所有子进程的任务都完成之后，却没有自杀，使得父进程一直在等待，程序不会退出。</li>
<li>程序每次执行一次之后，共享内存段不会随着程序的结束而被释放掉，需要人工释放</li>
</ol>
<h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><ol>
<li><p>在单核情况下，父进程的速度太快，子进程还没准备好接收，父进程就已经发出了信号，使得子进程错过了父进程的信号，即<a href="https://blog.csdn.net/liyupeng01boke/article/details/38511477?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">消息遗漏</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210123162621.png" alt="image-20210123162616107"></p>
<p>可以通过使父进程<code>sleep</code>一会后再给出信号来解决问题，这样保证子进程已经进入了<code>block</code>状态。</p>
</li>
<li><p>因为当子进程任务都完成之后，也仍在阻塞着等待信号，所以，需要在<code>do_add</code>的判断终止条件里，增加一个<code>pthread_cond_signal</code>函数给与信号，好让子进程执行自杀操作。</p>
<blockquote>
<p>这里可能也会出现跟问题一一样的情形，所以需要在<code>pthread_cond_signal</code>函数之前先让子进程<code>sleep</code>一小会，比如<code>0.1</code>。</p>
</blockquote>
</li>
<li><p>通过<a href="https://www.cnblogs.com/52php/p/5861372.html">shmctl()</a> 删除共享内存段</p>
</li>
</ol>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="1-基于文件的IPC——累加和问题。"><a href="#1-基于文件的IPC——累加和问题。" class="headerlink" title="1. 基于文件的IPC——累加和问题。"></a>1. 基于文件的IPC——累加和问题。</h4><p>如果不加锁，为什么每个进程都会<code>完整的算一遍累加和</code>？</p>
<p><a href="https://www.cnblogs.com/fnlingnzb-learner/p/13030070.html">需要考虑多个进程同时打开一个文件，到底会发生什么？</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210123164549.png" alt="image-20210123164547958"></p>
<h4 id="2-pthread-mutex-unlock和pthread-cond-signal顺序的问题。"><a href="#2-pthread-mutex-unlock和pthread-cond-signal顺序的问题。" class="headerlink" title="2. pthread_mutex_unlock和pthread_cond_signal顺序的问题。"></a>2. pthread_mutex_unlock和pthread_cond_signal顺序的问题。</h4><p><a href="https://blog.csdn.net/lqygame/article/details/71124264?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">一般情况下两种都是可以的，但不同的顺序，可能效率不一样。</a></p>
<p>在<code>Linux</code>下最好<code>pthread_cond_signal</code>放<code>中间</code>，但从编程规则上说，其他两种都可以</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>线程接口</title>
    <url>/2021/01/08/0023.%20%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线程接口"><a href="#线程接口" class="headerlink" title="线程接口"></a>线程接口</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><blockquote>
<p>线程是怎么产生的？</p>
<ol>
<li>内核线程</li>
<li>用户线程</li>
</ol>
<p>一开始计算机没有线程，只有进程。为了能处理更多的并发，并提升效率，从而发展了线程。</p>
<p>进程与线程本质上并无区别，如果只创建了一个进程，那这个进程也就是主线程。</p>
</blockquote>
<h3 id="pthread-equal"><a href="#pthread-equal" class="headerlink" title="pthread_equal"></a>pthread_equal</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<p><code>pthread_create</code> 创建的<code>线程 ID</code> 会放在第一个参数 <code>pthread_t *thread</code> 里面，不过这个 <code>ID 不是</code>一个<code>数字类型</code>，因此，在判断<code>两个线程 ID</code> 是不是<code>同一个线程</code>，不能用两个 <code>ID 是否相等</code>来判断，他们并不能做数学运算，得用 <code>pthread_equal</code>。</p>
<h3 id="pthread-exit："><a href="#pthread-exit：" class="headerlink" title="pthread_exit："></a>pthread_exit：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<ul>
<li><p>线程自杀，自己调度，自己死。</p>
</li>
<li><p>自杀之前，会先检查自己需要完成的任务（<code>atexit</code>里面的操作）有没有完成，如果没有，则弹出，完成任务，然后自杀退出。</p>
</li>
<li><p>共享内存的信息都不会被释放，除非该线程是最后一个线程。</p>
</li>
</ul>
<h3 id="pthread-cancel："><a href="#pthread-cancel：" class="headerlink" title="pthread_cancel："></a>pthread_cancel：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<ul>
<li>线程被取消，他杀，别人杀你</li>
<li>发送信号给该线程，请求杀死该线程，至于该线程是否可以被取消，取决于该线程的状态与类型</li>
<li> <code>pthread_setcancelstate</code>：决定线程是否能被取消的状态值，<code>默认是允许被取消</code>；如果不允许被取消，该信号会进入排队状态，直到该线程允许被取消。</li>
<li><code>pthread_setcanceltype</code>：决定线程被取消的类型，默认是<code>推迟</code>，也可以是<code>异步</code>。<ul>
<li><code>异步</code>取消意味着线程可以随时被取消，通常是立马被取消，但系统并不保证会立马被取消。</li>
<li><code>推迟</code>意味着线程的取消会被延迟，直到遇到下一个取消点函数的调用。</li>
</ul>
</li>
</ul>
<h3 id="exit："><a href="#exit：" class="headerlink" title="exit："></a>exit：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭整个进程，从而关闭所有线程。</li>
<li>所有的标准 IO 流会被刷新并关闭，跟 <code>return 0</code>相仿，同时，那些通过<code>tmpfile</code> 创建的文件也会被移除。</li>
</ul>
<h3 id="pthread-join："><a href="#pthread-join：" class="headerlink" title="pthread_join："></a>pthread_join：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<ul>
<li>类似<code>wait</code>，等待特定线程的终结；如果线程已经被终结了，该函数立即返回。目标线程必须是<code>joinable</code>才能被其他线程或者进程等待。</li>
<li><code>retval</code>：如果不为空，则会将目标线程的内容复制一份；如果是被取消的，则会把<code>PTHREAD_CANCELED</code>放入其中。</li>
<li>如果有多个线程等待着一个线程死亡，则线程死亡后由哪个线程接手是不确定的。</li>
</ul>
<h3 id="pthread-detach："><a href="#pthread-detach：" class="headerlink" title="pthread_detach："></a>pthread_detach：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>线程ID</code>标记为<code>分离的</code></li>
<li>标记为<code>分离</code>的线程，在线程完成任务死亡时，会自动的被释放该线程的所有信息，然后归还给系统，无需等待其他线程或者父进程给它收尸。</li>
<li>尝试<code>分离</code>一个<code>已经分离</code>的线程，是一个未定义的行为。</li>
</ul>
<h3 id="pthread-yield："><a href="#pthread-yield：" class="headerlink" title="pthread_yield："></a>pthread_yield：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_yield</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">Compile <span class="keyword">and</span> link with -pthread</span><br></pre></td></tr></table></figure>
<ul>
<li><p>让出线程</p>
</li>
<li><p>协同式操作系统，<code>让出cpu</code>就是用<code>yield</code>，在<code>抢占式操作系统</code>中，这个函数不是很推荐</p>
</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="socket编程基础"><a href="#socket编程基础" class="headerlink" title="socket编程基础"></a>socket编程基础</h3><ul>
<li><code>socket</code>套接字是什么</li>
<li>网络编程的时候，到底在干什么</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305222903.png" alt="image-20210305222852663" style="zoom: 67%;">

<blockquote>
<p>需要了解TCP、IP 的五层模型，或者 OSI 的七层模型。</p>
</blockquote>
<ul>
<li>正常写的程序都是 <code>OSI</code> 七层模型中最上层——<code>应用层</code></li>
<li><code>应用层</code>下面是<code>传输层</code>，再下面就是<code>网络层</code>。</li>
<li>在网络编程中，对于开发者而言，能做的只能是选择<code>运输层</code>的协议，选择<code>TCP/UDP</code>，或者对<code>TCP/UDP</code>的参数进行一些修改。</li>
<li><code>TCP</code>：传输控制协议，面向连接的<code>可靠</code>控制协议<ul>
<li><code>TCP</code>会先保存一份数据，然后再发送数据，等到<code>接收方</code>确认收着了，再发第二份数据；如果没有确认（数据丢失），则会重新再发送一遍。</li>
<li>连接：双方都应该保存一些变量，以便描述双方之间的状态</li>
<li>连接建立：<ul>
<li>三次握手：</li>
<li>一：A 发信息给 B</li>
<li>二：B 收到信息，发确认收到的信息给 A</li>
<li>三：A 收到信息，发确认收到的信息给 B</li>
</ul>
</li>
</ul>
</li>
<li><code>UDP</code>：用户数据报协议，<code>无连接，不可靠</code>的数据传输协议<ul>
<li>不管<code>接收方</code>有没有收着，只管发送。</li>
<li>优点：灵活，可以随时随地发信息，不用管其他</li>
</ul>
</li>
<li><code>IP</code>：无论是<code>TCP/UDP</code>，都需要依靠底层的程序（底层交通）进行数据传输，这个底层的交通的目标或者起始点就是<code>IP</code>（类似现实中的<code>IP</code>地址），尽力而为的交付服务（即不可靠）。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220603.png" alt="image-20210209102620445"></p>
<ul>
<li>进程将需要传输的数据交给<code>套接字socket</code>， <code>套接字socket</code>会选择用<code>TCP/UDP</code>协议经过<code>公共的传输运输服务</code>（因特网）传递到另一个进程。</li>
<li>如果是<code>TCP</code>，发送数据之前，会自行先备份一份数据，等另一个进程确认收到了，再销毁这个备份。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223027.png" alt="image-20210305223012876" style="zoom:67%;">

<ul>
<li><p>端口号：一种看不见摸不着的计算机设备，类似于一栋大楼里面某个房间的房间号。</p>
</li>
<li><p><code>IP地址</code>由下一层的<code>IP层</code>贴上的。</p>
</li>
<li><p>序列号：发送的第几份数据</p>
</li>
<li><p>确认应答号：希望下次发送的数据的序号是多少</p>
</li>
<li><p>首部长度：单位是字（一般四个字节为一字），一般都是32位</p>
<ul>
<li><code>ACK</code> ：确认</li>
<li><code>RST</code> ：重置连接</li>
<li><code>SYN</code>：建立连接的请求，用于三次连接</li>
<li><code>FIN</code>：断开连接，用于四次挥手</li>
</ul>
</li>
<li><p>窗口大小：抑制对方的发送频率，避免一下子接收过多信息，如果大小为<code>0</code>，则不会发<code>确认收到</code>的信息给对方</p>
</li>
<li><p>校验和：检验数据可不可靠。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223125.png" alt="image-20210305223114037" style="zoom:67%;">

<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建套接字，只会服务当前线程，<code>1v1</code>的服务<ul>
<li>一个进程可以建立多个套接字</li>
<li>父进程绑定了一个套接字，子进程继承了父进程，也可以使用父进程的套接字</li>
</ul>
</li>
<li><code>domin</code> ：域<ul>
<li><code>AF_INET（IPV4）</code>、<code>AF_INET6（IPV6）</code>、<code>AF_LOCAL</code>、<code>AF_ROUTE</code></li>
</ul>
</li>
<li><code>type</code>：类型<ul>
<li><code>SOCK_STREAM</code>：字节流，<code>TCP</code>本质就是一个字节流。</li>
<li><code>SOCK_DGRAM</code>：数据报，<code>UDP</code>使用</li>
<li><code>SOCK_PACKET</code>、<code>SOCK_SEQPACKET</code></li>
</ul>
</li>
<li><code>protocal</code>：协议，一般前面两个参数会决定这个参数，如果前面已经确定，这里可以用<code>0</code><ul>
<li><code>IPPRPTP_TCP</code>、<code>IPPRPTP_UDP</code>、<code>IPPRPTP_TIPC</code>，一般为<code>0</code></li>
</ul>
</li>
<li><code>Return Value</code> ：成功为新的文件描述符，否则为 <code>-1</code>；</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>绑定<code>IP</code>和端口，用于网络的交接处，即内网与外网</p>
<blockquote>
<p>​          比如现在有个服务器或者自己写了个服务，这个服务是用来做防火墙的，该程序会先接收内网用户的数据请求，然后验证数据有没有问题，检测敏感字段等，如果没有问题，再把数据交给外网，在这个过程中，两个网卡是相互隔离且不能有任何冲突、交互的，这个时候需要绑定一个确定的<code>IP</code>，使得向<code>内网IP</code>发送数据时，不会给<code>外网IP</code>发送数据。而绑定了端口，则将该套接字的服务定向到某个特定的<code>房间号</code>。</p>
</blockquote>
</li>
<li><p><code>sockfd</code>：调用<code>socket</code>返回的文件描述符</p>
</li>
<li><p><code>addr</code> ：指向数据结构<code>struct sockaddr</code> 的指针，保存地址信息（即端口和IP地址）</p>
</li>
<li><p><code>addrlen</code> ：设置为<code>sizeof(struct sockaddr)</code></p>
</li>
<li><p><code>Return Value</code>：<code>-1</code>出错，<code>0</code>正常</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>]; <span class="comment">// 包含 IP 与端口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">// address family : AF_INET</span></span><br><span class="line">    <span class="keyword">in_port_t</span> 	   sin_port;   <span class="comment">// port in network byte order</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// internet address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internet address</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr; <span class="comment">// address in network byte order</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="与sockaddr相关的函数"><a href="#与sockaddr相关的函数" class="headerlink" title="与sockaddr相关的函数"></a>与<code>sockaddr</code>相关的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;    <span class="comment">// 主机 转换到 网络 的长整型</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;   <span class="comment">// 主机 转换到 网络 的短整型</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;     <span class="comment">// 网络 转换到 主机 的长整型</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;    <span class="comment">// 网络 转换到 主机 的短整型</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip)</span></span>;  <span class="comment">// 把一个点分十进制的的地址转为 in_addr_t 无符号整型</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;   <span class="comment">// 把 in_addr_t 无符号整型转换为点分十进制的 IP 串</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主机字节序 &amp; 网络字节序</li>
<li>主机字节序：大端、小端模式<ul>
<li>小端：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>大端：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</li>
</ul>
</li>
<li>网络字节序：4 个字节的 32 bit 值以下面的次序传输：先是0~7 bit， 最后是 24 ~ 31 bit。</li>
<li>网络字节序跟本地字节序（主机字节序）可能不一样，需要转换（从主机转换到网络，以及从网络转换到主机）。</li>
</ul>
<h3 id="listen-："><a href="#listen-：" class="headerlink" title="listen()："></a>listen()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>监听端口的连接，把主动套接字转为被动套接字</li>
<li><code>sockfd</code> ：调用<code>socket()</code>返回的套接字文件描述符</li>
<li><code>backlog</code>：进入队列中允许的连接数目</li>
<li><code>Return Value</code> ：发生错误返回<code>-1</code>， 否则返回<code>0</code>； </li>
</ul>
<blockquote>
<p>网络通信中，一定有主动方与被动方，也就是常说的<code>cs框架（client 与 server）</code>，必然有一个主动的发起方与被动服务方。</p>
<p>套接字默认状态是一个主动套接字，通过<code>listen</code>转为被动，后果就是，无法再主动，只能被动的等待别人的连接。</p>
</blockquote>
<h3 id="accept-："><a href="#accept-：" class="headerlink" title="accept()："></a>accept()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>接受连接，<code>被动接受</code></li>
<li><code>accept()</code> 用来从<code>sockfd</code>上返回一个新的连接：</li>
<li><code>sockfd</code>：必须经由<code>socket()</code>，<code>bind()</code>，<code>listen()</code>函数处理后的<code>socket</code>；</li>
<li><code>addr</code>：地址，保存对方的端口地址</li>
<li><code>addrlen</code>：地址长度</li>
<li><code>Return Value</code> ：成功返回一个新的<code>sockfd</code>，原先的<code>sockfd</code>依然可以用<code>accept</code>；失败返回<code>-1</code>；</li>
</ul>
<blockquote>
<p>三次握手成功后，由这个<code>accept()</code>建立的套接字进行<code>1v1数据传输</code></p>
<p>返回的<code>sockfd</code>包含四个部分：</p>
<ul>
<li><code>from IP</code></li>
<li><code>from Port</code></li>
<li><code>to IP</code></li>
<li><code>to Port</code></li>
</ul>
<p><code>accept</code>建立的套接字，如果不使用了，最好关闭该套接字。</p>
<p><code>listen</code>套接字则无需关闭</p>
</blockquote>
<h3 id="connect-："><a href="#connect-：" class="headerlink" title="connect()："></a>connect()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>主动</code>连接</li>
<li><code>sockfd</code>：系统调用<code>socket()</code>返回的套接字文件描述符；</li>
<li><code>addr</code>：保存目的地端口和<code>IP</code>地址的数据结构<code>struct sockaddr</code></li>
<li><code>addrlen</code>：设置为<code>sizeof(struct sockaddr)</code></li>
<li><code>Return Value</code> ：成功返回<code>0</code>；失败返回<code>-1</code>；</li>
</ul>
<blockquote>
<p><code>connect()</code>与<code>accept()</code>是<code>一对</code>，分别在客户端和服务端执行，在此期间，<code>完成了三次握手操作</code></p>
</blockquote>
<h3 id="send-："><a href="#send-：" class="headerlink" title="send()："></a>send()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>发送数据</li>
<li><code>sockfd</code>：想发送数据的套接字描述符</li>
<li><code>msg</code>：指向想发送的数据的指针</li>
<li><code>len</code> ：数据的长度</li>
<li><code>flags</code>：一般置为<code>0</code></li>
<li><code>sendto</code>：主要用在<code>UDP</code>通信中</li>
<li><code>dest_addr</code>：远端要通信的网络地址</li>
<li><code>addlen</code>：地址长度</li>
<li><code>Return Value</code>：成功发送的字节数，错误则返回<code>-1</code>，并设置<code>errno</code></li>
</ul>
<h3 id="recv-："><a href="#recv-：" class="headerlink" title="recv()："></a>recv()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                 struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>接受数据：从 <code>sockfd</code>文件读取信息到<code>buf</code>中，最多读取<code>len</code>的长度。</li>
<li><code>sockfd</code>：读取的套接字描述符</li>
<li><code>buf</code>：读取的信息的缓冲</li>
<li><code>len</code>：缓冲的最大长度</li>
<li><code>flags</code>：一般置为<code>0</code></li>
<li><code>Return Value</code>：成功返回读入缓冲的数据字节数，错误则返回<code>-1</code>，并设置<code>errno</code></li>
</ul>
<h3 id="close-："><a href="#close-：" class="headerlink" title="close()："></a>close()：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用于四次挥手，关闭文件。</p>
</li>
<li><p>四次挥手时，两端都需要调用<code>close</code></p>
</li>
<li><p>当调用<code>close</code>之后，接收方的<code>recv()</code>返回值为<code>0</code>时，则说明对端关闭了连接。</p>
<blockquote>
<p>四次挥手，谁先发起，谁就是四次挥手的<code>客户端</code>。</p>
<p><code>2MSL</code>为包的最大生存时间。</p>
</blockquote>
</li>
</ul>
<h3 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220845.png" alt="image-20210209144532377" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220840.png" alt="image-20210209144549925" style="zoom:50%;">

<h3 id="kill-："><a href="#kill-：" class="headerlink" title="kill() ："></a>kill() ：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>给一个进程发信号</li>
<li>系统支持的 64 个信号</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220835.png" alt="image-20210210121937267"></li>
</ul>
<h3 id="signal-："><a href="#signal-：" class="headerlink" title="signal() ："></a>signal() ：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>信号句柄，表示要对信号做什么事，对 <code>signum</code>做<code>handler</code>这件事</li>
<li>信号的操作，根据<code>UNIX</code>版本不同会有不同的变化</li>
<li><code>handler</code> ： <ul>
<li><code>SIG_IGN</code>：忽略这个信号</li>
<li> <code>SIG_DFL</code>：默认操作，大部分是杀死自己</li>
<li> <code>the address of a programmer-defined function (a &quot;signal handler&quot;)</code> ：自定义，会将这个操作置为默认操作，或者阻塞该信号</li>
</ul>
</li>
<li>问题：捕鼠器问题，即可能捕捉到一个信号的同时，另一个信号刚好溜走。</li>
</ul>
<h3 id="案例演示："><a href="#案例演示：" class="headerlink" title="案例演示："></a>案例演示：</h3><h3 id="建立服务端"><a href="#建立服务端" class="headerlink" title="建立服务端"></a>建立服务端</h3><h3 id="tcp-server-h-：创建一个监听状态的套接字"><a href="#tcp-server-h-：创建一个监听状态的套接字" class="headerlink" title="tcp_server.h ：创建一个监听状态的套接字"></a>tcp_server.h ：创建一个<code>监听状态</code>的套接字</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TCP_SERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TCP_SERVER_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="tcp-server-c-：创建一个监听状态的套接字"><a href="#tcp-server-c-：创建一个监听状态的套接字" class="headerlink" title="tcp_server.c ：创建一个监听状态的套接字"></a>tcp_server.c ：创建一个<code>监听状态</code>的套接字</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_create</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="comment">// 申请一个套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立表单</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    	<span class="comment">// 字节序转化</span></span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听套接字 </span></span><br><span class="line">    <span class="comment">// 20 是正在建立连接的最大数目，不包含已经连接的</span></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">20</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socketfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="建立客户端"><a href="#建立客户端" class="headerlink" title="建立客户端"></a>建立客户端</h3><h3 id="tcp-client-h："><a href="#tcp-client-h：" class="headerlink" title="tcp_client.h："></a>tcp_client.h：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TCP_CLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TCP_CLIENT_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="tcp-client-c："><a href="#tcp-client-c：" class="headerlink" title="tcp_client.c："></a>tcp_client.c：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_connect</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(port);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(server)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="建立两个线程"><a href="#建立两个线程" class="headerlink" title="建立两个线程"></a>建立两个线程</h3><h3 id="1-server-c：服务端"><a href="#1-server-c：服务端" class="headerlink" title="1.server.c：服务端"></a>1.server.c：服务端</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存对方地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="comment">// 地址长度</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is online\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">        <span class="comment">// 建立子进程，避免只能跟一个客户端建立联系</span></span><br><span class="line">        <span class="comment">// 如果没有建立子进程，当有两个客户端时，服务端只能跟一个客户端连接，无法跟另一个客户端连接</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是孩子进程，则不需要在 sever_listen 了，不用再监听这个端口了，专心自己的专属客户</span></span><br><span class="line">            <span class="comment">// 这里close 关闭了之后，只会使得 sever_listen 的连接数 -1，除非是关闭最后一个连接</span></span><br><span class="line">            <span class="comment">// 不然不会影响其他进程使用这个端口</span></span><br><span class="line">            close(sever_listen);</span><br><span class="line">            <span class="comment">// 建立循环，使得一次性多次输入时，服务端都能接收</span></span><br><span class="line">    		<span class="comment">// 如果没有建立循环，短时间内多次输入，服务端只能接收到一两句</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">char</span> tobuff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// recv 可能会出现错误，需要判断</span></span><br><span class="line">                <span class="comment">// 当revc 的返回值为 0 的时候，说明对方发了 fin </span></span><br><span class="line">                <span class="keyword">size_t</span> ret = recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                	<span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; is offline\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    <span class="comment">// 连接断了，需要把套接字先关闭并退出</span></span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s\n&quot;</span>, inet_ntoa(client.sin_addr), buff);</span><br><span class="line">                <span class="built_in">sprintf</span>(tobuff, <span class="string">&quot;I&#x27;ve recved your message: %s&quot;</span>, buff);</span><br><span class="line">                <span class="comment">// 发送的时候，不能用 sizeof，需要用 strlen，不然会连空白字符一起发过去</span></span><br><span class="line">                <span class="comment">// 这样对方收到的可能就是空白字符 </span></span><br><span class="line">                send(sockfd, tobuff, <span class="built_in">strlen</span>(tobuff), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;&lt;Parent&gt; : 什么也不干......\n&quot;);</span></span><br><span class="line">            <span class="comment">// 父进程关闭这个端口，只是使得这个端口的连接数少一个，并不会影响子进程继续连接这个端口</span></span><br><span class="line">            <span class="comment">// 反而会因为关闭这个端口，而使得程序更加的健壮</span></span><br><span class="line">            close(sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="1-client-c：客户端"><a href="#1-client-c：客户端" class="headerlink" title="1.client.c：客户端"></a>1.client.c：客户端</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个退出函数，以便设置老鼠夹子，捕捉 ctrl + c 信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s ip port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义老鼠夹子，捕捉 ctrl + c 信号</span></span><br><span class="line">    <span class="comment">// lagout 如果换成 SIG_IGN，则会使得 ctrl + c 信号变得没有效果，这个时候只能用 kill 退出程序</span></span><br><span class="line">    <span class="comment">// 可以设置多个”老鼠夹子“，以便捕获多种信号</span></span><br><span class="line">    signal(SIGINT, lagout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;input&gt; : &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, buff);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strlen</span>(buff)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 发送信息</span></span><br><span class="line">        send(sockfd, buff, <span class="built_in">strlen</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sending %s...\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="comment">// 接收信息</span></span><br><span class="line">        <span class="comment">// recv 会把当前有的数据先接收，没有的数据放在下次再接收，这样就会出现拆包问题。</span></span><br><span class="line">        <span class="comment">// 拆包问题：</span></span><br><span class="line">        <span class="comment">// 1. 数据量过大，自己可以接收的数据大小达不到这个量，就会被拆分；</span></span><br><span class="line">        <span class="comment">// 2. 网络延迟等原因，使得对方的数据发送不完整，recv 直接先返回了不完整的信息</span></span><br><span class="line">        <span class="comment">// 拆包解决方案：拿到信息后，先等着，直到数据完整了，recv 再返回</span></span><br><span class="line">        <span class="comment">// 粘包问题：</span></span><br><span class="line">        <span class="comment">// 两个数据包混在了一起，比如拆包问题出现后，</span></span><br><span class="line">        <span class="comment">// 下次再发送数据，recv 接收的数据，既有这次的数据，也有上次的数据。</span></span><br><span class="line">        <span class="comment">// 这两个问题是必须解决的，而且因为网络延迟等原因，无法保证只接收一个数据包。</span></span><br><span class="line">        <span class="comment">// 不能期望，对方发送的数据包，一定能完整的到到你手上</span></span><br><span class="line">        <span class="comment">// 一次 recv 没接收全信息，下次接收，是手动调用，不是自动调用</span></span><br><span class="line">        recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;Sever&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">        bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305220826.png" alt="image-20210209152704525"></p>
<blockquote>
<p>如果是云主机，需要去控制台中把对应的端口拉近安全组，使得这个端口允许被访问。</p>
<p>连接方式：<code>./client + IP地址 + 端口号</code></p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层协议</title>
    <url>/2021/01/10/0025.%20%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="网络应用程序的体系结构"><a href="#网络应用程序的体系结构" class="headerlink" title="网络应用程序的体系结构"></a>网络应用程序的体系结构</h2><h3 id="CS结构：客户端——服务端结构"><a href="#CS结构：客户端——服务端结构" class="headerlink" title="CS结构：客户端——服务端结构"></a>CS结构：客户端——服务端结构</h3><ul>
<li>微信、QQ、钉钉等</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223519.png" alt="image-20210213124310552" style="zoom:50%;"></li>
<li>客户端直接通过网络跟服务器进行交互，而服务器则为我们提供一些功能。 </li>
<li>比较常见，比如微信，都是先把信息发到服务器，再由服务器转发给目标人物</li>
<li>这个体系中的服务端，更多的时候，并不是一台机器，而是企业搭建的数据中心，然后组成虚拟服务器为客户服务，比如百度搜索服务。</li>
</ul>
<h3 id="P2P结构：端——端结构"><a href="#P2P结构：端——端结构" class="headerlink" title="P2P结构：端——端结构"></a>P2P结构：端——端结构</h3><ul>
<li><p>百度网盘等</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223536.png" alt="image-20210213124755785" style="zoom:50%;">
</li>
<li><p>可以把所有的用户通过这种服务连接在一起。两主机为对等方，其扩展性较强，可以做到流量密集。一方下载数据可能会从另一方那里下载。</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p><code>ISP</code>友好性很差，所有<code>ISP</code>都想限制<code>P2P</code>的流量，因为网络趋向于一个上下流不对等的情况。 </p>
<blockquote>
<p>虽然使用了上载流量，但不能给<code>ISP</code>网络提供商带来效益。</p>
</blockquote>
</li>
<li><p>安全性：因为是对等的，即无论是下载还是上传，都需要放开更大的权限，这就对安全性存在着一定的考验。</p>
</li>
<li><p>合适的激励</p>
</li>
</ul>
</li>
</ul>
<h3 id="进程间通信："><a href="#进程间通信：" class="headerlink" title="进程间通信："></a>进程间通信：</h3><ul>
<li><p>所有<code>CS</code>结构的网络应用程序，都是由成对的进程组构成；</p>
</li>
<li><p>在<code>P2P</code>结构中，发起通信的为客户端，等待服务的进程为服务器；</p>
<blockquote>
<p>本地的<code>进程间通信（IPC）</code>使用共享内存，共享信号，条件变量等。</p>
<p>这里讲的是两个不同主机之间的进程间通信。</p>
<p><code>P2P</code>并不像<code>CS</code>，有明确的客户端与服务端，所以谁发起，谁就是客户端</p>
</blockquote>
</li>
</ul>
<h3 id="进程与计算机网络之间的接口："><a href="#进程与计算机网络之间的接口：" class="headerlink" title="进程与计算机网络之间的接口："></a>进程与计算机网络之间的接口：</h3><ul>
<li><code>Socket</code>是应用程序与网络之间的<code>API</code>；</li>
<li>应用程序对于运输层的控制仅限于：<ul>
<li>选择运输层协议</li>
<li>设定参数</li>
</ul>
</li>
</ul>
<h3 id="进程寻址："><a href="#进程寻址：" class="headerlink" title="进程寻址："></a>进程寻址：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223547.png" alt="image-20210213130639520" style="zoom:50%;">

<h3 id="可供应用程序使用的运输服务："><a href="#可供应用程序使用的运输服务：" class="headerlink" title="可供应用程序使用的运输服务："></a>可供应用程序使用的运输服务：</h3><ul>
<li><p>应用程序服务要求：</p>
<ul>
<li><p>可靠数据传输（<code>TCP</code>）</p>
</li>
<li><p>吞吐量 </p>
</li>
<li><p>定时</p>
</li>
<li><p>安全性：避免传输的信息在网络上裸奔。</p>
<blockquote>
<p>像之前的程序，都没有考虑安全性，信息都是在网络上裸奔，只要劫持了该信息，就可以知道信息内容。</p>
</blockquote>
<blockquote>
<p>举例：比如要劫持某个人在网络的信息，可以做<code>wify</code>伪装（接入点伪装，这也是不推荐大家使用公共网络的原因），可以把自己<code>wify</code>的<code>SSID与密码</code>设置跟对方需要想要连接的<code>wify</code>相同，只要自己的热点信号比公共<code>wify</code>的信号强，则对方的网络会<code>优先选择</code>你的<code>wify</code>，这样对方的所有数据都会经由你的设备进入互联网，这个时候如果在你的设备上有一个<code>抓包</code>工具，就可以抓到对方的数据包，这样就可以对对方的数据进行<code>拆包解析</code>，从而查看对方的信息。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="应用程序的网络服务要求："><a href="#应用程序的网络服务要求：" class="headerlink" title="应用程序的网络服务要求："></a>应用程序的网络服务要求：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223557.png" alt="image-20210213132019302" style="zoom:50%;">

<ul>
<li>不同的选择决定选择<code>TCP</code>还是<code>UDP</code>。</li>
<li>文件传输、电子邮件、Web文档、即时讯息：<code>TCP</code>；</li>
</ul>
<h3 id="应用程序及其协议，支持的运输层协议："><a href="#应用程序及其协议，支持的运输层协议：" class="headerlink" title="应用程序及其协议，支持的运输层协议："></a>应用程序及其协议，支持的运输层协议：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223607.png" alt="image-20210213132318740" style="zoom:50%;">

<ul>
<li>文件传输也有使用<code>UDP</code>的，此时就出现了一个问题，即<code>UDP</code>能否实现可靠数据传输？理论上是可以的，可以在上层自己做一个判断，判断数据包是否完整，不完整则重发，再由<code>UDP</code>发送出去。</li>
</ul>
<h3 id="应用层协议定义："><a href="#应用层协议定义：" class="headerlink" title="应用层协议定义："></a>应用层协议定义：</h3><ul>
<li><p>交换报文类型，例如请求报文和响应报文</p>
</li>
<li><p>各种报文类型的<code>语法</code>，如报文中各个字段的定义以及这些字段的描述</p>
</li>
<li><p>字段的<code>语义</code>，即这些字段中包含信息的含义</p>
</li>
<li><p><code>同步</code>：一个进程何时以及如何发送报文，对报文进行响应的规则</p>
<blockquote>
<p>很多协议，包括后续的项目，都会把数据交互过程封装成一个类似协议的东西。</p>
</blockquote>
</li>
</ul>
<h2 id="WEB与HTTP协议："><a href="#WEB与HTTP协议：" class="headerlink" title="WEB与HTTP协议："></a>WEB与HTTP协议：</h2><h3 id="WEB服务的应用层协议："><a href="#WEB服务的应用层协议：" class="headerlink" title="WEB服务的应用层协议："></a>WEB服务的应用层协议：</h3><ul>
<li><p>HTTP（超文本传输协议，HyperText Transfer Protocol）</p>
</li>
<li><p>客户程序和服务器程序运行在不同的端系统中，通过交换<code>HTTP</code>报文进行会话 </p>
<blockquote>
<p>上网用的就是<code>HTTP</code>或者<code>HTTPS</code>。 </p>
</blockquote>
</li>
</ul>
<h3 id="WEB术语"><a href="#WEB术语" class="headerlink" title="WEB术语"></a>WEB术语</h3><ul>
<li><code>Web</code>页面（Web page，文档）：通过浏览器解析出来的源码</li>
<li>对象：一切皆对象</li>
<li><code>HTML</code>基本文件</li>
<li><code>URL</code>：统一资源定位服务，在<code>HTTP</code>中下载资源、访问资源，都是基于<code>URL</code>，通过这个服务，可以得知需要的资源放在什么地方。</li>
<li><code>Web</code>浏览器：替用户发起请求响应，收到响应后将其解析展示出来。</li>
<li><code>Web</code>服务器：安装在服务器上的<code>HTTPD</code>等，是一个应用程序，监听在80端口，等着用户发起请求报文，收到后解析出来，如果本地有相关资源或者数据，则读取出来并通过响应报文发回来，如果没有则会给用户发送<code>404</code>。</li>
</ul>
<h3 id="HTTP的请求-响应行为"><a href="#HTTP的请求-响应行为" class="headerlink" title="HTTP的请求-响应行为"></a>HTTP的请求-响应行为</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223622.png" alt="image-20210213210955646" style="zoom:50%;">

<ul>
<li>请求：请求报文</li>
<li>响应：响应报文，至于响应报文对不对，比如<code>404</code>等，都是在响应报文中定义的</li>
</ul>
<h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ul>
<li><p>底层使用了<code>TCP</code>协议</p>
</li>
<li><p><code>HTTP</code>协议不用担心数据丢失，也不用关注<code>TCP</code>在网络中的数据丢失和乱序故障等细节</p>
</li>
<li><p><code>HTTP</code>是一个无状态协议，<code>服务器不存储关于客户的状态信息</code></p>
<blockquote>
<p>即刚下载了一个文件，从新下载的时候，依旧照常下，<code>HTTP</code>不会记录已经下载了。</p>
<p>像平时出现的那种刚跟别人说想去哪旅游，一上网就被推送了，这种类似被监听了的现象，并不是<code>HTTP</code>的锅，而是<code>附加服务</code>，<code>HTTP</code>本身是一个无状态协议。</p>
</blockquote>
</li>
<li><p><code>HTTP</code>服务器总是处于打开状态，具有一个固定<code>IP</code></p>
</li>
<li><p><code>HTTP</code>使用了<code>CS</code>应用程序结构</p>
</li>
</ul>
<h3 id="非持续连接与持续连接"><a href="#非持续连接与持续连接" class="headerlink" title="非持续连接与持续连接"></a>非持续连接与持续连接</h3><ul>
<li><p>非持续连续也叫<code>短连接</code>，持续连接也叫<code>长连接</code></p>
</li>
<li><p><code>HTTP</code>客户进程发起一个到服务器的<code>TCP</code>连接，使用默认端口<code>8.0</code>，在服务器上和客户端上都有一个套接字与之对应；</p>
</li>
<li><p><code>HTTP</code>客户经它的套接字向服务器发送请求报文。报文中包好了要请求的对象；</p>
</li>
<li><p><code>HTTP</code>服务器接收该报文，从服务器上检索对象，在<code>HTTP</code>响应报文中封装该对象，并通过套接字发送</p>
</li>
<li><p><code>HTTP</code>服务器通知<code>TCP</code>断开<code>TCP</code>连接</p>
</li>
<li><p><code>HTTP</code>客户接收响应报文，<code>TCP</code>连接关闭</p>
</li>
<li><p>对于多个对象重复以上步骤 </p>
</li>
<li><p>三次握手连接连接如下：</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223631.png" alt="image-20210213212356884" style="zoom:50%;">

<blockquote>
<p><code>TCP</code>连接为什么是<code>三次握手</code>，而不是<code>二次握手</code>或者<code>四次握手</code>？</p>
</blockquote>
<ul>
<li><p>第三次握手中就包含了<code>请求数据</code>。</p>
</li>
<li><p>服务端在第三次握手之后开始检索数据，并发送</p>
</li>
<li><p><code>TCP</code>请求报文样式：</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223641.png" alt="image-20210213212712640" style="zoom:50%;">
</li>
<li><p>方法：请求方法，包括<code>get获取数据</code>，<code>post提交表单</code>，<code>head测试</code>，<code>put把本地数据放在远端</code>，<code>delete从远端删除数据 </code></p>
</li>
<li><p> <code>url</code>：要处理的资源的具体连接</p>
</li>
<li><p>版本：当前协议的版本 </p>
</li>
<li><p>首部字段名：请求的浏览器类型</p>
<blockquote>
<p>比如用<code>mac</code>系统下载<code>zoom</code>安装包，网络不会推送<code>win</code>版本，这是因为发送请求时，带了<code>浏览器类型</code>的原因。</p>
</blockquote>
</li>
<li><p>实体主体：真实的数据，比如上传数据，则把数据放在实体主体里面 </p>
</li>
<li><p><code>TCP</code>响应报文样式：</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223648.png" alt="image-20210213213643331" style="zoom:50%;">
</li>
<li><p>状态码：比如<code>404没有找到</code>，<code>200找到数据</code></p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223719.png" alt="image-20210213213819803" style="zoom:50%;">

</li>
</ul>
<h3 id="用户与服务器的交互——COOKIE"><a href="#用户与服务器的交互——COOKIE" class="headerlink" title="用户与服务器的交互——COOKIE"></a>用户与服务器的交互——COOKIE</h3><ul>
<li><p>在<code>HTTP</code>响应报文中的一个<code>cookie</code>首部行</p>
</li>
<li><p>在<code>HTTP</code>请求报文中的一个<code>cookie</code>首部行</p>
</li>
<li><p>在用户端由浏览器管理的<code>cookie</code>文件</p>
</li>
<li><p>位于<code>WEB</code>后端的一个数据库</p>
<blockquote>
<p>由于<code>cookie</code>，导致当你一开始搜索一个话题时，后续几天系统会不断自动推送与之相关的话题链接或者广告</p>
</blockquote>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223749.png" alt="image-20210213214339303" style="zoom:50%;">

</li>
</ul>
<blockquote>
<p>比如第一次进京东浏览书籍的时候，如果没有登录，京东服务器发现自身并无该账户的信息，则会发响应报文，并为该账户建立一个初始的<code>cookie</code>8888，并保存在本地中，当下次再进入京东的时候，<code>cookie</code>会自动检索本地中该账户的相关信息，包括曾经做过的所有操作，浏览了什么商品等等，然后针对这些操作为该账户推送相关的内容。然后这个时候如果注册并登录了账户，则该账户会与该<code>cookie8888</code>绑定在一起，该账户的所有信息都会与<code>cookie8888</code>绑定在一起。</p>
<p>上面是单个站点的情况，同时大部分信息都是由服务器存储，用于做数据分析。</p>
<p>而现在很多的商业模式是大家互相买数据，比如腾讯跟淘宝共享数据的话，则腾讯的用户就是淘宝的用户，这些用户在腾讯的所有操作都会被移植到淘宝，即<code>每个人都在网络裸奔</code>。</p>
</blockquote>
<h3 id="WEB缓存区（代理服务器）"><a href="#WEB缓存区（代理服务器）" class="headerlink" title="WEB缓存区（代理服务器）"></a>WEB缓存区（代理服务器）</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223802.png" alt="image-20210213215721744" style="zoom:50%;">

<ul>
<li>需要一个资源，并不一定需要从资源最原始的地方下载，可以把所有的请求都设置成为经过一个<code>WEB服务器</code>，如果<code>WEB服务器</code>没有该资源，则会帮忙从更上一级的<code>WEB服务器</code>请求资源。</li>
<li>可以在局域网中建立一个<code>WEB服务器</code>，然后把局域网中所有电脑的请求都设置成为经过该<code>WEB服务器</code>，这样所有的需要经过<code>WEB服务器</code>的时候，如果本地服务器中有，则直接给与发起请求的客户端，如果服务器没有，则<code>WEB服务器</code>会向更高一级发送请求，直到找到给资源，并保存在<code>WEB服务器</code>中，然后让发起请求方从<code>WEB服务器</code>中下载，下次再有客户端发送相同请求，则直接将该保存资源给与对方下载。</li>
<li><code>WEB服务器</code>中的资源可能会过期，所以为了避免过期，则该服务器与资源最原始的地方需要进行定期的沟通，避免过期。比如客户端发送一个请求响应，<code>WEB</code>服务器会发送一个<code>modify</code>的请求报文给资源最初的地方，如果没有修改，则会给<code>WEB服务器</code>返回一个空报文，通知<code>WEB服务器</code>直接给客户端下载即可；如果有修改更新，则会发送个<code>WEB服务器</code>一个修改更新版本。</li>
<li>WEB缓存器的优点：<ul>
<li>大大减少对客户请求的响应时间（从资源最初所在服务器响应变成本地服务器响应）</li>
<li>减少了机构的接入链路到因特网的通信量</li>
<li>从整体上大大减少因特网上的<code>WEB</code>流量，改善所有应用的性能。</li>
</ul>
</li>
</ul>
<h2 id="HTTP协议与HTTPS协议"><a href="#HTTP协议与HTTPS协议" class="headerlink" title="HTTP协议与HTTPS协议"></a>HTTP协议与HTTPS协议</h2><h3 id="HTTPS-SECURE-HTTP"><a href="#HTTPS-SECURE-HTTP" class="headerlink" title="HTTPS(SECURE HTTP)"></a>HTTPS(SECURE HTTP)</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223813.png" alt="image-20210214103820579" style="zoom:50%;">

<ul>
<li><p>与<code>HTTP</code>的区别就是中间多了一层<code>加密\解密</code>，避免在网络上裸奔</p>
</li>
<li><p><code>https</code>协议需要到<code>ca</code>申请证书，一般免费证书很少，需要交费（价格不便宜）</p>
</li>
<li><p><code>http</code>是超文本传输协议，信息是明文传输（容易被解密），<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议（能解密，较难）</p>
</li>
<li><p><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p>
<blockquote>
<p>小于<code>1024</code>的端口，称之为<code>周知端口</code>，即给全世界有名的系统服务开辟的端口，即<code>VIP</code>端口，类似<code>110</code>，只有<code>超管</code>才能用这些端口。</p>
</blockquote>
</li>
<li><p><code>http</code>的连接很简单，是无状态的</p>
</li>
<li><p><code>https</code>协议是由<code>ssl+http</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>http</code>协议安全</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223826.png" alt="image-20210214104805530" style="zoom: 33%;">

<ul>
<li>变化：把一条一条的短连接封装在一条<code>TCP</code>连接中，所有对象都封装在这一条连接中传输，这叫连接的复用。</li>
<li><code>HTTP</code>是一个短连接，数据传输完成后就会立马断开连接，一问一答。</li>
<li>每建立一个连接都会消耗一点资源，而如果在类似<code>百度</code>这种大型网站的情况下，一秒钟可能会建立<code>上亿</code>的连接，这样就会浪费极大的资源，这种情况可以考虑一条连接在数据传输完成后不会立马断开连接，使得后面如果其他客户端也要建立连接，可以直接使用该连接，而不用重新建立，浪费资源。</li>
<li><code>http/2</code>把多个对象封装在一起，由一条<code>TCP</code>直接连接传输过去，交给对方去解析。</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223836.png" alt="image-20210214105812431" style="zoom:33%;">

</li>
</ul>
<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><ul>
<li>现在使用较少，主要用在本地局域网。</li>
<li>现在变成了服务其他应用的功能，个人用户用的比较少</li>
<li>打开之后就类似于一个远程文件夹</li>
</ul>
<h3 id="FTP文本传输协议"><a href="#FTP文本传输协议" class="headerlink" title="FTP文本传输协议"></a>FTP文本传输协议</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223847.png" alt="image-20210214110215434" style="zoom:33%;">
</li>
<li><p>组成：本地文件系统，FTP服务器对应的远程文件系统，本地FTP客户端（提供给用户一些接口，可以是浏览器，也可以是终端等）</p>
</li>
<li><p>用户通过命令的形式登录远程服务器，查看有哪些需要用到的数据，再传输到本地使用；或者把本地的数据传输到远程服务器中。</p>
</li>
</ul>
<h3 id="FTP的TCP连接（双连接）"><a href="#FTP的TCP连接（双连接）" class="headerlink" title="FTP的TCP连接（双连接）"></a>FTP的TCP连接（双连接）</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223856.png" alt="image-20210214113243409" style="zoom:33%;">
</li>
<li><p>第一条连接（长连接）：控制连接，<code>一直存在</code>，该连接走<code>控制指令</code></p>
</li>
<li><p>第二条连接（短连接）：数据连接，<code>临时存在</code>，该连接走数据，数据传输完成，就断开该连接</p>
</li>
<li><p>好处：</p>
<ul>
<li>在这里，使用<code>TCP</code>的发起者是人，并不是浏览器，这也就意味着<code>FTP</code>并不会有<code>很多的连接</code>，所以，这个双连接不会有太多的成本，甚至可以说这点成本服务器是感知不到的，同时，也没有一个<code>FTP服务器</code>会支持特别多的<code>并发</code>，如果需要特别高的<code>并发</code>，也不会选择<code>FTP</code>，而是选择其他方案了。</li>
<li>双连接会使得业务实现变得更加简单。先不从安全性等方面考虑，如果只是简单的随便抓一条连接就来充当数据连接，一方面，如果数据丢失，不好找出谁是发起者；另一方面，从何时为传输停止时间考虑，如果不额外建立一条数据连接，单单用控制连接来充当数据连接，那控制连接需要是不是的做一个判断，判断是否已经传输完成，这样的操作成本更改，还不如用一短连接，数据传输完成就会发送对应信号通知已经传输完成。</li>
</ul>
<blockquote>
<p>为什么一定要双连接呢？在你需要传数据的时候，此时的控制连接是空着的，闲置的，那为什么不能直接用该控制连接传数据呢？</p>
</blockquote>
</li>
</ul>
<h3 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223907.png" alt="image-20210214120733270" style="zoom: 50%;">

<h3 id="FTP典型回答"><a href="#FTP典型回答" class="headerlink" title="FTP典型回答"></a>FTP典型回答</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210305223918.png" alt="image-20210214120755829" style="zoom: 50%;">

<h2 id="SMTP、POP3、IMAP协议（邮件）"><a href="#SMTP、POP3、IMAP协议（邮件）" class="headerlink" title="SMTP、POP3、IMAP协议（邮件）"></a>SMTP、POP3、IMAP协议（邮件）</h2><ul>
<li>早期的互联网主要业务是邮件。</li>
</ul>
<h3 id="SMTP简单邮件传输协议"><a href="#SMTP简单邮件传输协议" class="headerlink" title="SMTP简单邮件传输协议"></a>SMTP简单邮件传输协议</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084419.png" alt="image-20210214121350250" style="zoom:50%;">

<ul>
<li><p>用户 A 的代理：网页，邮件客户端等</p>
</li>
<li><p>由<code>SMTP</code>把信息通过<code>TCP</code>协议发送到<code>用户A的邮件服务器</code></p>
<blockquote>
<p>比方说本地用户为<code>126</code>，当<code>126</code>账户编辑好邮件点击发送时，本地客户端就会建立起一条连接，连接到<code>126服务器</code>上（底层是<code>TCP</code>连接，上层是<code>SMTP</code>协议），从应用层角度，会匹配账户跟密码，正确了才准许连接。</p>
<p>从底层<code>tcp</code>层面看，先建立一条<code>tcp</code>连接，再发送登录指令，依次发送账户跟密码的相关信息，正确了，这条连接才准许传输数据，再告诉应用层连接成功，应用层再把数据封装好，最后重新回到<code>tcp</code>连接中，把数据源源不断的发送到<code>126</code>服务器中。</p>
</blockquote>
</li>
<li><p>从用户 A 的代理发送过来的数据会先放在<code>任务队列</code>中排队，避免在满负荷的情况还继续工作从而崩溃。</p>
</li>
<li><p><code>用户A的邮件服务器</code>中会拆开数据包，查看数据的目的地以及是否合理等，都没问题了，才会发送给<code>用户B的邮件服务器</code>，然后等着客户端主动来提取数据，查看邮件。</p>
<blockquote>
<p>比方说上邮箱中选择接收所有邮件等类似操作，都是代理发起的请求，请求<code>用户B的邮件服务器</code>发送近期的的所有邮件。</p>
<p>而诸如对方一发送邮件，另一方就收到新邮件提示的原因，就是因为代理是频繁的访问<code>用户B的邮件服务器</code>，间隔时间较短，所以使得人们觉得，一方刚发送，另一方就收到通知。而这个过程，其实会耗费较多资源。</p>
</blockquote>
</li>
</ul>
<h2 id="DNS协议（域名解析符）"><a href="#DNS协议（域名解析符）" class="headerlink" title="DNS协议（域名解析符）"></a>DNS协议（域名解析符）</h2><ul>
<li><p>作用：将主域名与<code>IP</code>地址做一个转换，唯一值</p>
<blockquote>
<p>比如访问百度，需要知道百度的<code>IP</code>地址。</p>
<p>不管是真名还是别名，均能通过<code>DNS</code>得到真实的目的地。</p>
</blockquote>
</li>
<li><p>DNS 提供的服务</p>
<ul>
<li><p>主机名到<code>IP</code>地址的转换</p>
</li>
<li><p>主机别名</p>
</li>
<li><p>邮件服务器别名</p>
</li>
<li><p>负载均衡：将服务分散开，避免过于集中，从而导致负载过大。</p>
<blockquote>
<p>比方说，百度的服务肯定不止一个，因为如果只有一个的话，那很容易就因为高负荷而使得百度系统崩溃了。所以百度的域名后面应该牵扯到了很多的域名或者<code>IP地址</code>，而每个用户的请求都需要通过一套方案最终落到一个唯一的机器上，这就是<code>负载均衡</code>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="集中式DNS可能遇到的问题（即全球只有一个DNS服务器）"><a href="#集中式DNS可能遇到的问题（即全球只有一个DNS服务器）" class="headerlink" title="集中式DNS可能遇到的问题（即全球只有一个DNS服务器）"></a>集中式DNS可能遇到的问题（即全球只有一个DNS服务器）</h3><ul>
<li><p>单点故障：一个点出现问题，导致整个系统出了问题，应该避免。</p>
<blockquote>
<p>通过多次冗余（看似没用）的操作来维护。</p>
</blockquote>
</li>
<li><p>通信容量大</p>
</li>
<li><p>远距离集中式数据库，时延高</p>
</li>
<li><p>维护不易</p>
</li>
</ul>
<blockquote>
<p>设计应用时，<code>集中式</code>有好处，但也有<code>巨大的隐患</code>，所以，业务要低耦合，或者尽量不耦合，即没有过多的连续性，尽可能不依赖其他方面，这样哪怕一方面出故障了，也不会影响整个系统。</p>
</blockquote>
<h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><ul>
<li><p>根DNS服务器</p>
<ul>
<li>因特网上有13个</li>
</ul>
</li>
<li><p>顶级域DNS服务器（TLD、com、cn）</p>
</li>
<li><p>权威DNS服务器</p>
</li>
<li><p>本地DNS服务器</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084356.png" alt="image-20210214130322577" style="zoom:50%;">
</li>
<li><p>本地DNS可能有很多个，不止一个</p>
</li>
<li><p>请求主机发送请求，本地DNS发现本地没有，就一一查询根DNS、TLD、权威DNS等，直到查到域名，返回给本地DNS备份，并发送回请求主机。备份会保存一段时间。</p>
<blockquote>
<p>2、3、4、5、6、7是<code>迭代</code>还是<code>递归</code>呢？</p>
</blockquote>
</li>
</ul>
<h3 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306084408.png" alt="image-20210214131033596" style="zoom: 50%;">

<ul>
<li>该记录会保存一段时间，这段时间内都可以直接使用，如果超过该时间，则记录会被清除，请求主机如果想再次拿到该域名，需要重新查找。</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>如何通过应用层协议做到进程间通信/远程通信？</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC回顾</title>
    <url>/2021/01/17/0032.%20IPC%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IPC回顾"><a href="#IPC回顾" class="headerlink" title="IPC回顾"></a>IPC回顾</h1><ul>
<li><p>基于文件的IPC</p>
</li>
<li><p>基于共享内存的IPC</p>
<ul>
<li><p>竞争</p>
</li>
<li><p>同步：</p>
<ul>
<li><p>线程好处：增加并发性，增加实时的并行度，减少业务调度的成本（上下文切换的成本），线程之间是可以互相通信的，因为共享一个进程，方便很多</p>
</li>
<li><p>线程缺点：调试比较难，容易发生数据竞争，即有一个资源被多个线程非同步的访问</p>
</li>
<li><p>解决方法：</p>
<ul>
<li><p>程序设计概念上：</p>
<ul>
<li>比如设计一个全局变量，那大家都可以访问；如果把变量塞到线程函数中，那其他线程也就访问不到了</li>
</ul>
</li>
<li><p>线程同步：互斥、协程（go语言比较多，协同程序，就是一个线程或者进程，有着特定的功能——协调，即这个线程可以协调两个线程直接的事情！这个线程就只做协调这件事）、互斥锁、读写锁</p>
<ul>
<li><p>互斥锁：死锁问题（拿到资源之后，不释放这个资源）</p>
<blockquote>
<p>死锁问题，不一定是程序员写出来的，很可能是因为当前程序需要另外的资源，所以暂时不释放，而另一个程序刚好有对应的资源，但需要当前程序手中的资源，也不释放，导致双方均不释放资源、同时得不到对方的资源，就会产生死锁。</p>
<p>AB锁：典型的死锁拥抱，就是有个内锁跟外锁，如果顺序搞错，就死锁！</p>
<p>哲学家进餐问题：</p>
</blockquote>
</li>
<li><p>解决方法：鸵鸟策略，简单暴力高效，即拿到资源后，发现可能产生死锁，就释放了</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程并发：select、poll、epoll</p>
<ul>
<li>并发更多的是跟网络相关</li>
</ul>
</li>
<li><p>进程间通信：</p>
<ul>
<li>亲缘关系：同一个父进程，IPC有天然的优势</li>
<li>非亲缘关系：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><ul>
<li>前面一个命令是标准输入、后面是标准输出</li>
<li>liux中，前后是两个命令；在系统编程中，前后是两个进程，可以用户两个进程之间的通信</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;              /* Obtain O_* constant definitions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单向的数据通道，可用于进程间通信</p>
</li>
<li><p>pipefd[0]是读端、pipe[1]是写端 ，写端的数据，会先被内核缓存起来，直到被读走（即数据会从用户态下沉到内核态，但是不会写到磁盘中，当管道开始读的时候，会使用read引发一个系统调用）</p>
<blockquote>
<p>正常情况下，用户空间是没法读取一个文件的，文件是交给内核，由内核调用底层的文件系统再去磁盘上读取，而read只需到内核就可以了，不需要再继续深入了。、</p>
</blockquote>
</li>
<li><p>返回值：成功返回0，失败返回-1</p>
<blockquote>
<p>返回值说明，我们需要返回的东西不在返回值中，而是在数组中，即传出参数。就是直接把参数的地址当成传入参数传到函数中，函数中的任何修改都直接反应在其真实值中，这样函数结束后，就可以直接调用数组中的参数使用！</p>
</blockquote>
</li>
</ul>
<h3 id="pipe的应用"><a href="#pipe的应用" class="headerlink" title="pipe的应用"></a>pipe的应用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> cpid;</span><br><span class="line">    <span class="keyword">char</span> buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;string&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) &#123;    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>管道也是一个文件，如果父进程产生子进程之后，子进程关闭了管道文件，会不会使得父进程的管道文件也会被关闭吗？</p>
<blockquote>
<p>不会！因为是两个独立的，只不过该管道文件会被设置为由两个连接数，当子进程关闭了，只是连接数减一，如果连接数为0，才会关闭了整个管道文件。</p>
</blockquote>
</li>
<li><p>管道的两个进程不会共享内存！</p>
</li>
<li><p>linux中管道命令，其实就是基于这个函数</p>
</li>
</ul>
<h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>管道中，留从一个进程中来，或者到一个进程中去</li>
<li>通过创建一个管道打开一个进程，然后fork一个子进程，再调用shell来执行command，最后通过管道传回父进程中去，这样，父进程就可以通过管道拿到子进程的输出。</li>
<li>子进程的命令会通过管道输出，除非用了重定向！</li>
</ul>
<blockquote>
<p>ping：进程fork一个子进程，然后子进程去ping，此时父进程阻塞着，等待着子进程的死亡！而之所以父进程看得到子进程的ping，就是因为两个进程之间连着管道，父进程拿到了子进程的输出。</p>
</blockquote>
<ul>
<li><p>返回值： 是一个普通的标准IO流。</p>
<blockquote>
<p>用popen打开一个流，只能用pclose关闭，不能用fclose？</p>
</blockquote>
</li>
</ul>
<h2 id="匿名管道、命名管道"><a href="#匿名管道、命名管道" class="headerlink" title="匿名管道、命名管道"></a>匿名管道、命名管道</h2><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="shm：共享内存"><a href="#shm：共享内存" class="headerlink" title="shm：共享内存"></a>shm：共享内存</h3><h3 id="mmap：共享内存机制——映射"><a href="#mmap：共享内存机制——映射" class="headerlink" title="mmap：共享内存机制——映射"></a>mmap：共享内存机制——映射</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建了一个虚拟地址空间，起始的地址映射是通过addr来获得的，长度参数指定要映射的mmap的长度。如果addr是空的，内核则会自行选择一个地址用来创造mmap。如果addr不为空，则内核会依据该addr产生一个mmap映射</li>
<li>mmap性能优势在哪？为什么在进程通信里面可以做到更快？</li>
</ul>
<blockquote>
<p>shm 与 mmap：两者相似，但不同方向</p>
<ul>
<li>共享内存：把用户空间的一段内存映射到同一块、两个进程的不同段内存信息映射到同一块物理内存上面；</li>
<li>mmap：把一个文件映射到两个进程的不同的用户空间上，即两个进程各自在自己的空间中（不借用内核），读取空间就相当于读取这个文件</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义捕获错误</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error(msg) \</span></span><br><span class="line">           <span class="keyword">do</span> &#123; perror(msg); <span class="built_in">exit</span>(EXIT_FAILURE); &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>	 <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *addr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">off_t</span> offset, pa_offset;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">ssize_t</span> s;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || argc &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s file offset [length]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获得文件状态，这里是为了获得文件的大小</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>)           <span class="comment">/* To obtain file size */</span></span><br><span class="line">        handle_error(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    offset = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 页对齐</span></span><br><span class="line">    pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* offset for mmap() must be page aligned */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= sb.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;offset is past end of file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">4</span>) &#123;</span><br><span class="line">        length = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> (offset + length &gt; sb.st_size)</span><br><span class="line">            length = sb.st_size - offset;</span><br><span class="line">        <span class="comment">/* Can&#x27;t display bytes past end of file */</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">/* No length arg ==&gt; display to end of file */</span></span><br><span class="line">        length = sb.st_size - offset;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 让内核帮忙选地址，</span></span><br><span class="line">    addr = mmap(<span class="literal">NULL</span>, length + offset - pa_offset, PROT_READ,</span><br><span class="line">                MAP_PRIVATE, fd, pa_offset);</span><br><span class="line">    <span class="comment">// mmap出错返回的值</span></span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">        handle_error(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写文件，写进标准输出</span></span><br><span class="line">    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);</span><br><span class="line">    <span class="keyword">if</span> (s != length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">            handle_error(<span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;partial write&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 卸载</span></span><br><span class="line">    munmap(addr, length + offset - pa_offset);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此例子并无进程间通信 </li>
</ul>
<h2 id="信号量-sem"><a href="#信号量-sem" class="headerlink" title="信号量 sem"></a>信号量 sem</h2><ul>
<li><p>信号量，允许进程和线程去同步他们的操作（避免竞争）</p>
</li>
<li><p>信号量是一个大于等于 0 的整数，通过<code>sem_post</code>操作增加信号量的值，或者通过<code>sem_wait</code>操作来降低信号量的值。如果信号量为0，则<code>sem_wait</code>会被阻塞到，直到信号量大于0为止</p>
</li>
<li><p>信号量两个形式：命名信号量、匿名信号量</p>
</li>
<li><p><strong>（面试考点）PV操作：</strong>对应信号量的加/减</p>
<blockquote>
<p>锁实现的底层原理？怎么样才能实现一个锁？怎么能保证底层实现一个原子操作？<strong>CAS</strong>（比较与置换，会带着自己的预期去比较，如果不符合预期，就放弃继续循环！原子操作！！底层实现原子性操作的原理！！<strong>贼速度！！</strong>）。</p>
<p>在应用层的时候，如果要实现原子性，就必须得加锁，需要用到底层提供的锁的概念，这样效率比较低！</p>
<p>从应用层到底层，锁的原理其实都一样，就是效率问题！</p>
</blockquote>
</li>
</ul>
<h3 id="sem-init：初始化信号量"><a href="#sem-init：初始化信号量" class="headerlink" title="sem_init：初始化信号量"></a>sem_init：初始化信号量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">Link with -pthread.</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化一个未定义的信号量，并为其赋一个初始值</li>
<li>pshared：表明这个信号量是否可以在进程间或者线程间共享<ul>
<li>0：一个进程中的线程可以共享</li>
<li>非0：设置在一个共享内存中，进程间可以共享</li>
</ul>
</li>
</ul>
<h3 id="sem-open：打开命名信号量"><a href="#sem-open：打开命名信号量" class="headerlink" title="sem_open：打开命名信号量"></a>sem_open：打开命名信号量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;           /* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;        /* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">mode_t</span> mode, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">Link with -pthread.</span><br></pre></td></tr></table></figure>
<h3 id="sem-post：增加信号量的值"><a href="#sem-post：增加信号量的值" class="headerlink" title="sem_post：增加信号量的值"></a>sem_post：增加信号量的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line">Link with -pthread.</span><br></pre></td></tr></table></figure>
<ul>
<li>增加信号量的值，解锁操作</li>
<li>信号量 &gt; 0：sem_wait会被唤醒</li>
</ul>
<h3 id="sem-wait：降低信号量的值"><a href="#sem-wait：降低信号量的值" class="headerlink" title="sem_wait：降低信号量的值"></a>sem_wait：降低信号量的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">Link with -pthread.</span><br></pre></td></tr></table></figure>
<ul>
<li>sem_trywait</li>
<li>sem_timewait</li>
</ul>
<h3 id="semget：获得一个system-V的信号集"><a href="#semget：获得一个system-V的信号集" class="headerlink" title="semget：获得一个system V的信号集"></a>semget：获得一个system V的信号集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果key有一个私有的IPC或者不存在这个信号集合时，nsems个信号量会被创建为一个集合</li>
<li>当创建一个集合时，semget会初始化集合的数据结构体<code>semid_ds</code></li>
</ul>
<h3 id="semctl："><a href="#semctl：" class="headerlink" title="semctl："></a>semctl：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行一个控制操作，这个操作由cmd定义</p>
</li>
<li><p>cmd：</p>
<ul>
<li>IPC_STAT</li>
<li>IPC_SET</li>
<li>IPC_RMID</li>
<li>IPC_INFO等</li>
</ul>
</li>
</ul>
<h3 id="semop：操作"><a href="#semop：操作" class="headerlink" title="semop：操作"></a>semop：操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">size_t</span> nsops,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对信号量做一个操作</li>
<li>对选择的信号量做一个操作。每一个操作单元都是一个结构体，被定义在一个单个的信号量</li>
<li>如果sem_op是一个正数，这个信号量会被加到信号量集合中</li>
<li>如果sem_op等于0，则进程必须有读取这个集合的权限</li>
<li>如果sem_op小于0，则进程必须有修改这个集合的权限</li>
</ul>
<h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p><strong>PV操作</strong>：所谓的PV操作，就是加减资源</p>
<p>假设有十个进程，都要去三个打印机打印这个数据，那如果不做一个适当的同步操作，就会变成争夺三个打印机，即所谓的数据竞争。所以需要对资源做一个互斥访问， 实际上就是进程的互斥与同步的有效方式（PV操作），其底层就是信号量，信号量的值value就是资源的数量，每当有一个进程拿到打印机，就应该把资源数减一，变成两个打印机（P操作），如果三个打印机都被拿走了，其他进程就只能是阻塞着，等到资源被归还（V操作），资源数加一，然后又被阻塞的进程抢走，资源数再度变为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要使用semctl,需要自己实现这个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_sem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2021</span>);</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">if</span> ((sem_id = semget(key, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sem_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> sem_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.val = VALUE;</span><br><span class="line">    <span class="keyword">return</span> semctl(sem_id, <span class="number">0</span>, SETVAL, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源加一操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_P</span><span class="params">(<span class="keyword">int</span> sem_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuff</span>;</span></span><br><span class="line">    sbuff.sem_num = <span class="number">0</span>;</span><br><span class="line">    sbuff.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sbuff.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (semop(sem_id, &amp;sbuff, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源减一操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_V</span><span class="params">(<span class="keyword">int</span> sem_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sbuff</span>;</span></span><br><span class="line">    sbuff.sem_num = <span class="number">0</span>;</span><br><span class="line">    sbuff.sem_op = <span class="number">1</span>;</span><br><span class="line">    sbuff.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span> (semop(sem_id, &amp;sbuff, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sem_id;</span><br><span class="line">    <span class="keyword">if</span> ((sem_id = create_sem()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create_sem&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (init_sem(sem_id) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;init_sem&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_P(sem_id);</span><br><span class="line">        cnt++;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        sem_V(sem_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt = %d\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只有两个进程进程，用文件锁还可以，但是如果多个进程，比如三个，用锁的话效率就低了，应该用PV操作</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>系统创建一条队列，所有的信息都在队列中排队，每次都从队列中拿走一个或者插入</li>
</ul>
<h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对msgid做一个控制操作</li>
</ul>
<h3 id="msgop"><a href="#msgop" class="headerlink" title="msgop"></a>msgop</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个操作：<ul>
<li>发送</li>
<li>接收</li>
</ul>
</li>
</ul>
<h3 id="案例演示："><a href="#案例演示：" class="headerlink" title="案例演示："></a>案例演示：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">80</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">char</span> *prog_name, <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(msg, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s [options]\n&quot;</span>, prog_name);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Options are:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-s        send message using msgsnd()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-r        read message using msgrcv()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-t        message type (default is 1)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;-k        message queue key (default is 1234)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> qid, <span class="keyword">int</span> msgtype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    msg.mtype = msgtype;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    <span class="built_in">snprintf</span>(msg.mtext, <span class="keyword">sizeof</span>(msg.mtext), <span class="string">&quot;a message at %s&quot;</span>,</span><br><span class="line">             ctime(&amp;t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgsnd(qid, (<span class="keyword">void</span> *) &amp;msg, <span class="keyword">sizeof</span>(msg.mtext),</span><br><span class="line">               IPC_NOWAIT) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsnd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sent: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> qid, <span class="keyword">int</span> msgtype)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(qid, (<span class="keyword">void</span> *) &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), msgtype,</span><br><span class="line">               MSG_NOERROR | IPC_NOWAIT) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != ENOMSG) &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No message available for msgrcv()\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;message received: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> qid, opt;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">0</span>;               <span class="comment">/* 1 = send, 2 = receive */</span></span><br><span class="line">    <span class="keyword">int</span> msgtype = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> msgkey = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;srt:k:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                mode = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                mode = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                msgtype = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (msgtype &lt;= <span class="number">0</span>)</span><br><span class="line">                    usage(argv[<span class="number">0</span>], <span class="string">&quot;-t option must be greater than 0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">                msgkey = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                usage(argv[<span class="number">0</span>], <span class="string">&quot;Unrecognized option\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">        usage(argv[<span class="number">0</span>], <span class="string">&quot;must use either -s or -r option\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    qid = msgget(msgkey, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">2</span>)</span><br><span class="line">        get_msg(qid, msgtype);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        send_msg(qid, msgtype);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息队列可以用在多个进程。</li>
<li>也可以用在线程池，即线程中的线程都从消息队列取任务。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式</title>
    <url>/2021/01/18/0033.%20%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232732.png" alt="img"></p>
<blockquote>
<p>除了这几个，还有一个文件锁！</p>
</blockquote>
<p><strong>正文</strong></p>
<p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232739.png" alt="img"></p>
<p>Linux 内核提供了不少进程间通信的机制，我们来一起瞧瞧有哪些？</p>
<p><strong>管道</strong></p>
<p>如果你学过 Linux 命令，那你肯定很熟悉「|」这个竖线。</p>
<ul>
<li>$ps auxf | grep mysql</li>
</ul>
<p>上面命令行里的「|」竖线就是一个管道，它的功能是将前一个命令（ps auxf）</p>
<p>的输出，作为后一个命令（grep mysql）的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。</p>
<p>同时，我们得知上面这种管道是没有名字，所以「|」表示的管道称为匿名管道，用完了就销毁。</p>
<p>管道还有另外一个类型是命名管道，也被叫做 FIFO，因为数据是先进先出的传输方式。</p>
<p>在使用命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：</p>
<ul>
<li>$mkfifo myPipe</li>
</ul>
<p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是</p>
<p>以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思：</p>
<ul>
<li>$ls -l prw-r–r–. 1 root root 0 Jul 17 02:45 myPipe</li>
</ul>
<p>接下来，我们往 myPipe 这个管道写入数据：</p>
<ul>
<li>$ echo”hello”&gt; myPipe // 将数据写进管道 // 停住了 …</li>
</ul>
<p>你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。</p>
<p>于是，我们执行另外一个命令来读取这个管道里的数据：</p>
<ul>
<li>$ cat &lt; myPipe // 读取管道里的数据 hello</li>
</ul>
<p>可以看到，管道里的内容被读取出来了，并打印在了终端上，另外一方面，echo 那个命令也正常退出了。</p>
<p>我们可以看出，管道这种通信方式效率低，不适合进程间频繁地交换数据。当然，它的好处，自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p>
<blockquote>
<p>那管道如何创建呢，背后原理是什么？</p>
</blockquote>
<p>匿名管道的创建，需要通过下面这个系统调用：</p>
<ul>
<li>intpipe( intfd[ 2])</li>
</ul>
<p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符</p>
<p>fd[0]，另一个是管道的写入端描述符 fd[1]。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232745.png" alt="img"></p>
<p>其实，所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p>
<p>看到这，你可能会有疑问了，这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p>
<p>我们可以使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个「 fd[0] 与 fd[1]」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232758.png" alt="img"></p>
<p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p>
<ul>
<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；</li>
<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232806.png" alt="img"></p>
<p>所以说如果需要双向通信，则应该创建两个管道。</p>
<p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。</p>
<p>在 shell 里面执行 A | B命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232811.png" alt="img"></p>
<p>所以说，在 shell 里通过「|」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。</p>
<p>我们可以得知，对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p>
<p>另外，对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p>
<p>不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong></p>
<p>前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。</p>
<p>对于这个问题，消息队列的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>
<p>再来，消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>
<p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>但邮件的通信方式存在不足的地方有两点，一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点。</p>
<p>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p>
<p><strong>共享内存</strong></p>
<p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232823.png" alt="img"></p>
<p><strong>信号量</strong></p>
<p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。</p>
<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>
<ul>
<li>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232828.png" alt="img"></p>
<p>具体的过程如下：</p>
<ul>
<li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li>
<li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li>
<li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li>
</ul>
<p>可以发现，信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p>
<p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p>
<p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232839.png" alt="img"></p>
<p>具体过程：</p>
<ul>
<li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li>
<li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li>
<li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li>
</ul>
<p>可以发现，信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。</p>
<p><strong>信号</strong></p>
<p>上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</p>
<p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 Java 的区别。</p>
<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号：</p>
<ul>
<li>$kill-l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX</li>
</ul>
<p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p>
<ul>
<li>Ctrl+C 产生 SIGINT 信号，表示终止该进程；</li>
<li>Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束；</li>
</ul>
<p>如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p>
<p>信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<ol>
<li>执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</li>
<li>捕捉信号。我们 可以为信号定义一个信号处理函数。 当信号发生时，我们就执行相应的信号处理函数。</li>
<li>忽 略信号 。 当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。 有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们用于在任何时候中断或结束某一进程。</li>
</ol>
<p><strong>Socket</strong>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。我们来看看创建 socket 的系统调用：intsocket( intdomain, inttype, intprotocal)三个参数分别代表：domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL/AF_UNIX 用于本机；type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可；根据创建 socket 类型的不同，通信的方式也就不同：实现 TCP 字节流通信：socket 类型是 AF_INET 和 SOCK_STREAM；实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；实现本地进程间通信：「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；接下来，简单说一下这三种通信的编程模式。针对 TCP 协议通信的 socket 编程模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232846.png" alt="img"></p>
<p>服务端和客户端初始化 socket，得到文件描述符；服务端调用 bind，将绑定在 IP 地址和端口;服务端调用 listen，进行监听；服务端调用 accept，等待客户端连接；客户端调用 connect，向服务器端的地址和端口发起连接请求；服务端 accept 返回用于传输的 socket 的文件描述符；客户端调用 write 写入数据；服务端调用 read 读取数据；客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。针对 UDP 协议通信的 socket 编程模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210330232900.png" alt="img"></p>
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。针对本地进程间通信的 socket 编程模型本地 socket 被用于在同一台主机上进程间通信的场景：本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。</p>
<p><strong>总结</strong>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中唯一的异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：互斥的方式，可保证任意时刻只有一个线程访问共享资源；同步的方式，可保证线程 A 应在线程 B 之前执行；</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2021/02/04/0042.%20%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-力扣6117：合并二叉树"><a href="#1-力扣6117：合并二叉树" class="headerlink" title="1. 力扣6117：合并二叉树"></a>1. 力扣6117：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417101750231.png" alt="image-20210417101750231"></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><h4 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h4><ul>
<li>新建一棵二叉树，每棵树的节点为原本两棵的节点之和</li>
<li>递归链接新树的左右两节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        TreeNode *NewNode = <span class="keyword">new</span> TreeNode(root1-&gt;val + root2-&gt;val);</span><br><span class="line">        NewNode-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        NewNode-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> NewNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-力扣226：翻转二叉树"><a href="#2-力扣226：翻转二叉树" class="headerlink" title="2. 力扣226：翻转二叉树"></a>2. 力扣226：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417102725298.png" alt="image-20210417102725298"></p>
<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>分别提取节点的左右两个节点，交换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode *right = invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-力扣104：二叉树的最大深度"><a href="#3-力扣104：二叉树的最大深度" class="headerlink" title="3. 力扣104：二叉树的最大深度"></a>3. 力扣104：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417103047194.png" alt="image-20210417103047194"></p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>广搜，直到最底层</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode *tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-力扣101：-对称二叉树"><a href="#4-力扣101：-对称二叉树" class="headerlink" title="4. 力扣101： 对称二叉树"></a>4. 力扣101： <a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417103551155.png" alt="image-20210417103551155"></p>
<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><ul>
<li><p>递归：把根节点复制一份，每次判断根节点的左节点与根节点的右节点</p>
</li>
<li><p>广搜、迭代：每次连续入队的两个节点，分别为左子树的左节点+右子树的右节点，或者左子树的右节点+右子树的左节点，只要这两个里面的值不同，立马报错</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bool check(TreeNode *p, TreeNode *q) &#123;</span></span><br><span class="line"><span class="comment">        if (!p &amp;&amp; !q) return true;</span></span><br><span class="line"><span class="comment">        if (!p || !q) return false;</span></span><br><span class="line"><span class="comment">        return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode *&gt; tmp;</span><br><span class="line">        tmp.push(p), tmp.push(q);</span><br><span class="line">        <span class="keyword">while</span> (!tmp.empty()) &#123;</span><br><span class="line">            TreeNode *tmp1 = tmp.front(); </span><br><span class="line">            tmp.pop();</span><br><span class="line">            TreeNode *tmp2 = tmp.front(); </span><br><span class="line">            tmp.pop();</span><br><span class="line">            <span class="keyword">if</span> (!tmp1 &amp;&amp; !tmp2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((!tmp1 || !tmp2) || (tmp1-&gt;val != tmp2-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tmp.push(tmp1-&gt;left);</span><br><span class="line">            tmp.push(tmp2-&gt;right);</span><br><span class="line">            tmp.push(tmp1-&gt;right);</span><br><span class="line">            tmp.push(tmp2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-力扣543：-二叉树的直径"><a href="#5-力扣543：-二叉树的直径" class="headerlink" title="5. 力扣543： 二叉树的直径"></a>5. 力扣543： <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417104944972.png" alt="image-20210417104944972"></p>
<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>维护一个全局变量res，用来得出最大的直径</li>
<li>节点直径 = 左子树深度 + 右子树深度 + 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = deepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> R = deepth(root-&gt;right);</span><br><span class="line">        res = max(res, L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max(L, R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">        deepth(root);</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-力扣114：二叉树展开为链表"><a href="#6-力扣114：二叉树展开为链表" class="headerlink" title="6. 力扣114：二叉树展开为链表"></a>6. 力扣114：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417110449201.png" alt="image-20210417110449201"></p>
<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><ul>
<li>找到当前节点的前驱节点</li>
<li>把前驱节点的下个节点设置为当前节点的后继节点</li>
<li>把当前节点的左孩子设置为右孩子</li>
<li>把当前节点更新为当前节点的右孩子，循环</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                TreeNode *next = cur-&gt;left;</span><br><span class="line">                TreeNode *pred = next;</span><br><span class="line">                <span class="keyword">while</span> (pred-&gt;right) pred = pred-&gt;right;</span><br><span class="line">                pred-&gt;right = cur-&gt;right;</span><br><span class="line">                cur-&gt;right = next;</span><br><span class="line">                cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-力扣105：从前序与中序遍历序列构造二叉树"><a href="#7-力扣105：从前序与中序遍历序列构造二叉树" class="headerlink" title="7. 力扣105：从前序与中序遍历序列构造二叉树"></a>7. 力扣105：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417112657044.png" alt="image-20210417112657044"></p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!preorder.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt;s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preVal = preorder[i];</span><br><span class="line">            TreeNode *tmp = s.top();</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;val != inorder[index]) &#123;</span><br><span class="line">                tmp-&gt;left = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                s.push(tmp-&gt;left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top()-&gt;val == inorder[index]) &#123;</span><br><span class="line">                    tmp = s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp-&gt;right = <span class="keyword">new</span> TreeNode(preVal);</span><br><span class="line">                s.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8-力扣538：把二叉搜索树转换为累加树"><a href="#8-力扣538：把二叉搜索树转换为累加树" class="headerlink" title="8. 力扣538：把二叉搜索树转换为累加树"></a>8. 力扣538：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417143130100.png" alt="image-20210417143130100"></p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>倒着中序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        convertBST(root-&gt;right);</span><br><span class="line">        root-&gt;val += tmp;</span><br><span class="line">        tmp = root-&gt;val;</span><br><span class="line">        convertBST(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-力扣236：二叉树的最近公共祖先"><a href="#9-力扣236：二叉树的最近公共祖先" class="headerlink" title="9. 力扣236：二叉树的最近公共祖先"></a>9. 力扣236：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417143427501.png" alt="image-20210417143427501"></p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>深搜</li>
<li>左孩子存在 || 右孩子存在 || 根节点的值等于p (q) 的值 </li>
<li>判断是否是共同父节点：<ul>
<li>左孩子真 &amp;&amp; 右孩子真</li>
<li>当前节点的值等于p（q）的值 &amp;&amp; 左（右）孩子真 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> left = dfs(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> right = dfs(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((left &amp;&amp; right) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (left || right))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-力扣102：二叉树的层序遍历"><a href="#10-力扣102：二叉树的层序遍历" class="headerlink" title="10. 力扣102：二叉树的层序遍历"></a>10. 力扣102：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417144421058.png" alt="image-20210417144421058"></p>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ul>
<li>广搜，设置一个标志，用来标识每一层有多少个节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_size = q.size();</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp_size; i++) &#123;</span><br><span class="line">                TreeNode *tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                res.back().push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-1-力扣337：打家劫舍-III"><a href="#11-1-力扣337：打家劫舍-III" class="headerlink" title="11_1. 力扣337：打家劫舍 III"></a>11_1. 力扣337：<a href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417145204368.png" alt="image-20210417145204368"></p>
<h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>动态规划的思路，不过是用树的形式体现</li>
<li>结构体，存放”选当前节点“， 与”不选当前节点“</li>
<li>深搜，每次先把左右孩子的情况先深搜准备好</li>
<li>处理当前节点：<ul>
<li>选当前节点：左孩子不选+右孩子不选+当前节点的价值</li>
<li>不选当前节点：左孩子选与不选中的最大值 + 右孩子选与不选中的最大值</li>
</ul>
</li>
<li>在结果节点中选择两者最大值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> select;</span><br><span class="line">    <span class="keyword">int</span> notselect;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node <span class="title">DFS</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> l = DFS(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = DFS(root-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> select = root-&gt;val + l.notselect + r.notselect;</span><br><span class="line">        <span class="keyword">int</span> notselect = max(l.select, l.notselect) + max(r.select, r.notselect);</span><br><span class="line">        <span class="keyword">return</span> &#123;select, notselect&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        Node res = DFS(root);</span><br><span class="line">        <span class="keyword">return</span> max(res.select, res.notselect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-力扣213：打家劫舍-II"><a href="#11-2-力扣213：打家劫舍-II" class="headerlink" title="11_2. 力扣213：打家劫舍 II"></a>11_2. 力扣213：<a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417150343892.png" alt="image-20210417150343892"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ul>
<li>动态规划，当前节点的值从上个节点以及上上个节点的值比较得出</li>
<li>因为是围成一个圈，所以，可以设置两个dp，一个为有头没尾，一个为有尾无头，最后比较最后一个值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res_t1(size), res_t2(size);</span><br><span class="line">        res_t1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        res_t1[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        res_t2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) res_t1[i] = max(res_t1[i - <span class="number">1</span>], res_t1[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">            res_t2[i] = max(res_t2[i - <span class="number">1</span>], res_t2[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(res_t1[size - <span class="number">2</span>], res_t2[size - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-力扣198：打家劫舍"><a href="#11-3-力扣198：打家劫舍" class="headerlink" title="11_3. 力扣198：打家劫舍"></a>11_3. 力扣198：<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417151104983.png" alt="image-20210417151104983"></p>
<h3 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>动态规划，当前节点的值从上一个点以及上上个点得出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre[<span class="number">2</span>], cur;</span><br><span class="line">        pre[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        pre[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        cur = pre[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            cur = max(pre[<span class="number">0</span>] + nums[i], pre[<span class="number">1</span>]);</span><br><span class="line">            pre[<span class="number">0</span>] = pre[<span class="number">1</span>];</span><br><span class="line">            pre[<span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="12-力扣437：-路径总和-III"><a href="#12-力扣437：-路径总和-III" class="headerlink" title="12. 力扣437： 路径总和 III"></a>12. 力扣437：<a href="https://leetcode-cn.com/problems/path-sum-iii/"> 路径总和 III</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417151337157.png" alt="image-20210417151337157"></p>
<h3 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>深搜：根节点的数量 + 左孩子的数量 + 右孩子的数量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = root-&gt;val == sum;</span><br><span class="line">        cnt += DFS(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        cnt += DFS(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? DFS(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="13-力扣98：-验证二叉搜索树"><a href="#13-力扣98：-验证二叉搜索树" class="headerlink" title="13. 力扣98： 验证二叉搜索树"></a>13. 力扣98： <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></h2><p><img src="/2021/02/04/0042/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417152033844.png" alt="image-20210417152033844"></p>
<h3 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>中序遍历，边遍历边比较</li>
<li>保存上一个节点的值，便于比较</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/02/04/0043.%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-1-力扣121：-买卖股票的最佳时机"><a href="#1-1-力扣121：-买卖股票的最佳时机" class="headerlink" title="1_1. 力扣121： 买卖股票的最佳时机"></a>1_1. 力扣121：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/"> 买卖股票的最佳时机</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417152650430.png" alt="image-20210417152650430"></p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>维护两个变量，一个为到当前位置为止的最小值，另一个为（当前价值 - 最小值）的最大值</li>
<li>遍历一遍数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mmin = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            ans = max(ans, prices[i] - mmin);</span><br><span class="line">            mmin = min(mmin, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-力扣122：买卖股票的最佳时机-II"><a href="#1-2-力扣122：买卖股票的最佳时机-II" class="headerlink" title="1_2. 力扣122：买卖股票的最佳时机 II"></a>1_2. 力扣122：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417154922023.png" alt="image-20210417154922023"></p>
<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><ul>
<li><h3 id="贪心："><a href="#贪心：" class="headerlink" title="贪心："></a>贪心：</h3><ul>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417155305385.png" alt="image-20210417155305385"></li>
</ul>
</li>
<li><h3 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h3><ul>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417155412729.png" alt="image-20210417155412729"></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贪心：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) ans += prices[i] - prices[i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>], dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-力扣309：最佳买卖股票时机含冷冻期"><a href="#1-3-力扣309：最佳买卖股票时机含冷冻期" class="headerlink" title="1_3.力扣309：最佳买卖股票时机含冷冻期"></a>1_3.力扣309：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417170237891.png" alt="image-20210417170237891"></p>
<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417170317621.png" alt="image-20210417170317621"></p>
<p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417170332846.png" alt="image-20210417170332846"></p>
<p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417170343534.png" alt="image-20210417170343534"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(f[size <span class="number">-1</span>][<span class="number">1</span>], f[size - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-力扣53：最大子序和：最大子序和"><a href="#2-力扣53：最大子序和：最大子序和" class="headerlink" title="2. 力扣53：最大子序和：最大子序和"></a>2. 力扣53：最大子序和：<a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417160424241.png" alt="image-20210417160424241"></p>
<h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>维护两个变量：<ul>
<li>now：从开头加到现在的最大值</li>
<li>ans：当前值与ans的最大值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            now = max(now + nums[i], nums[i]);</span><br><span class="line">            ans = max(ans, now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-力扣70：爬楼梯"><a href="#3-力扣70：爬楼梯" class="headerlink" title="3.力扣70：爬楼梯"></a>3.力扣70：<a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417160810871.png" alt="image-20210417160810871"></p>
<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>简单的递推</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">50</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] + ans[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-力扣338：比特位计数"><a href="#4-力扣338：比特位计数" class="headerlink" title="4. 力扣338：比特位计数"></a>4. 力扣338：<a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417160934265.png" alt="image-20210417160934265"></p>
<h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><ul>
<li><strong>当前值</strong>每次与<strong>当前值 - 1</strong>与运算，只要非0， 就说明有一个1；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                tmp &amp;= (tmp - <span class="number">1</span>); </span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.emplace_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-力扣406：根据身高重建队列"><a href="#5-力扣406：根据身高重建队列" class="headerlink" title="5. 力扣406：根据身高重建队列"></a>5. 力扣406：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417161427572.png" alt="image-20210417161427572"></p>
<h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>从高位往地位排序</li>
<li>高个子看不到矮个子，所以根据前面有多少人比它高来插入即可</li>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417161800311.png" alt="image-20210417161800311"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(people.begin(), people.end(), cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> person : people) &#123;</span><br><span class="line">            res.insert(res.begin() + person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-力扣64：最小路径和"><a href="#5-力扣64：最小路径和" class="headerlink" title="5. 力扣64：最小路径和"></a>5. 力扣64：<a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417162053510.png" alt="image-20210417162053510"></p>
<h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>除了第一行与第一列，其他位置的值，均是从当前位置的上方或者左方中，取一个最小值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">205</span>][<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = dp[<span class="number">1</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-力扣647：回文子串"><a href="#6-力扣647：回文子串" class="headerlink" title="6. 力扣647：回文子串"></a>6. 力扣647：<a href="https://leetcode-cn.com/problems/palindromic-substrings/">回文子串</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417162414670.png" alt="image-20210417162414670"></p>
<h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>马拉车算法</li>
<li>通过马拉车算法得出新子串，算出半径，直接把半径 /  2的结果相加，就是最终结果</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_new_string</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ns = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            (ns += s[i]) += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ns;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ns = get_new_string(s);</span><br><span class="line">        <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[ns.size()], c;</span><br><span class="line">        r[<span class="number">0</span>] = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; ns.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= c + r[c]) r[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r[i] = min(c + r[c] - i, r[<span class="number">2</span> * c - i]);</span><br><span class="line">            <span class="keyword">while</span> (i - r[i] &gt;= <span class="number">0</span> &amp;&amp; ns[i - r[i]] == ns[i + r[i]]) r[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + r[i] &gt; c + r[c]) c = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ns[i]; i++) &#123;</span><br><span class="line">            res += (r[i] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-力扣62：不同路径"><a href="#7-力扣62：不同路径" class="headerlink" title="7. 力扣62：不同路径"></a>7. 力扣62：<a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417163821100.png" alt="image-20210417163821100"></p>
<h3 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>动态规划：<ul>
<li>第一行跟第一列初始化为1</li>
<li>其他位置为当前位置的上方+左方</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8-力扣279：完全平方数"><a href="#8-力扣279：完全平方数" class="headerlink" title="8.力扣279：完全平方数"></a>8.力扣279：<a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417164034945.png" alt="image-20210417164034945"></p>
<h3 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>平方数最小为1，每个dp初始化为1的数量</li>
<li>平方数最大不会超过目标值</li>
<li>因为不限数量，转换为无限背包问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] = min(dp[j - i * i] + <span class="number">1</span>, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-力扣621：任务调度器"><a href="#9-力扣621：任务调度器" class="headerlink" title="9.力扣621：任务调度器"></a>9.力扣621：<a href="https://leetcode-cn.com/problems/task-scheduler/">任务调度器</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417170922971.png" alt="image-20210417170922971"></p>
<h3 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>构造，筒思想</li>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417183251794.png" alt="image-20210417183251794"></li>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417183309579.png" alt="image-20210417183309579"></li>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417183329077.png" alt="image-20210417183329077"></li>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417183342870.png" alt="image-20210417183342870"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : tasks) res[ch]++;</span><br><span class="line">        <span class="comment">// 最多的执行次数</span></span><br><span class="line">        <span class="keyword">int</span> Ctime_max = max_element(res.begin(), res.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;u, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;v) &#123; </span><br><span class="line">            <span class="keyword">return</span> u.second &lt; v.second;</span><br><span class="line">        &#125;)-&gt;second;</span><br><span class="line">        <span class="comment">// 具有最多执行次数的任务数量</span></span><br><span class="line">        <span class="keyword">int</span> Cnum_max = accumulate(res.begin(), res.end(), <span class="number">0</span>, [=](<span class="keyword">int</span> acc, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;u) &#123;</span><br><span class="line">            <span class="keyword">return</span> acc+ (u.second == Ctime_max);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> max((Ctime_max - <span class="number">1</span>) * (n + <span class="number">1</span>) + Cnum_max, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tasks.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-力扣139：单词拆分"><a href="#10-力扣139：单词拆分" class="headerlink" title="10.力扣139：单词拆分"></a>10.力扣139：<a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417183851940.png" alt="image-20210417183851940"></p>
<h3 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>dp[i]为以 i 结尾的字符串中，能否全部组成存在的字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : wordDict) &#123;</span><br><span class="line">            words.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; words.find(s.substr(j, i - j)) != words.end()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="11-力扣416：分割等和子集"><a href="#11-力扣416：分割等和子集" class="headerlink" title="11. 力扣416：分割等和子集"></a>11. 力扣416：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417184816336.png" alt="image-20210417184816336"></p>
<h3 id="思路：-13"><a href="#思路：-13" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>如果总和为奇数，则不能分割</li>
<li>如果最大的元素 &gt; sum / 2，则不能分割</li>
<li>dp一维数组，01背包，每次输入一个元素，只要<code>dp[j] || dp[j - nums[i]] || nums[i] == j</code>有一个为<code>true</code>，则<code>d[j] = true</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">20005</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> nums_max = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> || size &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums_max &gt; sum / <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] || dp[j - nums[i]] || nums[i] == j) dp[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[sum / <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="12-力扣300：最长递增子序列"><a href="#12-力扣300：最长递增子序列" class="headerlink" title="12. 力扣300：最长递增子序列"></a>12. 力扣300：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417191644938.png" alt="image-20210417191644938"></p>
<h3 id="思路：-14"><a href="#思路：-14" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>方式一：以 i 结尾，当前的最长递增子序列</li>
<li>方式二：维护一个lens数组，下标对应长度，值对应当前长度的最大值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> lens[<span class="number">2505</span>];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lens[mid] &lt; target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(lens, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2505</span>);</span><br><span class="line">        lens[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = binary_search(<span class="number">0</span>, size + <span class="number">1</span>, nums[i]);</span><br><span class="line">            lens[tmp + <span class="number">1</span>] = nums[i];</span><br><span class="line">            res = max(tmp + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="13-力扣221：最大正方形"><a href="#13-力扣221：最大正方形" class="headerlink" title="13. 力扣221：最大正方形"></a>13. 力扣221：<a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417192133690.png" alt="image-20210417192133690"></p>
<h3 id="思路：-15"><a href="#思路：-15" class="headerlink" title="思路："></a>思路：</h3><ul>
<li><p>从左上角到右下角移动</p>
</li>
<li><p>第一行与第一列初始化</p>
</li>
<li><p>其他的位置，为上方、左方、左上方的最小值 + 1</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                res = max(res, dp[<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                res = max(res, dp[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                    res = max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="14-力扣5：最长回文子串"><a href="#14-力扣5：最长回文子串" class="headerlink" title="14. 力扣5：最长回文子串"></a>14. 力扣5：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417192957187.png" alt="image-20210417192957187"></p>
<h3 id="思路：-16"><a href="#思路：-16" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>马拉车算法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_new_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ns = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            (ns += s[i]) += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ns;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ns = get_new_string(s);</span><br><span class="line">        <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>[ns.size()], c;</span><br><span class="line">        r[<span class="number">0</span>] = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ns.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= c + r[c]) r[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r[i] = min(c + r[c] - i, r[<span class="number">2</span> * c - i]);</span><br><span class="line">            <span class="keyword">while</span> (i - r[i] &gt;= <span class="number">0</span> &amp;&amp; ns[i - r[i]] == ns[i + r[i]]) r[i]++;</span><br><span class="line">            <span class="keyword">if</span> (i + r[i] &gt; c + r[c]) c = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ns[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt;= r[i]) <span class="keyword">continue</span>;</span><br><span class="line">            ans = r[i];</span><br><span class="line">            ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - r[i] + <span class="number">1</span>; j &lt; i + r[i]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ret += ns[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="15-力扣494：目标和"><a href="#15-力扣494：目标和" class="headerlink" title="15. 力扣494：目标和"></a>15. 力扣494：<a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417194837730.png" alt="image-20210417194837730"></p>
<h3 id="思路：-17"><a href="#思路：-17" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>如果最大值小于目标绝对值，返回0</li>
<li>因为可加可减，所以结果事存在负数的，整个dp二维数组向右边平移，保证下标不会出现负数</li>
<li>dp的状态转移：<ul>
<li>当前<code>dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]];</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">25</span>][<span class="number">2010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="built_in">abs</span>(S)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>) dp[<span class="number">0</span>][<span class="number">1005</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>] + <span class="number">1005</span>] = <span class="number">1</span>;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1005</span> - nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1005</span> - sum; j &lt;= <span class="number">1005</span> + sum; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> l = (j - nums[i]) &gt;= <span class="number">0</span> ? j - nums[i] : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> r = (j + nums[i]) &lt;= <span class="number">1005</span> + sum ? j + nums[i] : <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][l] + dp[i - <span class="number">1</span>][r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>][<span class="number">1005</span> + S];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="16-力扣322：零钱兑换"><a href="#16-力扣322：零钱兑换" class="headerlink" title="16. 力扣322：零钱兑换"></a>16. 力扣322：<a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417195452441.png" alt="image-20210417195452441"></p>
<h3 id="思路：-18"><a href="#思路：-18" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>之前的dp，是以零钱种类为外部循环，这里反过来，以零钱种类为内部循环，当所有的价格大于零钱值是，判断dp进行转移<code>dp[i] = min(dp[i], dp[i - coins[j]] + 1);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">10005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = coins.size();</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="17-力扣55：跳跃游戏"><a href="#17-力扣55：跳跃游戏" class="headerlink" title="17. 力扣55：跳跃游戏"></a>17. 力扣55：跳跃游戏</h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417195920312.png" alt="image-20210417195920312"></p>
<h3 id="思路：-19"><a href="#思路：-19" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>维护一个变量right，为当前位置最远能到的位置</li>
<li>当位置小于这个坐标的时候，不断更新right，取最大值</li>
<li>只要right超过目标位置，即成功</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ind = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ind; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= right) &#123;</span><br><span class="line">                right = max(right, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= ind) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="18-力扣152：乘积最大子数组"><a href="#18-力扣152：乘积最大子数组" class="headerlink" title="18. 力扣152：乘积最大子数组"></a>18. 力扣152：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417200246885.png" alt="image-20210417200246885"></p>
<h3 id="思路：-20"><a href="#思路：-20" class="headerlink" title="思路："></a>思路：</h3><ul>
<li>维护一个最大值与最小值</li>
<li>最终结果为<code>当前值*最大值、当前值、当前值*最小值</code>三者中取最大</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fmax = nums[<span class="number">0</span>], fmin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_max = fmax;</span><br><span class="line">            fmax = max(tmp_max * nums[i], max(nums[i], nums[i] * fmin));</span><br><span class="line">            fmin = min(fmin * nums[i], min(nums[i], nums[i] * tmp_max));</span><br><span class="line">            ans = max(fmax, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-力扣32：最长有效括号"><a href="#19-力扣32：最长有效括号" class="headerlink" title="19. 力扣32：最长有效括号"></a>19. 力扣32：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></h2><p><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417200601515.png" alt="image-20210417200601515"></p>
<h3 id="思路：-21"><a href="#思路：-21" class="headerlink" title="思路："></a>思路：</h3><ul>
<li><h3 id="动态规划：-1"><a href="#动态规划：-1" class="headerlink" title="动态规划："></a>动态规划：</h3><ul>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417200930590.png" alt="image-20210417200930590"></li>
</ul>
</li>
<li><h3 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h3><ul>
<li><img src="/2021/02/04/0043/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210417200958686.png" alt="image-20210417200958686"></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.size() || s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; str;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        str.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) str.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                str.pop();</span><br><span class="line">                <span class="keyword">if</span> (str.empty()) str.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = max(ans, i - str.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>从Linux 进程调度到 Android 线程管理</title>
    <url>/2022/09/23/0044.%E4%BB%8ELinux%20%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%B0%20Android%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Linux-进程与Android-线程"><a href="#Linux-进程与Android-线程" class="headerlink" title="Linux 进程与Android 线程"></a>Linux 进程与Android 线程</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。</p>
<p>无论按照怎样的分法，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（比如cpu、内存、文件等等），而将线程分配到某个cpu上执行。一个进程当然可以拥有多个线程，此时，如果进程运行在SMP机器上，它就可以同时使用多个cpu来执行各个线程，达到最大程度的并行，以提高效率；同时，即使是在单cpu的机器上，采用多线程模型来设计程序，正如当年采用多进程模型代替单进程模型一样，使设计更简洁、功能更完备，程序的执行效率也更高，例如采用多个线程响应多个输入，而此时多线程模型所实现的功能实际上也可以用多进程模型来实现，而与后者相比，线程的上下文切换开销就比进程要小多了，从语义上来说，同时响应多个输入这样的功能，实际上就是共享了除cpu以外的所有资源的。</p>
<p>针对线程模型的两大意义，分别开发出了核心级线程和用户级线程两种线程模型，分类的标准主要是线程的调度者在核内还是在核外。前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。</p>
<h3 id="内核线程与用户线程"><a href="#内核线程与用户线程" class="headerlink" title="内核线程与用户线程"></a>内核线程与用户线程</h3><p>需要理解 Linux 进程与 Android 线程的关系，需要先解释清楚 Linux 中内核线程、用户线程的关系，在 内核线程、轻量级进程、用户线程的区别和联系 中有比较清晰的阐述。可以总结为几点:</p>
<ul>
<li><p>内核线程只运行在内核态，不受用户态上下文的拖累。</p>
</li>
<li><p>用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全由库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</p>
</li>
<li><p>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p>
</li>
<li><p>LinuxThreads 是用户空间的线程库，所采用的是线程-进程 1对1 模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定 的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</p>
</li>
<li><p><strong>PS</strong>: Linux 在2.6之前使用的是 LinuxThreads 线程库,2.6之后是NPTL(Native Posix Thread Library)，NPTL 使用的也是1对1的结构，但是在信号处理，线程同步，存储管理等多方面进行了优化。</p>
</li>
</ul>
<p>此外，Linux 内核不存在真正意义上的线程。Linux 将所有的执行实体都称之为任务（task），每一个任务在 Linux 上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。但是，Linux 下不同任务之间可以选择公用内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，而这些任务就成为这个进程里面的线程。</p>
<h2 id="Linux-进程调度"><a href="#Linux-进程调度" class="headerlink" title="Linux 进程调度"></a>Linux 进程调度</h2><p>现在的操作系统都是多任务的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）。这个管理程序就是调度程序，它的功能说起来很简单：</p>
<ul>
<li><p>决定哪些进程运行，哪些进程等待</p>
</li>
<li><p>决定每个进程运行多长时间</p>
</li>
</ul>
<p>此外，为了获得更好的用户体验，运行中的进程还可以立即被其他更紧急的进程打断。总之，调度是一个平衡的过程。一方面，它要保证各个运行的进程能够最大限度的使用CPU(即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上)；另一方面，保证各个进程能公平的使用CPU(即防止一个进程长时间独占CPU的情况)。</p>
<h3 id="Linux-进程优先级"><a href="#Linux-进程优先级" class="headerlink" title="Linux 进程优先级"></a>Linux 进程优先级</h3><p>进程提供了两种优先级，一种是普通的进程优先级，第二个是实时优先级。前者适用 SCHED_NORMAL 调度策略，后者可选 SCHED_FIFO 或 SCHED_RR 调度策略。任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占，同级实时进程之间是按照 FIFO（一次机会做完）或者 RR（多次轮转）规则调度的。</p>
<h3 id="nice-值"><a href="#nice-值" class="headerlink" title="nice 值"></a>nice 值</h3><ul>
<li><p>nice 的取值范围为 -20 到 19。</p>
</li>
<li><p>nice 的值越大，进程的优先级就越低，获得 CPU 调用的机会越少，nice值越小，进程的优先级则越高，获得 CPU 调用的机会越多。</p>
</li>
<li><p>一个 nice 值为 -20 的进程优先级最高，nice 值为 19 的进程优先级最低。</p>
</li>
<li><p>父进程 fork 出来的子进程 nice 值与父进程相同。父进程 renice，子进程 nice 值不会随之改变。</p>
</li>
</ul>
<h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>Linux 进程优先级与 nice 值及实时进程优先级的关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20220925114243.png" alt="image-20220925114243392"></p>
<h3 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h3><p>除此之外，在执行阶段，调度程序通过增加或减少进程静态优先级的值，来达到奖励IO消耗型或惩罚cpu消耗型的进程，调整后的进程称为动态优先级。与之对应的我们前面提到的优先级的值被称为静态优先级。</p>
<h3 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h3><p>优先级，可以决定谁先运行。但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度。于是就有了时间片的概念。时间片是一个数值，表示一个进程被抢占前能持续运行的时间。也可以认为是进程在下次调度发生前运行的时间(除非进程主动放弃CPU，或者有实时进程来抢占CPU)。时间片的大小设置并不简单，设大了，系统响应变慢(调度周期长)；设小了，进程频繁切换带来的处理器消耗。默认的时间片一般是10ms。</p>
<p><strong>举个例子说明调度原理的实现：</strong></p>
<p>假设系统中只有3个进程ProcessA(NI=+10)，ProcessB(NI=0)，ProcessC(NI=-10)，NI表示进程的nice值，时间片=10ms：</p>
<ul>
<li><p>调度前，把进程优先级按一定的权重映射成时间片(这里假设优先级高一级相当于多5msCPU时间)。假设ProcessA分配了一个时间片10ms，那么ProcessB的优先级比ProcessA高10(nice值越小优先级越高)，ProcessB应该分配10×5+10=60ms，以此类推，ProcessC分配20×5+10=110ms。</p>
</li>
<li><p>开始调度时，优先调度分配CPU时间多的进程。由于ProcessA(10ms),ProcessB(60ms),ProcessC(110ms)。显然先调度ProcessC。</p>
</li>
<li><p>10ms(一个时间片)后，再次调度时，ProcessA(10ms), ProcessB(60ms), ProcessC(100ms)。 ProcessC刚运行了10ms，所以变成100ms。此时仍然先调度ProcessC。</p>
</li>
<li><p>再调度4次后(4个时间片)，ProcessA(10ms), ProcessB(60ms),ProcessC(60ms)。此时ProcessB和ProcessC的CPU时间一样，这时得看ProcessB和ProcessC谁在CPU运行队列的前面，假设ProcessB在前面，则调度ProcessB</p>
</li>
<li><p>10ms(一个时间片)后，ProcessA(10ms), ProcessB(50ms), ProcessC(60ms)。再次调度ProcessC</p>
</li>
<li><p>ProcessB 和 ProcessC 交替运行，直至 ProcessA(10ms), ProcessB(10ms), ProcessC(10ms)。<br>这时得看ProcessA，ProcessB，ProcessC谁在CPU运行队列的前面就先调度谁。这里假设调度ProcessA</p>
</li>
<li><p>10ms (一个时间片)后，ProcessA (时间片用完后退出), ProcessB (10ms), ProcessC (10ms)。</p>
</li>
<li><p>再过2个时间片，ProcessB 和 ProcessC 也运行完退出。</p>
</li>
</ul>
<p>这个例子很简单，主要是为了说明调度的原理，实际的调度算法虽然不会这么简单。</p>
<h3 id="进程调度算法-CFS"><a href="#进程调度算法-CFS" class="headerlink" title="进程调度算法 CFS"></a>进程调度算法 CFS</h3><p>Linux上的调度算法是不断发展的，在2.6.23内核以后，采用了“完全公平调度算法”，简称CFS。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>CFS算法的初衷就是让所有进程同时运行在一个CPU上，例如两个进程都需要运行10ms的时间，则CFS算法下，连个进程同时运行在CPU上，且时间为20ms，而不是每个进程分别运行10ms。但是这只是一种理想的运行方式，CFS为了近似这种运行算法，就提出了虚拟运行时间(vruntime)的概念。vruntime记录了一个可执行进程到当前时刻为止执行的总时间（需要以进程总数n进行归一化，并且根据进程的优先级进行加权）。根据vruntime的定义可以知道，vruntime越大，说明该进程运行的越久，所以被调度的可能性就越小。所以我们的调度算法就是每次选择 vruntime 值最小的进程进行调度，内核中使用红黑树可以方便的得到 vruntime 值最小的进程。至于每个进程如何更新自己的 vruntime ？内核中是按照如下方式来更新的： vruntime += delta * NICE_0_LOAD/ se.weight；其中：</p>
<p>NICE_0_LOAD 是个定值，及系统默认的进程的权值；se.weight是当前进程的权重(优先级越高，权重越大)；</p>
<p>delta 是当前进程运行的时间；我们可以得出这么个关系：vruntime 与delta 成正比，即当前运行时间越长 vruntime 增长越快；</p>
<p>vruntime 与 se.weight 成反比，即权重越大 vunruntime 增长越慢。简单来说，一个进程的优先级越高，而且该进程运行的时间越少，则该进程的 vruntime 就越小，该进程被调度的可能性就越高。</p>
<h3 id="运行时长"><a href="#运行时长" class="headerlink" title="运行时长"></a>运行时长</h3><p>CFS 的运行时间是有当前系统中所有可调度进程的优先级的比重来确定的，假如现在进程中有三个可调度进程A、B、C，它们的优先级分别为5,10,15，则它们的时间片分别为5/30，10/30，15/30。而不是由自己的时间片计算得来的，这样的话，优先级为1，2的两个进程与优先级为50,100的两个进程分的时间片是相同的。简单来说，CFS采用的所有进程优先级的比重来计算每个进程的时间片的，是相对的而不是绝对的。</p>
<h3 id="Linux-进程组与-Cgroups"><a href="#Linux-进程组与-Cgroups" class="headerlink" title="Linux 进程组与 Cgroups"></a>Linux 进程组与 Cgroups</h3><p>Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。也是目前轻量级虚拟化技术 lxc （linux container）的基础之一。 </p>
<p>Cgroups最初的目标是为资源管理提供的一个统一的框架，既整合现有的cpuset等子系统，也为未来开发新的子系统提供接口。现在的cgroups适用于多种应用场景，从单个进程的资源控制，到实现操作系统层次的虚拟化（OS Level Virtualization）。Cgroups提供了以下功能：</p>
<ul>
<li><p>限制进程组可以使用的资源数量（Resource limiting ）。比如：memory子系统可以为进程组设定一个memory使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发OOM（out of memory）。</p>
</li>
<li><p>进程组的优先级控制（Prioritization ）。比如：可以使用cpu子系统为某个进程组分配特定cpu share。</p>
</li>
<li><p>记录进程组使用的资源数量（Accounting ）。比如：可以使用cpuacct子系统记录某个进程组使用的cpu时间</p>
</li>
<li><p>进程组隔离（Isolation）。比如：使用ns子系统可以使不同的进程组使用不同的namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。</p>
</li>
<li><p>进程组控制（Control）。比如：使用freezer子系统可以将进程组挂起和恢复。</p>
</li>
</ul>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>任务（task）。在 cgroups 中，任务就是系统的一个进程。</p>
</li>
<li><p>控制族群（control group）。控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。</p>
</li>
<li><p>层级（hierarchy）。控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性。</p>
</li>
<li><p>子系统（subsytem）。一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。</p>
</li>
</ul>
<h3 id="cgroups-在-Android-中的应用"><a href="#cgroups-在-Android-中的应用" class="headerlink" title="cgroups 在 Android 中的应用"></a>cgroups 在 Android 中的应用</h3><p>Android中关于 cpu/cpuset/schedtune 三个子系统的应用都是基于进程优先级的。</p>
<p>AMS(ActivityManagerService) 和 PMS(PackageManagerService) 等通过 Process 设置进程优先级、调度策略等；android/osProcess JNI通过调用libcutils.so/libutils.so执行getpriority/setpriority/schedsetscheduler/schedgetschedler系统调用或者直接操作CGroup文件节点以达到设置优先级，限制进程CPU资源的目的。</p>
<ul>
<li><p>cpu，这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问，连接在 Android 系统的 /dev/cpuctl 层级结构上。</p>
</li>
<li><p>cpuset，这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点，连接在 Android 系统的 /dev/cpuset 层级结构上。</p>
</li>
<li><p>schedtune，是ARM/Linaro为了EAS新增的一个子系统，主要用来控制进程调度选择CPU以及boost触发，连接在 Android 系统的 /dev/stune 层级结构上。</p>
</li>
<li><p>Android 中在从设置进程优先级到最后映射到不同 cgroups 下的过程，有兴趣的可以参考 Android中关于cpu/cpuset/schedtune的应用{<a href="https://blog.csdn.net/omnispace/article/details/73320945%7D%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E3%80%82%E6%88%91%E4%BB%AC%E8%BF%99%E9%87%8C%E4%BB%A5">https://blog.csdn.net/omnispace/article/details/73320945}这篇文章。我们这里以</a> cpu 子系统为例介绍一下再 CPU 子系统下是如何控制不同 cgroup 对 CPU 资源的访问。</p>
</li>
</ul>
<h3 id="CPU-子系统"><a href="#CPU-子系统" class="headerlink" title="CPU 子系统"></a>CPU 子系统</h3><p>CPU 子系统连接的 /dev/cpuctl 层级结构下有两个 cgroup，分别是</p>
<ul>
<li><p>/ ，对应到 Android 的前台进程组。</p>
</li>
<li><p>/bg_non_interactive ，对应到 Android 的后台进程组。</p>
</li>
</ul>
<p>在 cgroup 下定义了一些参数，来控制不同的 cgroup 在使用 cpu 资源时的配置：</p>
<ul>
<li><p>cpu.shares ：保存了整数值，用来设置 cgroup 分组任务获得 CPU 时间的相对值。</p>
</li>
<li><p>cpu.rt_runtime_us ：主要用来设置 cgroup 获得 CPU 资源的周期，单位为微妙。</p>
</li>
<li><p>cpu.rt_period_us ：主要是用来设置 cgroup 中的任务可以最长获得 CPU 资源的时间，单位为微秒。</p>
</li>
</ul>
<p>通过下面的数据我们可以看到，前台进程组和后台进程组的 cpu.share 值相比接近于 20:1，也就是说前台进程组中的应用可以利用 95% 的 CPU，而处于后台进程组中的应用则只能获得 5% 的 CPU 利用率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;cpu.shares</span><br><span class="line">1024</span><br><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;bg_non_interactive&#x2F;cpu.shares</span><br><span class="line">52</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20220925120102.png" alt="image-20220925120102579"></p>
<p>同样我们也可查看 cpu.rt_period_us 与 cpu.rt_runtime_us 的时间对比：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;cpu.rt_period_us</span><br><span class="line">1000000</span><br><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;cpu.rt_runtime_us    </span><br><span class="line">800000</span><br></pre></td></tr></table></figure>
<p>即单个逻辑CPU下每一秒内可以获得0.8秒的执行时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;bg_non_interactive&#x2F;cpu.rt_period_us</span><br><span class="line">1000000</span><br><span class="line">shell@hammerhead:&#x2F; $ cat &#x2F;dev&#x2F;cpuctl&#x2F;bg_non_interactive&#x2F;cpu.rt_runtime_us</span><br><span class="line">700000</span><br></pre></td></tr></table></figure>
<p>PS: 最长的获取CPU资源时间取决于逻辑CPU的数量。比如 cpu.rt_runtime_us 设置为200000（0.2秒）， cpu.rt_period_us 设置为1000000（1秒）。在单个逻辑CPU上的获得时间为每秒为0.2秒。 2个逻辑CPU，获得的时间则是0.4秒。 </p>
<h3 id="SchedPolicy"><a href="#SchedPolicy" class="headerlink" title="SchedPolicy"></a>SchedPolicy</h3><p>Android 底层对进程分组的操作最后是通过 sched_policy.c 文件中的 set_sched_policy(int tid, SchedPolicy policy) 和 set_cpuset_policy(int tid, SchedPolicy policy) 函数添加到对应的进程组的，调用这两个函数的传递的 SchedPolicy 定义在 sched_policy.h 中，定义不同的调度策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Keep in sync with THREAD_GROUP_* in frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Process.java *&#x2F;</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    SP_DEFAULT    &#x3D; -1,</span><br><span class="line">    SP_BACKGROUND &#x3D; 0,</span><br><span class="line">    SP_FOREGROUND &#x3D; 1,</span><br><span class="line">    SP_SYSTEM     &#x3D; 2,  &#x2F;&#x2F; can&#39;t be used with set_sched_policy()</span><br><span class="line">    SP_AUDIO_APP  &#x3D; 3,</span><br><span class="line">    SP_AUDIO_SYS  &#x3D; 4,</span><br><span class="line">    SP_TOP_APP    &#x3D; 5,</span><br><span class="line">    SP_CNT,</span><br><span class="line">    SP_MAX        &#x3D; SP_CNT - 1,</span><br><span class="line">    SP_SYSTEM_DEFAULT &#x3D; SP_FOREGROUND,</span><br><span class="line">&#125; SchedPolicy;</span><br></pre></td></tr></table></figure>
<p>在 set_sched_policy 中根据不同的 SchedPolicy 为进程找到不同的进程组，并添加进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据不同调度策略选择不同的进程组</span><br><span class="line">int fd &#x3D; -1;</span><br><span class="line">int boost_fd &#x3D; -1;</span><br><span class="line">switch (policy) &#123;</span><br><span class="line">case SP_BACKGROUND:</span><br><span class="line">    fd &#x3D; bg_cgroup_fd;</span><br><span class="line">    boost_fd &#x3D; bg_schedboost_fd;</span><br><span class="line">    break;</span><br><span class="line">case SP_FOREGROUND:</span><br><span class="line">case SP_AUDIO_APP:</span><br><span class="line">case SP_AUDIO_SYS:</span><br><span class="line">    fd &#x3D; fg_cgroup_fd;</span><br><span class="line">    boost_fd &#x3D; fg_schedboost_fd;</span><br><span class="line">    break;</span><br><span class="line">case SP_TOP_APP:</span><br><span class="line">    fd &#x3D; fg_cgroup_fd;</span><br><span class="line">    boost_fd &#x3D; ta_schedboost_fd;</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    fd &#x3D; -1;</span><br><span class="line">    boost_fd &#x3D; -1;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加到对应的进程组</span><br><span class="line">if (add_tid_to_cgroup(tid, fd) !&#x3D; 0) &#123;</span><br><span class="line">    if (errno !&#x3D; ESRCH &amp;&amp; errno !&#x3D; ENOENT)</span><br><span class="line">        return -errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set_cpuset_policy 也有类似的逻辑，这里就不重复列举了，有兴趣的可以去看看源码。</p>
<p>在初始化方法中，可以看到对应不同的进程组和映射到不同的 cgroups 层级架构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __initialize(void) &#123;</span><br><span class="line">    char* filename;</span><br><span class="line">    if (!access(&quot;&#x2F;dev&#x2F;cpuctl&#x2F;tasks&quot;, F_OK)) &#123;</span><br><span class="line">        __sys_supports_schedgroups &#x3D; 1;</span><br><span class="line"></span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuctl&#x2F;tasks&quot;;</span><br><span class="line">        fg_cgroup_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        if (fg_cgroup_fd &lt; 0) &#123;</span><br><span class="line">            SLOGE(&quot;open of %s failed: %s\n&quot;, filename, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuctl&#x2F;bg_non_interactive&#x2F;tasks&quot;;</span><br><span class="line">        bg_cgroup_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        if (bg_cgroup_fd &lt; 0) &#123;</span><br><span class="line">            SLOGE(&quot;open of %s failed: %s\n&quot;, filename, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        __sys_supports_schedgroups &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ifdef USE_CPUSETS</span><br><span class="line">    if (!access(&quot;&#x2F;dev&#x2F;cpuset&#x2F;tasks&quot;, F_OK)) &#123;</span><br><span class="line"></span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks&quot;;</span><br><span class="line">        fg_cpuset_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuset&#x2F;background&#x2F;tasks&quot;;</span><br><span class="line">        bg_cpuset_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks&quot;;</span><br><span class="line">        system_bg_cpuset_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;cpuset&#x2F;top-app&#x2F;tasks&quot;;</span><br><span class="line">        ta_cpuset_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">#ifdef USE_SCHEDBOOST</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;stune&#x2F;top-app&#x2F;tasks&quot;;</span><br><span class="line">        ta_schedboost_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;stune&#x2F;foreground&#x2F;tasks&quot;;</span><br><span class="line">        fg_schedboost_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        filename &#x3D; &quot;&#x2F;dev&#x2F;stune&#x2F;background&#x2F;tasks&quot;;</span><br><span class="line">        bg_schedboost_fd &#x3D; open(filename, O_WRONLY | O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到上面 SchedPolicy 的定义，可以看到 Keep in sync with THREAD_GROUP_* in frameworks/base/core/java/android/os/Process.java 这样的一句注释，看一眼这里 Process.java 对线程组的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Default thread group - </span><br><span class="line"> * has meaning with setProcessGroup() only, cannot be used with setThreadGroup(). </span><br><span class="line"> * When used with setProcessGroup(), the group of each thread in the process </span><br><span class="line"> * is conditionally changed based on that thread&#39;s current priority, as follows: </span><br><span class="line"> * threads with priority numerically less than THREAD_PRIORITY_BACKGROUND </span><br><span class="line"> * are moved to foreground thread group.  All other threads are left unchanged. </span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_DEFAULT &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Background thread group - All threads in </span><br><span class="line"> * this group are scheduled with a reduced share of the CPU. </span><br><span class="line"> * Value is same as constant SP_BACKGROUND of enum SchedPolicy. </span><br><span class="line"> * FIXME rename to THREAD_GROUP_BACKGROUND. </span><br><span class="line"> *&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_BG_NONINTERACTIVE &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Foreground thread group - All threads in </span><br><span class="line"> * this group are scheduled with a normal share of the CPU. </span><br><span class="line"> * Value is same as constant SP_FOREGROUND of enum SchedPolicy. </span><br><span class="line"> * Not used at this level. </span><br><span class="line"> **&#x2F;</span><br><span class="line">private static final int THREAD_GROUP_FOREGROUND &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * System thread group. </span><br><span class="line"> **&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_SYSTEM &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Application audio thread group. </span><br><span class="line"> **&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_AUDIO_APP &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * System audio thread group. </span><br><span class="line"> **&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_AUDIO_SYS &#x3D; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Thread group for top foreground app. </span><br><span class="line"> **&#x2F;</span><br><span class="line">public static final int THREAD_GROUP_TOP_APP &#x3D; 5;</span><br></pre></td></tr></table></figure>
<p>可以看到两组定义之间明确的对应关系：</p>
<table>
<thead>
<tr>
<th>Process 进程组</th>
<th>SchedPolicy 进程组</th>
</tr>
</thead>
<tbody><tr>
<td>THREAD_GROUP_DEFAULT</td>
<td>SP_DEFAULT</td>
</tr>
<tr>
<td>THREAD_GROUP_BG_NONINTERACTIVE</td>
<td>SP_BACKGROUND</td>
</tr>
<tr>
<td>THREAD_GROUP_FOREGROUND</td>
<td>SP_FOREGROUND</td>
</tr>
<tr>
<td>THREAD_GROUP_SYSTEM</td>
<td>SP_SYSTEM</td>
</tr>
<tr>
<td>THREAD_GROUP_AUDIO_APP</td>
<td>SP_AUDIO_APP</td>
</tr>
<tr>
<td>THREAD_GROUP_AUDIO_SYS</td>
<td>SP_AUDIO_SYS</td>
</tr>
<tr>
<td>THREAD_GROUP_TOP_APP</td>
<td>SP_TOP_APP</td>
</tr>
</tbody></table>
<p>至于这里的对应关系是怎么传递对接上的，会在后面进行解释。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Andriod</category>
      </categories>
      <tags>
        <tag>Andriod</tag>
        <tag>系统调度</tag>
      </tags>
  </entry>
  <entry>
    <title>类和对象——封装</title>
    <url>/2021/02/02/0039.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="类和对象——封装"><a href="#类和对象——封装" class="headerlink" title="类和对象——封装"></a>类和对象——封装</h1><h2 id="类型与变量"><a href="#类型与变量" class="headerlink" title="类型与变量"></a>类型与变量</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135903.png" alt="image-20210228193156190" style="zoom:50%;">

<ul>
<li>类相当于类型，对象相当于变量</li>
<li>类型 = 类型数据 + 类型操作</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135909.png" alt="image-20210228193841229" style="zoom:50%;">

<ul>
<li>类中包含：<ul>
<li>数据</li>
<li>操作</li>
</ul>
</li>
<li>成员属性与方法：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135915.png" alt="image-20210228194052578" style="zoom:50%;"></li>
<li>上面是<code>成员属性</code>，下面是<code>成员方法</code>。</li>
<li>class 是增强版本的  struct，struct 不能定义成员方法。</li>
</ul>
</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li><p>编译器层面的语义信息：编译器会根据设置的权限，去检查代码中是否访问了逻辑上不可见的元素。</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135920.png" alt="image-20210228194832575" style="zoom:50%;">
</li>
<li><p>类内，类外</p>
</li>
<li><p>访问权限控制的是类外能否访问到</p>
</li>
<li><p>public：类外能访问</p>
</li>
<li><p>private：只有类内可以访问</p>
</li>
<li><p>protected：子类可以访问父类保护的内容</p>
</li>
<li><p>friendly（隔壁老王）：友元函数，可以访问类内部的私有属性和方法</p>
</li>
</ul>
<h3 id="代码演示1："><a href="#代码演示1：" class="headerlink" title="代码演示1："></a>代码演示1：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::say</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;My name is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People alin;</span><br><span class="line">    People hug;</span><br><span class="line">    alin.name = <span class="string">&quot;Haizei Wu&quot;</span>;</span><br><span class="line">    hug.name = <span class="string">&quot;Hug&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;alin = &quot;</span> &lt;&lt; &amp;alin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;hug = &quot;</span> &lt;&lt; &amp;alin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    alin.say(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">    hug.say(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>只在成员方法内可以使用 this 指针，作用是指向当前对象</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135853.png" alt="image-20210228201459364"></li>
<li>如果此时传入一个name，但是仍旧想打印成员函数的name，就可以用this-&gt;name，this指针科帮助我们明确的强调当前我们调用的是一个成员属性。</li>
<li>命名空间：在名字前面加一个<code>限定域</code><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135932.png" alt="image-20210228202209140"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135937.png" alt="image-20210228202220006"></li>
<li>此时主函数中的 People 报错，因为People 这个类被包含在 haizei 这个命名空间中</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135942.png" alt="image-20210228202335022"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306135947.png" alt="image-20210228202353701"></li>
<li>想不报错，可以用上面两种方法，不过在c++ 中不建议用 using namesapce</li>
</ul>
</li>
<li>class 是一个特殊的命名空间，因为在定义类内的成员操作时，需要加上类名，类似命名空间。</li>
</ul>
<h3 id="代码演示2：（实现-cout）"><a href="#代码演示2：（实现-cout）" class="headerlink" title="代码演示2：（实现 cout）"></a>代码演示2：（实现 cout）</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">// 工业上一般命名空间都是通过这样宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGINS(x) namespace x &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDS(x) &#125; <span class="comment">// namespace x</span></span></span><br><span class="line">BEGINS(haizei)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> x);</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span> *x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回值是void，则只能输出一个 cout &lt;&lt; a; 而不能连续输出 cout &lt;&lt; a &lt;&lt; b，否则会报错</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; a &lt;&lt; b 可以看成是 (cout &lt;&lt; a) &lt;&lt; b，因为左移运算符的对象是 cout，所以依旧需要返回 cout 本身，所以成员方法应该用如下方式</span></span><br><span class="line">ostream &amp;ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span> *x) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream <span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line">ENDS(haizei)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">123</span>, m = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    haizei::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140050.png" alt="image-20210228203455214"></li>
<li> &lt;&lt; 是一个左移运算符，运算符两边是变量，所以 cout 应该是一个变量，而在c++中，对象类似变量，所以 cout 应该是一个对象</li>
<li>所以，cin、cout 都应该是一个对象。</li>
</ul>
<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><blockquote>
<p>由于没有学左值右值，所以目前这部分不是完整的知识。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140105.png" alt="image-20210301150153667"></p>
<ul>
<li><p>无返回值，且函数名与类名一样</p>
</li>
<li><p>变量需要初始化，那对象也需要初始化，而初始化则是构造函数，析构函数则是销毁对象</p>
</li>
<li><p>任何对象的生命周期：构造 ——使用 ——析构</p>
</li>
<li><p>默认构造函数：编译器自动生成，没有参数的函数</p>
<blockquote>
<p>如果自己写了一个有参构造函数，那编译器的默认构造函数则已经被删掉不存在了。</p>
<p>这个时候，如果还要使用默认构造函数，只能自己显示的写一个默认构造函数，即存在两个构造函数。</p>
<p>仅仅是默认构造不见了，如果需要拷贝构造，仍然会自动生成。</p>
</blockquote>
</li>
<li><p>有参构造函数：</p>
<ul>
<li><p>转换构造函数：只有一个参数，相当于把一种类型转换成当前类型</p>
</li>
<li><p>拷贝构造：传参类型与当前对象类型一致，把其他对象拷贝给当前对象 </p>
</li>
<li><p>移动构造：涉及右值</p>
<blockquote>
<p>拷贝构造与赋值运算符完全不等价。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>析构函数：回收资源，释放空间</p>
</li>
</ul>
<blockquote>
<p>在工程项目中，构造函数与析构函数一般会设计得非常非常的简单，会尽量避免在构造函数进行对大资源的申请，因为如果构造函数出 BUG 了，那 C++ 的异常捕获机制是很难捕获到的。</p>
<p>因此，一般会额外做一个伪构造函数跟伪析构函数（成员函数）去代替构造跟析构，或者说运用设计模式中的<code>工厂设计模式</code>。</p>
</blockquote>
<blockquote>
<p>C++的学习重点：程序的处理流程。</p>
</blockquote>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data : &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化列表初始化d，指定传参的参数</span></span><br><span class="line">    A() : d(<span class="number">3</span>, <span class="number">4</span>), c(<span class="number">3</span>, <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c : &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d : &quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span> x) : d(x, x), c(<span class="number">3</span>, <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : transform constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c : &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d : &quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化列表初始化d，通过拷贝构造构造d，Data会生成默认的拷贝构造</span></span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) : d(a.d), c(<span class="number">3</span>, <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c : &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d : &quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : operator&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个成员方法是const类型的方法，该方法的内部的this也是const，所以返回的值也是const</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) <span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : operator&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Data c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="function">A <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    A d = <span class="number">3</span>;</span><br><span class="line">    a = <span class="number">123</span>;</span><br><span class="line">    A e = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b : &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;end of main&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>任何对象在建立的时候都会调用构造函数，只不过这个构造函数是自己调用还是系统自动调用</p>
</li>
<li><p>上面的代码表示，析构函数是在主程序结束之后才会被调用</p>
</li>
<li><p>主程序结束之后，先对 b 对象进行析构，再对 a 对象进行析构，这个顺序与构造顺序<code>刚好相反</code></p>
<blockquote>
<p>b对象的构造有可能依赖于 a 对象的信息，如果真的依赖了，则 b 对象的析构对象很大概率也会依赖a 对象，所以为了避免析构 a 对象时会影响 b 对象，所以需要先析构 b 对象，即构造顺序与析构顺序一定相反。</p>
</blockquote>
</li>
<li><p>转换构造：通过<code>()</code>或者直接<code>=</code>来调用</p>
<ul>
<li>一般只有类型相符合，才能赋值，而在 <code>a = 123</code>中，编译器会<code>临时</code>将<code>123</code>通过<code>A(int x)</code>这个构造函数转换 <code>A类型</code>，这样，就可以把<code>123</code>赋值给<code>a</code>了，<code>赋值完之后就被析构</code>了。上面的代码编译时，会产生两个两个转换构造函数，其中之一就是<code>123</code>的转换</li>
<li>逻辑上：<ul>
<li><code>A(int x)</code>：把一个整型转换A类型</li>
<li><code>A(string name)</code>：把一个字符串类型转换成A类型</li>
</ul>
</li>
<li>功能上：只是初始化当前对象的某个参数</li>
</ul>
</li>
<li><p><code>A = 123</code>的流程：</p>
<ul>
<li>重载了运算符 = </li>
<li>123 是一个整型，A 不是一个整型，但是A有一个可以把整型转换成A对象的构造函数，当调用赋值运算符<code>=</code>的时候，会通过<code>123</code>临时生成一个匿名对象<code>x</code>，再把这个对象<code>x</code>绑定到赋值运算符方法的<code>a</code>上，然后再进入正常的赋值运算符流程中，所以，此时的<code>this</code>指针，指向的是对象<code>a</code></li>
<li>赋值完成之后（赋值运算符方法结束），匿名对象已经没有作用，直接就被析构了。</li>
</ul>
</li>
<li><p><code>A e = a</code>：</p>
<ul>
<li><p>对这里，等价于 <code>A e(a)</code>，这里不会调用到赋值运算符，如果不是在建立对象的时候用<code>=</code>，则会调用赋值运算符</p>
</li>
<li><p>如果拷贝构造函数是<code>A(A a)&#123;&#125;</code>，的话，因为是值传递，函数会临时生成一个临时变量，这也就意味着会调用参数的拷贝构造，然后一直拷贝构造下去，无限递归。</p>
<p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140235.png" alt="image-20210301161928516"></p>
</li>
<li><p>所以不能用值传递，最起码得用<code>引用</code>，避免无限套娃</p>
<blockquote>
<p>需要加<code>const</code>，因为有可能构造的是一个临时变量，即可能传入的变量本身就是一个<code>const</code>变量，这样的话，编译器就会报错，因为<code>const</code>是不让修改的，如果函数传参不是<code>const</code>，就可以在函数里面对该引用修改，就改变了<code>const</code>变量不能修改的初衷，为了兼容传入的变量<code>有const</code>跟<code>没有const</code>两种情况，就只能直接在函数的参数列表改成只有<code>const</code>。</p>
</blockquote>
<ul>
<li><p>左值引用：</p>
<ul>
<li>C++中多了引用类型，也就是相当于传入参数的<code>别名</code>，如下面主函数中传参是n，而函数的传参列表是引用类型，相当于<code>x</code>是<code>n</code>的<code>别名</code>，在函数中对<code>x</code>的任何操作都等价于对<code>n</code>的任何操作。</li>
<li>引用相当于对外部参数贴了一个标签，这并不会产生任何的拷贝行为。</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_one</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        add_one(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>

<blockquote>
<p>引用其实类似指针，只不过引用比指针会方便一点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数的行为：</p>
<ul>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140248.png" alt="image-20210301173512733"></p>
</li>
<li><p>实际上的构造（编译器层面）：22行，进入大括号的时候，编译器就已经构造完成，因为只有构造完成，才能调用，而在大括号里面的内容其实都是调用。</p>
</li>
<li><p>逻辑上的构造：24行完毕就是逻辑上构造完成。</p>
</li>
<li><p>在上述代码中，A类中有个Data 类的成员，而Data 类因为建立了有参构造导致默认构造函数已经不存在，所以，在A类使用构造函数时，如果不用初始化列表初始化Data d的话，就会报错。</p>
<blockquote>
<p>初始化列表可以显性的指定参数的属性。</p>
<p>如果需要对类中成员赋值，最好直接使用初始化列表。</p>
<p>初始化列表的顺序跟构造顺序无关，构造顺序只跟成员顺序有关，无论初始化列表的顺序如何都没用。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> n = <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = a.n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;data[i] = a.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;n; &#125;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> ind) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind &lt; <span class="number">0</span> || ind &gt;= n) <span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">return</span> data[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> ind) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind &lt; <span class="number">0</span> || ind &gt;= n) <span class="keyword">return</span> <span class="keyword">this</span>-&gt;end;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data[ind];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *data, end;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Array &amp;a) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;Array (&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;) : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        i &amp;&amp; out &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        out &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">        a[i] = rand() % <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Array b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">18432</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>使用<code>new</code>代替<code>malloc</code>，因为<code>new</code>可以调用构造函数，同时<code>new</code>是一个运算符，可以重载。</p>
</li>
<li><p>方括号两个重载函数（<code>const</code>与<code>非const</code>）：</p>
<ul>
<li>重载<code>&lt;&lt;</code>的时候，传参是<code>const</code>类型，所以函数里面的方括号应该得是<code>const</code>类型</li>
<li>在主函数时，因为要赋值，所以方括号应该是<code>非const</code>类型</li>
<li>所以，为了满足不同场景，所以写了两个重载函数</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140458.png" alt="image-20210301170911538" style="zoom:50%;">
</li>
</ul>
</li>
<li><p>在对b 对象进行修改的时候，a对象的值也跟着改动了</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140504.png" alt="image-20210301171142651" style="zoom:50%;">

<ul>
<li><p>原因（浅拷贝）：默认的拷贝是两个对象，相同的字段之间依次进行赋值，所以如果指针类型的数据，也一样会拷贝拷贝过去，这就使得两个对象同时拥有<code>同一片存储区域 </code>，两者均具有对这片区域的修改权，一方修改，另一方也会跟着修改，这就是所谓的<code>浅拷贝</code>，也是编译器提供的默认拷贝行为。</p>
<blockquote>
<p>对于指针类型的数据，浅拷贝可能会出现问题，所以出现了深拷贝。</p>
</blockquote>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140525.png" alt="image-20210301171757024" style="zoom:50%;">
</li>
<li><p>深拷贝：自己额外的开辟一个存储空间</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140530.png" alt="image-20210301172147580"></li>
<li>该深拷贝并不完美</li>
<li>结果如下：</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140536.png" alt="image-20210301172253075"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="new与malloc"><a href="#new与malloc" class="headerlink" title="new与malloc"></a>new与malloc</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;malloc int&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> *data1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">free</span>(data1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new int&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> *data2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">delete</span>[] data2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;malloc A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    A *Adata1 = (A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>(Adata1 + i) A();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(Adata1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    A *Adata2 = <span class="keyword">new</span> A[n];</span><br><span class="line">    <span class="keyword">delete</span> Adata2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>结果：</p>
<ul>
<li><p>对整型数据的申请空间，malloc 跟 new 差别不大</p>
</li>
<li><p>对自定义 class 类型，malloc 申请空间后，不会调用构造函数进行初始化，而 new 申请空间后会调用构造函数进行初始化</p>
</li>
<li><p>对自定义 class 类型，free 不会调用析构函数，而 delete 会调用析构函数</p>
<blockquote>
<p>如果申请空间是一个数组，delete后面需要加一个[]，如果只是单一一个对象，则无需。</p>
</blockquote>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140545.png" alt="image-20210301192740455"></p>
</li>
</ul>
</li>
<li><p>原地构造：配合<code>malloc</code>进行使用</p>
<ul>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140552.png" alt="image-20210301193759407"></p>
</li>
<li><p>先用 <code>malloc</code> 申请一片空间</p>
</li>
<li><p>用 <code>new</code> 对每一个空间进行原地初始化，格式为：</p>
<ul>
<li><p><code>new</code>（空间首地址）+  构造函数</p>
<blockquote>
<p>构造函数可以跟申请空间的类型不同，即用A类申请空间，用B类的构造函数。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>在<code>深拷贝</code>的时候，用得<code>挺多</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>三/五法则：</p>
<ol>
<li>需要析构函数的类也需要拷贝构造函数和拷贝赋值函数<ul>
<li>一般需要析构函数的，都是需要动态申请资源的，而动态申请资源的拷贝一般都是深拷贝</li>
</ul>
</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然</li>
<li>析构函数不能删除</li>
<li>如果有一个类有删除好的或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除</li>
<li>如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作</li>
</ol>
</blockquote>
<h3 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140557.png" alt="image-20210301201755599" style="zoom:50%;">

<ul>
<li><p>在相关属性与方法前面加上<code>static</code>的时候，就成为了类属性、类方法</p>
</li>
<li><p>类属性：所有对象共有的属性与</p>
<blockquote>
<p>成员属性：表示状态</p>
<p>即任何对象访问类属性，都是同样的属性，但是成员属性则不一定相同。</p>
<p>如果一个对象对类属性进行修改，则其他对象访问到的类属性均是被修改后的类属性。</p>
<p>有点类似C语言的静态变量，全局仅有一份。</p>
</blockquote>
</li>
<li><p>类方法：不属于某个对象的方法</p>
<blockquote>
<p>类方法不与任何一个对象绑定，所以在类方法内部是无法访问this指针的。</p>
</blockquote>
</li>
</ul>
<h3 id="const方法"><a href="#const方法" class="headerlink" title="const方法"></a>const方法</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140613.png" alt="image-20210301202740019" style="zoom:50%;">

<ul>
<li>const 类型的方法：保证该方法内部，不会当前对象的属性值进行任何更改，一旦更改就会报错</li>
<li>提供给 const 类型的对象使用</li>
</ul>
<h3 id="对象与引用"><a href="#对象与引用" class="headerlink" title="对象与引用"></a>对象与引用</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140619.png" alt="image-20210301202953043" style="zoom:50%;">

<ul>
<li>b 就是 a 的别名</li>
<li>引用在定义变量的时候就需要初始化，因为初始化就是在绑定目标的过程。</li>
</ul>
<h3 id="c-中的结构体与类"><a href="#c-中的结构体与类" class="headerlink" title="c++中的结构体与类"></a>c++中的结构体与类</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140625.png" alt="image-20210301203134616" style="zoom:50%;">

<ul>
<li><p>c++中的 struct 已经不是C语言的结构体了，其底层实现方式跟 class 一样</p>
</li>
<li><p>class：白名单机制</p>
</li>
<li><p>struct：黑名单机制，即如果不希望某些属性被访问到时，需要显性的把该属性定义到 private</p>
<blockquote>
<ol>
<li>为什么c++保留 struct 关键字？</li>
<li>为什么默认访问权限是public？</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="返回值优化（RVO）"><a href="#返回值优化（RVO）" class="headerlink" title="返回值优化（RVO）"></a>返回值优化（RVO）</h2><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    D(<span class="keyword">const</span> D &amp;d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span> x) : x(x) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : transform constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) : x(a.x), d(a.d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; : operator=&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    D d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">temp</span><span class="params">(<span class="number">69</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;temp : &quot;</span> &lt;&lt; &amp;temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = func();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;a : &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li>编译运行后发现 a 的地址与 temp 的地址一模一样，而且只调用了有参构造，没调用拷贝构造<ul>
<li>因为<code>func（）</code>中，temp 只是一个<code>局部变量</code>，其最终的结果均会传递给 a 对象，因此编译器就做了个优化，直接把 temp 这个局部变量中的 this 指针指向 a，这样所有的修改都变成是针对 a。即在<code>func</code>函数中，temp 变量的构造中，传给this 的是 a 的地址，而不是局部变量 temp 的地址</li>
<li>这种优化，就是返回值优化。</li>
</ul>
</li>
<li>如果不用初始化列表显性的拷贝的时候，比如D类的d，则会调用其默认构造（D类的默认构造）。</li>
<li>如果把A类的拷贝构造给注释掉的话，会自动生成一个默认拷贝构造，此时D类则是调用<code>拷贝构造</code></li>
</ul>
<h3 id="对象初始化："><a href="#对象初始化：" class="headerlink" title="对象初始化："></a>对象初始化：</h3><ul>
<li><p>默认初始化</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140637.png" alt="image-20210301210417804" style="zoom:50%;">
</li>
<li><p>拷贝构造</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140642.png" alt="image-20210301210600907" style="zoom:50%;"></li>
<li><p>函数形参的初始化</p>
<ul>
<li>值传递，a 把自己的值拷贝给 b</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140649.png" alt="image-20210301210643521" style="zoom:50%;"></li>
<li><p>返回值优化（RVO）</p>
<ul>
<li>一般情况下，函数的返回值会对应一个临时的匿名变量，所以 return 的时候，相当于把 return 的值赋值给临时匿名变量</li>
</ul>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140654.png" alt="image-20210301210758596"></p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140659.png" alt="image-20210301211244674" style="zoom:50%;">
</li>
<li><p>中间的匿名变量没有任何价值，所以<code>第一版优化</code>就是直接把 temp_a 拷贝给 a</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140705.png" alt="image-20210301211446505" style="zoom:50%;"></li>
<li><p>因为 temp_a 是个局部变量，最终的所有操作的结果都会成为 a，所以<code>第二版优化</code>就是直接把<code>temp_a看成是 a 的别名</code>，直接对 a 进行操作，这样就只会调用一次构造函数，不会调用拷贝构造</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140710.png" alt="image-20210301211732199" style="zoom:50%;">

</li>
</ul>
<blockquote>
<p>如果想看到没修改之前的，可以关掉<code>返回值优化</code>，只需在编译的时候，加上参数 -fno-elider-constructors 即可：<img src="/2021/02/02/0039/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210301212034311.png" alt="image-20210301212034311" style="zoom:50%;"></p>
</blockquote>
<blockquote>
<p>在工程项目中，当实现完代码之后，因为并不知道到底实现了多少遍拷贝构造，所以不能改变拷贝构造的语义，因为改变了之后，编译器可能不知道改变了。即传入的值，一律不改变！</p>
<p>赋值运算符可以改，但拷贝构造不能改！！！</p>
</blockquote>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People() : say_cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 加个限定符，避免在复杂的编程环境下，跟其他变量撞名</span></span><br><span class="line">        People::total_num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; People::total_num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hahaha, funny!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        say_cnt += <span class="number">1</span>;</span><br><span class="line">        output(); <span class="comment">// 调用的是const类型的output</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;output function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;output function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~People() &#123;</span><br><span class="line">        People::total_num -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> say_cnt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> People::total_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People hug, alin;</span><br><span class="line">    hug.say_count();</span><br><span class="line">    alin.say_count();</span><br><span class="line">    People::say_count();</span><br><span class="line">    <span class="keyword">const</span> People xiaobo;</span><br><span class="line">    xiaobo.say();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>类属性<code>total_num</code>在类中仅仅只是声明，而没有定义，通常需要在类外定义一下（即声明与定义分开），与成员属性不太相同</p>
</li>
<li><p>类属性在声明时，需要加上static关键字，这是为了使编译器可以区分是类属性还是成员属性</p>
</li>
<li><p>类属性在定义时，则是在告诉编译器，这个变量是什么类型，应该怎么初始化，在哪个域中等，所以这个时候可以不需要static关键字 </p>
</li>
<li><p>类方法可以通过<code>类名::类方法</code>或者<code>对象.类方法</code>调用，所以<code>对象.方法</code>，不一定就是成员方法，也可能是类方法</p>
</li>
<li><p>const 类型的方法，其内部调用的，无论是变量还是方法，均需要 const 类型</p>
<blockquote>
<p>如果此时需要保留非const 方法，就可以运用函数重载，直接定义两个方法，一个const，一个非const</p>
</blockquote>
</li>
</ul>
<h3 id="构造函数与析构函数（补充1）"><a href="#构造函数与析构函数（补充1）" class="headerlink" title="构造函数与析构函数（补充1）"></a>构造函数与析构函数（补充1）</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;a);</span><br><span class="line">    <span class="keyword">const</span> A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    <span class="comment">//a = b;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>C++的规则比较多，比如构造函数，并不一定清楚在什么情况下，系统添加了什么函数，删除了什么函数等，可能并不清楚C++给类都做了哪些默认的行为，有哪些行为是现在看不到也反应不到代码的。一般在大行工程项目中，为了避免人为疏忽和语言的潜在规则之间可能会引发的潜在bug，C++多了两个关键字——default 与 delete，可以显性的表示什么样的函数可以用编译器提供的，什么样的函数是需要删除掉的</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140719.png" alt="image-20210302091707566"></li>
<li>上面的代码，分别是<code>删除默认构造函数</code>，<code>使用系统自带的拷贝构造函数</code></li>
<li><code>重要</code>：上面的代码其实并<code>没有什么功能上的意义</code>，其意义在于<code>C++的设计哲学</code>，是为了方便思考，为了避免发生错误推出的功能，对功能上可能没什么影响。</li>
</ul>
</li>
<li><p>某个类下的对象，不能被拷贝：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140723.png" alt="image-20210302091622973" style="zoom: 67%;">
</li>
<li><p>这种情况下，的确不可以在定义对象时，直接<code>A b(a)</code>来进行拷贝构造，但是！！还有<code>赋值运算符=</code>也是拷贝构造，所以，需要把<code>拷贝构造与赋值运算符</code>放在<code>private</code>里面</p>
<blockquote>
<p>从功能上讲，拷贝构造放在private之后，就可以不用加delete了，不过加了也无妨，这个是设计哲学的问题。</p>
</blockquote>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140736.png" alt="image-20210302091523455" style="zoom:67%;">

</li>
</ul>
</li>
</ul>
<h3 id="附加："><a href="#附加：" class="headerlink" title="附加："></a>附加：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140741.png" alt="image-20210302092029968" style="zoom:50%;">

<ul>
<li>重载运算符的时候为什么返回值是引用呢？</li>
<li>比如下面的：<code>(a = 123) = 456</code></li>
<li>这条等式成立的前提得是<code>(a = 123)</code>可以赋值，如果<code>返回一个引用</code>，则<code>(a = 123)</code>仍旧是一个对象，这样才可以继续赋值，等式才能成立，下面的 <code>cout</code>也是同理。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="函数重载："><a href="#函数重载：" class="headerlink" title="函数重载："></a>函数重载：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(<span class="number">2.3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>如果<strong>一个作用域</strong>内几个<strong>函数名字相同</strong>但是<strong>参数列表不同</strong>，称为<strong>函数重载</strong>。</p>
<ul>
<li><strong>与返回值没有关系</strong>，编译器无法通过返回值区分函数版本</li>
<li>冲突1：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140748.png" alt="image-20210302093934950"></li>
<li>第二个函数有默认值，所以，第二个函数的参数，可以是一个，也可以是两个。如果主函数调用只有一个参数的函数，编译器不知道要调用第一个还是第二个。可以把第一个函数合并到第二个。</li>
</ul>
</li>
</ul>
<h3 id="重载的意义："><a href="#重载的意义：" class="headerlink" title="重载的意义："></a>重载的意义：</h3><ul>
<li>通过函数名对函数功能进行提示</li>
<li>通过函数参数列表对函数的用法进行提示</li>
<li>扩展已有的功能</li>
</ul>
<h3 id="友元："><a href="#友元：" class="headerlink" title="友元："></a>友元：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data : &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Data &amp;d);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Data &amp;d) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;( &quot;</span>&lt;&lt; d.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d.y &lt;&lt; <span class="string">&quot; )&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>  out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Data <span class="title">f</span><span class="params">(<span class="number">10</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<p>若<code>类外的一个函数</code>想要访问<code>类内部成员</code>（比如私有成员），需要将该函数声明成类的一个<code>友元函数</code>——引狼入室。</p>
<blockquote>
<p>声明在类内部，是考虑到数据安全性！因为一般情况下，声明为友元函数，是类开发者决定的，类开发者决定某些函数可以访问这个类的私有成员。</p>
</blockquote>
<h3 id="运算符重载（非成员）"><a href="#运算符重载（非成员）" class="headerlink" title="运算符重载（非成员）"></a>运算符重载（非成员）</h3><ul>
<li>C++中重载能够扩展运算符功能</li>
<li>运算符重载以函数的方式进行</li>
<li>用特殊形式的函数扩展运算符的功能</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140805.png" alt="image-20210302100441586" style="zoom:50%;"></li>
<li>白色方框的符号能被重载，蓝色的则不行，外加一个<code>sizeof</code>（运算符）也不能重载</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140801.png" alt="image-20210302100604726"></li>
</ul>
<h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point();</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;);</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>+=(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point() : Point(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;outer constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">c</span><span class="params">(a.x + b.x, a.y + b.y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point &amp;Point::<span class="keyword">operator</span>+=(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    x += n, y += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Point::<span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inner constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">c</span><span class="params">(x + a.x, y + a.y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Point &amp;a) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">7</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<ul>
<li><p>委托构造函数：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140814.png" alt="image-20210302101016965"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140819.png" alt="image-20210302101120494"></li>
<li>第29行只是想把 x 与 y 设置为 0，所以，29行可以委托给第30行的有参构造函数进行构造</li>
</ul>
</li>
<li><p>运算符重载：</p>
<ul>
<li><p>方式一：类外重载</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140826.png" alt="image-20210302105033866" style="zoom: 67%;"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140831.png" alt="image-20210302105118616" style="zoom:67%;"></li>
<li>由于是类外访问类内私有成员，所以需要用到友元</li>
</ul>
</li>
<li><p>方式二：类内重载（优先级高）</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140837.png" alt="image-20210302105210455" style="zoom:67%;">
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210306140842.png" alt="image-20210302105236636" style="zoom: 80%;">
</li>
<li><p>如果运算符既有类内重载，又有类外重载，编译器会优先运行<code>类内重载</code></p>
</li>
<li><p><code>+=</code>运算符是返回引用，而<code>+</code>运算符则是返回值</p>
<blockquote>
<p><code>（a + b）</code>的返回值是一个<code>新的值</code>，不是 a 也不是 b，而<code>a += 2</code>的返回值则是<code>a</code>，同时为了避免出现<code>(a += 2) += 2</code>等式的出现，所以<code>+=</code>运算符返回的是引用，一方面表明返回的是<code>a</code>本身，另一方面避免出现<code>(a += 2) += 2</code>等式无法求解。</p>
<p>如果不返回引用也是可以的，不过还是加上的好，逻辑上比较可靠！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="特殊运算符重载：只支持类内重载"><a href="#特殊运算符重载：只支持类内重载" class="headerlink" title="特殊运算符重载：只支持类内重载"></a>特殊运算符重载：只支持<code>类内重载</code></h3><ol>
<li><p>[] ：数组对象</p>
<ul>
<li>返回值可以任意类型 </li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309165009.png" alt="image-20210309164953247"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309165017.png" alt="image-20210309165006657"></li>
<li>重载了[] 运算符之后，导致这个类下的所有对象都支持 [] 运算符</li>
<li>外在表现得像一个数组，实际上还是一个对象！</li>
</ul>
</li>
<li><p>() ：函数对象</p>
<ul>
<li>外在表现得像一个函数，实际上还是一个对象！又名仿函数</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309165137.png" alt="image-20210309165131945"></li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309165205.png" alt="image-20210309165200295"></li>
</ul>
</li>
<li><p>-&gt;：指针对象、间接引用</p>
<ul>
<li><p>外在表现得像一个指针，实际上还是一个对象！</p>
</li>
<li><p>返回的是一个地址，调用<code>对象-&gt;</code>相当于调用了其他对象，这样就可以使用该对象的成员方法</p>
<blockquote>
<p>如果是普通成员调用成员方法，是<code>对象.成员方法</code>，而重载了<code>-&gt;</code>的类，就可以<code>对象-&gt;成员方法</code>来调用其他类的成员方法。</p>
</blockquote>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310172333.png" alt="image-20210306145758956"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310172340.png" alt="image-20210306145814295"></p>
</li>
</ul>
</li>
<li><p>= ：赋值运算符</p>
</li>
</ol>
<h4 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point();</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;);</span><br><span class="line">    Point &amp;<span class="keyword">operator</span>+=(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="built_in">string</span> s);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> Point &amp;);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADD</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    ADD(<span class="keyword">int</span> c) : c(c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PPoint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PPoint(Point *p) : p(p) &#123;&#125;</span><br><span class="line">    Point *<span class="keyword">operator</span>-&gt;()&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point() : Point(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Point::<span class="keyword">operator</span>[](<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;x&quot;</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;y&quot;</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a, <span class="keyword">const</span> Point &amp;b) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;outer constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">c</span><span class="params">(a.x + b.x, a.y + b.y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point &amp;Point::<span class="keyword">operator</span>+=(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    x += n, y += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Point::<span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;a) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;inner constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">c</span><span class="params">(x + a.x, y + a.y)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Point &amp;a) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ADD <span class="title">add</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add(<span class="number">6</span>, <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">7</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    Point c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="string">&quot;x&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="string">&quot;y&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PPoint p = &amp;a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;getX() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="智能指针简易版"><a href="#智能指针简易版" class="headerlink" title="智能指针简易版"></a>智能指针简易版</h4><ul>
<li>指向该对象的指针数量为0时，对象会被析构</li>
<li>实现方式：<ul>
<li>引用计数：当前有多少只能指针指向当前对象 </li>
</ul>
</li>
</ul>
<h3 id="代码演示：-2"><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> haizei &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A () &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;default constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        ~A() &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>();	</span><br><span class="line">        <span class="built_in">shared_ptr</span>(A *);</span><br><span class="line">        <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span> &amp;);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span></span>;</span><br><span class="line">        A *<span class="keyword">operator</span>-&gt;();</span><br><span class="line">        A &amp;<span class="keyword">operator</span>*();</span><br><span class="line">        <span class="comment">// 赋值运算符返回当前对象的引用，为了抱枕 p1 = p2 = p3这种连等可以实现</span></span><br><span class="line">        <span class="built_in">shared_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span> &amp;); </span><br><span class="line">        ~<span class="built_in">shared_ptr</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">decrease_by_one</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">increase_by_one</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">int</span> *cnt;</span><br><span class="line">        A *obj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>::<span class="built_in">shared_ptr</span>() : obj(<span class="literal">nullptr</span>), cnt(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>::<span class="built_in">shared_ptr</span>(A *obj) : obj(obj), cnt(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>::<span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span> &amp;p) : obj(p.obj), cnt(p.cnt) &#123; increase_by_one(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shared_ptr::use_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt ? *cnt : <span class="number">0</span>; &#125;</span><br><span class="line">    A *<span class="built_in">shared_ptr</span>::<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> obj; &#125;</span><br><span class="line">    A &amp;<span class="built_in">shared_ptr</span>::<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *obj; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_ptr::decrease_by_one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;cnt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *(<span class="keyword">this</span>-&gt;cnt) -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (*(<span class="keyword">this</span>-&gt;cnt) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;obj;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_ptr::increase_by_one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// *cnt += 1; 等价于下面</span></span><br><span class="line">            <span class="comment">// *(this-&gt;cnt) += 1; // 等价于下面</span></span><br><span class="line">            cnt[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值运算符，先判断是不是同个对象，如果不是同个对象，先把当前对象的指针减一，再赋值，再把赋值过来的对象的指针加一</span></span><br><span class="line">    <span class="built_in">shared_ptr</span> &amp;<span class="built_in">shared_ptr</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span> &amp;p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;obj != p.obj) &#123;</span><br><span class="line">            decrease_by_one();</span><br><span class="line">            obj = p.obj;</span><br><span class="line">            cnt = p.cnt;</span><br><span class="line">            increase_by_one();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>::~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;decrease_by_one();</span><br><span class="line">        <span class="keyword">this</span>-&gt;obj = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    haizei::A *p1 = <span class="keyword">new</span> haizei::A();</span><br><span class="line">    p1 = <span class="literal">nullptr</span>; <span class="comment">// 不会自动析构</span></span><br><span class="line">    <span class="function">haizei::<span class="built_in">shared_ptr</span> <span class="title">p2</span><span class="params">(<span class="keyword">new</span> haizei::A())</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    haizei::<span class="built_in">shared_ptr</span> p3 = p2;</span><br><span class="line">    p2-&gt;x = <span class="number">123</span>;</span><br><span class="line">    p2-&gt;y = <span class="number">456</span>;</span><br><span class="line">    (*p2).x = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p2 = <span class="literal">nullptr</span>; <span class="comment">// 自动析构</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    p2 = p2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="sort函数的使用：可调用对象"><a href="#sort函数的使用：可调用对象" class="headerlink" title="sort函数的使用：可调用对象"></a>sort函数的使用：可调用对象</h3><p>正常情况下，sort 的比较规则是传一个比较函数 cmp1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(arr.begin(), arr.end(), cmp1);</span><br></pre></td></tr></table></figure>
<p>而其实也可以传递一个仿函数，函数名就是类的对象名字，如果直接<code>类名()</code>(已经重载了括号)，则是产生一个匿名对象，也可以传一个真正的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMP</span>;</span></span><br><span class="line">CMP cmp2;</span><br><span class="line">sort(arr.begin(), arr.end(), CMP());</span><br><span class="line">sort(arr.begin(), arr.end(), cmp2());</span><br></pre></td></tr></table></figure>
<p>仿函数的功能比正常的比较函数更加强大！！！</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310172143.png" alt="image-20210309192002341" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(arr.begin(), arr.end(), CMP(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>比如可以增加一个整型变量z，用来判断是从大到小排序，还是从小到大排序，图中默认从小到大。这种操作用普通的比较函数是做不到的。</li>
</ul>
<h4 id="实现自己的-sort-函数"><a href="#实现自己的-sort-函数" class="headerlink" title="实现自己的 sort 函数"></a>实现自己的 sort 函数</h4><p><code>function&lt;bool(int, int)&gt; cmp</code>：function 可以看作是一种高级的函数指针变量，普通的函数指针变量只能指向函数，而这个指针变量定义的对象可以指向任意的对象，包括仿函数、函数、lambda表达式都行！！！</p>
<blockquote>
<p><code>function&lt;bool(int, int)&gt; cmp</code>：高级函数指针变量，返回的是 bool 类型，传入的是两个整型参数</p>
</blockquote>
<h4 id="代码演示：-3"><a href="#代码演示：-3" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        out &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> haizei &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CMP</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        CMP(<span class="keyword">int</span> z = <span class="number">0</span>) : z(z) &#123;&#125; <span class="comment">// z = 0 less， z = 1 greater</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (a &lt; b) ^ !!(z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; cmp = CMP())</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> x = l, y = r, z = arr[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 系统中的排序规则就是把cmp函数替换到小于号的位置</span></span><br><span class="line">            <span class="keyword">while</span> (cmp(arr[x], z)) x++;</span><br><span class="line">            <span class="keyword">while</span> (cmp(z, arr[y])) y--;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= y) &#123;</span><br><span class="line">                swap(arr[x], arr[y]);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x &lt;= y);</span><br><span class="line">        sort(arr, l, y, cmp);</span><br><span class="line">        sort(arr, x, r, cmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        arr.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr.begin(), arr.end(), haizei::CMP());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    haizei::sort(arr2, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    haizei::sort(arr2, <span class="number">0</span>, <span class="number">4</span>, cmp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    haizei::sort(arr2, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    haizei::sort(arr2, <span class="number">0</span>, <span class="number">4</span>, haizei::CMP(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类和对象——多态</title>
    <url>/2021/02/04/0041.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1_%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="类和对象——多态"><a href="#类和对象——多态" class="headerlink" title="类和对象——多态"></a>类和对象——多态</h1><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234728.png" alt="image-20210307143057276" style="zoom:50%;">

<ul>
<li>结果：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234704.png" alt="image-20210309234702766" style="zoom: 67%;"></li>
</ul>
</li>
<li>普通成员方法：<ul>
<li>跟着类走，即调用的时候对象属于哪个类型，调用的就是该类型的成员方法；<strong>该成员方法的调用在编译期就决定了</strong></li>
<li>比如上面，a是Cat类的，使用的run就是Cat类的；b与c都是Animal类的，使用的run就是Animal类的</li>
</ul>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234735.png" alt="image-20210307144407918" style="zoom:50%;">

<ul>
<li><p>普通成员跟着类走，虚函数则相反，是跟着对象走的。</p>
</li>
<li><h4 id="virtual：把成员方法声明为虚函数"><a href="#virtual：把成员方法声明为虚函数" class="headerlink" title="virtual：把成员方法声明为虚函数"></a>virtual：把成员方法声明为虚函数</h4><ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234744.png" alt="image-20210307190859491" style="zoom:50%;"></li>
<li>结果：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309235423.png" alt="image-20210309235240801" style="zoom: 67%;"></li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309235432.png" alt="image-20210309235413859" style="zoom:50%;"></li>
<li>分析：虚函数是跟着对象走的，a 对象是 Cat，所以调用Cat 类的run， b 对象跟 c 对象指向的均是a 对象，所以调用的run 也是Cat 类的run</li>
</ul>
</li>
<li><h4 id="override：非功能性关键字，起到说明性作用，用来表示虚函数场景，用来表示覆盖父类虚函数的作用"><a href="#override：非功能性关键字，起到说明性作用，用来表示虚函数场景，用来表示覆盖父类虚函数的作用" class="headerlink" title="override：非功能性关键字，起到说明性作用，用来表示虚函数场景，用来表示覆盖父类虚函数的作用"></a>override：非功能性关键字，起到说明性作用，用来表示虚函数场景，用来表示覆盖父类虚函数的作用</h4><ul>
<li><p>规范语义，方便编译器帮助咱们寻找错误。</p>
<blockquote>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310000741.png" alt="image-20210310000734668" style="zoom:50%;">

<ul>
<li>比如父类中有个fll()的虚函数，子类想覆盖该函数，写错写成了fl1()，如果没有加上关键字<code>override</code>的话，程序不会报错，因为这个写法符合语法规则，只是没能做到覆盖的目的；如果加上了<code>override</code>，则编译器会自动识别出该错误，减少找bug的时间！！</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>如果<strong>父类的成员方法是虚函数</strong>，<strong>子类</strong>相同的成员方法<strong>也自然而然的变成虚函数</strong>，写不写<strong>override</strong>都一样，但是最好还是标注以示提醒</p>
</li>
<li><p>虚函数作用：<strong>对外展示的接口统一</strong></p>
</li>
<li><p>虚函数在<strong>编译期没法确定</strong>调用什么方法，只能在<strong>运行期才能确定</strong>调用什么方法</p>
<h4 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">string</span> name) : name(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I don&#x27;t know how to run&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fl1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">string</span> name) : Animal(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can run with four legs&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fl1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> :</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="built_in">string</span> name) : Animal(name)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can run with two legs&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bat(<span class="built_in">string</span> name) : Animal(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can fly&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 10</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Animal **zoo = <span class="keyword">new</span> Animal*[MAX_N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(rand() % <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: zoo[i] = <span class="keyword">new</span> Cat(<span class="string">&quot;Cat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: zoo[i] = <span class="keyword">new</span> People(<span class="string">&quot;People&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: zoo[i] = <span class="keyword">new</span> Bat(<span class="string">&quot;Bat&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) zoo[i]-&gt;run();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Cat a(&quot;Tom&quot;);</span></span><br><span class="line"><span class="comment">    Animal &amp;b = a;</span></span><br><span class="line"><span class="comment">    Animal *c = &amp;a;</span></span><br><span class="line"><span class="comment">    a.run(); // 让这只小猫跑</span></span><br><span class="line"><span class="comment">    b.run(); // 让这只动物跑</span></span><br><span class="line"><span class="comment">    c-&gt;run();// 让这只动物跑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
<li><h4 id="final-关键字：终止虚函数"><a href="#final-关键字：终止虚函数" class="headerlink" title="final 关键字：终止虚函数"></a>final 关键字：终止虚函数</h4><ul>
<li><strong>禁止</strong>虚函数被<strong>重写</strong>；<strong>禁止</strong>基类<strong>被继承</strong></li>
<li>在子类中，可以同时使用 overried 和 final</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310001335.png" alt="image-20210310001323115" style="zoom:50%;"></li>
<li>要求任何子类调用的方法所表现的都跟父类一样的话，就用final，避免子类捣乱修改该方法</li>
<li><img src="/2021/02/04/0041/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210310001603517.png" alt="image-20210310001603517" style="zoom:50%;"></li>
<li>比如：父类有getName()方法，同时不希望任何子类去修改，要求所有的子类，只要调用，就一定是调用父类的getName()，这种情况下，就用final，使得所有的子类的表现都跟父类一样</li>
</ul>
</li>
</ul>
<h3 id="虚函数为什么是跟着对象走的？"><a href="#虚函数为什么是跟着对象走的？" class="headerlink" title="虚函数为什么是跟着对象走的？"></a>虚函数为什么是跟着对象走的？</h3><ul>
<li><p><strong>头8个字节</strong>会存一个地址，这个地址指向一个<strong>虚函数表vtable</strong>，表中带着<strong>这个类</strong>中一个又一个<strong>的虚函数</strong></p>
</li>
<li><p>虚函数表：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234914.png" alt="image-20210307154823294" style="zoom:50%;">
</li>
<li><p>根据类来管理，<strong>同个类型的对象指向同一个虚函数表</strong></p>
</li>
<li><p>所以，overrider所谓的覆盖指的是，把子类中某个成员方法的虚函数表地址改成另一个虚函数表的地址</p>
<blockquote>
<p>比如：B的虚函数表，就是把say方法的地址改为子类的，然后把run方法地址继续记为父类的，两者结合成一张新的虚函数表。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针:"></a>this指针:</h3><ul>
<li>成员指针隐藏的参数<ul>
<li><img src="/2021/02/04/0041/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210310082608890.png" alt="image-20210310082608890" style="zoom:50%;"></li>
<li>像A类的say方法，外观看上去是只有一个参数 <strong>int x</strong>，实际上，在地层中，该方法会变成有两个参数，即<strong>this指针 与 int x</strong>，所以 this 指针是成员函数的一个隐藏函数</li>
</ul>
</li>
<li>成员方法指针：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234921.png" alt="image-20210307161658038"></li>
<li>p 指针只能用来存储普通方法地址，不能用来存储成员存储成员方法的地址；因为普通函数指针没有隐藏的this指针变量，这样，参数数量不对等，直接不匹配；</li>
<li>需要这样定义成员方法指针：</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234926.png" alt="image-20210307162836539"></li>
<li>成员方法作用：</li>
</ul>
</li>
</ul>
<h4 id="代码演示：-1"><a href="#代码演示：-1" class="headerlink" title="代码演示："></a>代码演示：</h4><ul>
<li><p><strong>成员方法指针</strong>与<strong>成员属性指针</strong>，都可以看成是字段的等价替换</p>
</li>
<li><p>((void **)(&amp;b))[0] = ((void **)(&amp;c))[0]; </p>
<blockquote>
<p>关于<code>(void **)(&amp;b)</code>的理解可以查看<a href="https://blog.csdn.net/wcybrain/article/details/78300445">这里</a>、<a href="https://www.cnblogs.com/wubugui/p/4247733.html">这里</a></p>
<p>在c++中<strong>void*** 可以接收所有类型的指针，但是反之不可。在c中*<em>void</em></strong>既可以赋值给任何指针，也可以被任何指针赋值</p>
</blockquote>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="keyword">this</span>-&gt;x = <span class="number">200</span>; <span class="keyword">this</span>-&gt;y = <span class="number">400</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this-&gt;x = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class A say &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class A run &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reg1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reg2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reg3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reg4&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reg5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reg5&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; x = <span class="number">300</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class B say &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; x = <span class="number">400</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Class C run &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC(a) func(a, #a)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp;a, <span class="built_in">string</span> class_name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object &quot;</span> &lt;&lt; class_name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    a.say(<span class="number">123</span>);</span><br><span class="line">    a.run();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;==============&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*text)</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a;</span><br><span class="line">    B *b;</span><br><span class="line">    C *c;</span><br><span class="line">    FUNC(a);</span><br><span class="line">    FUNC(b);</span><br><span class="line">    FUNC(c);</span><br><span class="line">    <span class="comment">// 把b 对象的虚函数表指向 c 对象的虚函数表，结果就是 b 对象运行的是 c 对象的方法</span></span><br><span class="line">    ((<span class="keyword">void</span> **)(&amp;b))[<span class="number">0</span>] = ((<span class="keyword">void</span> **)(&amp;c))[<span class="number">0</span>]; </span><br><span class="line">    FUNC(b);</span><br><span class="line">    <span class="comment">// 函数指针赋值</span></span><br><span class="line">    <span class="comment">// 先定义一个函数指针变量 typedef void (*text)(void *, int);</span></span><br><span class="line">    <span class="comment">// 把 b 对象的地址修改为函数指针地址(text **)(&amp;b)</span></span><br><span class="line">    <span class="comment">// 定义到虚函数表 ((text **)(&amp;b))[0]，</span></span><br><span class="line">    <span class="comment">// 虚函数表的第一个函数就是目标虚函数 ((text **)(&amp;b))[0][0](&amp;c, 100)</span></span><br><span class="line">    <span class="comment">// 此时 this 指针指向的是c对象的地址</span></span><br><span class="line">    <span class="comment">// 如果成员方法中有输出this指针的相关成员属性，则都是输出c对象的成员属性，这里this-&gt;x = 400</span></span><br><span class="line">    ((text **)(&amp;b))[<span class="number">0</span>][<span class="number">0</span>](&amp;c, <span class="number">100</span>); </span><br><span class="line">    <span class="comment">// 指向成员方法的成员方法指针</span></span><br><span class="line">    <span class="keyword">void</span> (A::*p[<span class="number">3</span>])();</span><br><span class="line">    <span class="comment">// 指向成员属性的成员属性指针</span></span><br><span class="line">    <span class="keyword">int</span> A::*q;</span><br><span class="line">    q = &amp;A::x; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a.*q) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// (a.*q) 等价于 a.x</span></span><br><span class="line">    p[<span class="number">0</span>] = &amp;A::reg1;</span><br><span class="line">    p[<span class="number">1</span>] = &amp;A::reg2;</span><br><span class="line">    p[<span class="number">2</span>] = &amp;A::reg3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 成员方法指针的调用</span></span><br><span class="line">        (a.*p[rand() % <span class="number">3</span>])();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="dynamaic-cast"><a href="#dynamaic-cast" class="headerlink" title="dynamaic_cast"></a>dynamaic_cast</h3><ul>
<li><p>尝试将一个地址（小括号）转换为目标地址（尖括号），如果转成功，会返回一个地址，否则失败返回一个空地址</p>
<blockquote>
<p>切记，如果是如下面（51-52行）动态申请内存（new ）获得的地址，则dynamaic_cast不会有任何问题。但是如果是如下面（56-57行）直接申请一个对象指针的话，则第59行会报错！！！</p>
<img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310093520.png" alt="image-20210310093316193" style="zoom: 67%;">
</blockquote>
</li>
<li><p>dynamaic_cast 一定是运行期才能实现的行为，而如果将虚函数注释了，则dynamaic_cast报错，因为dynamaic_cast判断是不是父类子类是依靠虚函数表，而如果注释了虚函数，则虚函数表也不见了。</p>
</li>
<li><p>只要类<strong>存在继承关系</strong>，<strong>析构函数一定要设置成虚函数</strong>！！！否则<strong>不能正常析构</strong>，所以也能正常使用dynamaic_cast</p>
<blockquote>
<p>如果没有设置为虚析构函数，则析构函数只是普通成员函数，是跟着类走的，所以只能调用对应类型的析构函数，其他类型的析构函数不会被调用，这样的话其他类就不能正常析构了</p>
</blockquote>
</li>
</ul>
<h4 id="代码演示：-2"><a href="#代码演示：-2" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A constuctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//virtual void say() &#123;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;class A &quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B constuctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void say() &#123;</span></span><br><span class="line">      <span class="comment">//  cout &lt;&lt; &quot;class B &quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C constuctor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//void say() &#123;</span></span><br><span class="line">      <span class="comment">//  cout &lt;&lt; &quot;class C &quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~C() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(A *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">dynamic_cast</span>&lt;B *&gt;(p)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;is class B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">dynamic_cast</span>&lt;C *&gt;(p)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p &lt;&lt;<span class="string">&quot;is class C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    A *p;</span><br><span class="line">    B *b;</span><br><span class="line">    C *c;</span><br><span class="line">    <span class="keyword">switch</span>(rand() % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> : p = <span class="keyword">new</span> B(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> : p = <span class="keyword">new</span> C(); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    judge(p);</span><br><span class="line">    <span class="comment">//delete p; </span></span><br><span class="line">    A *p1 = <span class="keyword">new</span> B(), *p2 = <span class="keyword">new</span> C();</span><br><span class="line">    judge(p1);</span><br><span class="line">    judge(p2);</span><br><span class="line">    swap(((<span class="keyword">void</span> **)p1)[<span class="number">0</span>],       ((<span class="keyword">void</span> **)p2)[<span class="number">0</span>]);</span><br><span class="line">    judge(p1);</span><br><span class="line">    judge(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210309234932.png" alt="image-20210307181115570" style="zoom:50%;">

<ul>
<li><p>父类的某个成员方法是必须的，但是实现该方法是不合理的，这个时候就需要用纯虚函数。</p>
</li>
<li><p>作用：</p>
<ul>
<li><p>父类有<strong>纯虚函数</strong>，<strong>子类一定要对纯虚函数进行实现</strong>，否则无法实例化（创建对象）</p>
</li>
<li><p>用在<strong>父类做规定</strong>，规定<strong>子类必须实现</strong>的方法</p>
<ul>
<li><p>概念：接口：不规定功能，只定义表现形式</p>
<blockquote>
<p>比如USB接口，不要求是用在连接手机或者键盘等，但是其外在表现形式是同样的，都是方方正正的外观等；</p>
<p>再比如，在线程池中定义一个苦力父类，声明三个纯虚函数：取数据、存数据、处理数据，但是怎么存、存到哪，怎么处理不确定，这三个虚函数由子类自定义实现！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一般情况下，用来实现接口</p>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310093640.png" alt="image-20210307191002984" style="zoom:50%;">
</li>
<li><h4 id="代码演示：-3"><a href="#代码演示：-3" class="headerlink" title="代码演示："></a>代码演示：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">string</span> name) : name(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fl1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">string</span> name) : Animal(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can run with four legs&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fl1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> :</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    People(<span class="built_in">string</span> name) : Animal(name)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can run with two legs&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bat(<span class="built_in">string</span> name) : Animal(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I can fly&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    House() : Animal(<span class="string">&quot;House&quot;</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;House, I can run with four legs&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    House h;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>

</li>
</ul>
</li>
</ul>
<h4 id="自己的优先队列："><a href="#自己的优先队列：" class="headerlink" title="自己的优先队列："></a>自己的优先队列：</h4><ul>
<li>了解什么是接口</li>
<li>分别用数组跟堆实现优先队列</li>
<li>感受：接口帮助我们屏蔽了内部实现细节，它只在乎外在表现，所以接口是一个程序设计或者类设计中最重要的部分，因为接口关系着外部函数如何调用该类</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector_queue</span> :</span> <span class="keyword">public</span> IQueue, <span class="keyword">public</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等价于 push_back(x);</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::push_back(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p = <span class="keyword">this</span>-&gt;begin();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin(); iter != end(); iter++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter &gt; *p) p = iter;</span><br><span class="line">        &#125;</span><br><span class="line">        erase(p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = at(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            ans = max(at(i), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_queue</span> :</span> <span class="keyword">public</span> IQueue, <span class="keyword">public</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        up_maintain(size());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(at(<span class="number">0</span>), at(size() - <span class="number">1</span>));</span><br><span class="line">        pop_back();</span><br><span class="line">        down_maintain(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> at(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">up_maintain</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ind &gt; <span class="number">1</span> &amp;&amp; at(ind - <span class="number">1</span>) &gt; at((ind / <span class="number">2</span>) - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(at(ind - <span class="number">1</span>), at((ind / <span class="number">2</span>) - <span class="number">1</span>));</span><br><span class="line">            ind /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">down_maintain</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ind * <span class="number">2</span> &lt;= size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = ind;</span><br><span class="line">            <span class="keyword">if</span> (at(ind * <span class="number">2</span> - <span class="number">1</span>) &gt; at(temp - <span class="number">1</span>)) temp = ind * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ind * <span class="number">2</span> + <span class="number">1</span> &lt;= size() &amp;&amp; at(ind * <span class="number">2</span>) &gt; at(temp - <span class="number">1</span>)) temp = ind * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">std</span>::swap(at(temp - <span class="number">1</span>), at(ind - <span class="number">1</span>));</span><br><span class="line">            ind = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    vector_queue q1;</span><br><span class="line">    heap_queue q2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        q1.push(val);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;push q1 : &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q1.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        q2.push(val);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;push q2 : &quot;</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q2.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h3><p>拥有纯虚函数的类是不能产生对象的，这些类即为抽象类，Animal即为抽象类</p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><img src="https://cdn.jsdelivr.net/gh/a872456824/ImgHosting/Alin-PIC/20210310110648.png" alt="image-20210310110637817" style="zoom:50%;">

<ul>
<li>哈希表需要自己的一个存储空间 </li>
<li>哈希函数：BKDR </li>
<li>冲突处理方法：拉链法<ul>
<li>哈希表类：利用function&lt;int(string)&gt;定义一个哈希函数类型，同时有个成员属性存储该哈希函数</li>
<li>插入、寻找、删除</li>
<li>因为是拉链法，需要由链表，所以定义一个链表节点结构<ul>
<li>成员属性：字符串、下个节点的地址</li>
<li>成员方法：初始化，读取当前节点字符串、下个节点地址next的方法，设置指针的方法，插入，删除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="代码演示第一版："><a href="#代码演示第一版：" class="headerlink" title="代码演示第一版："></a>代码演示第一版：</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node() = <span class="keyword">default</span>;</span><br><span class="line">    Node(<span class="built_in">string</span>, Node *);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">data</span><span class="params">()</span></span>;  <span class="comment">// 获取当前节点的字符</span></span><br><span class="line">    <span class="function">Node *<span class="title">next</span><span class="params">()</span></span>;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *)</span></span>; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase_next</span><span class="params">()</span></span>; <span class="comment">// 删除当前节点的下个节点</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> __data;</span><br><span class="line">    Node *__next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> function&lt;<span class="keyword">int</span>(<span class="built_in">string</span>)&gt; HASH_FUNC_T; <span class="comment">// 定义一个哈希表函数类型</span></span><br><span class="line">    HashTable(HASH_FUNC_T, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 哈希表的容量</span></span><br><span class="line">    HASH_FUNC_T hash_func;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; data; <span class="comment">// 哈希表中的一片连续存储区，每个位置指向一个节点, 存储的是虚拟头节点，方便使用头插法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node::Node(<span class="built_in">string</span> data, Node *next = <span class="literal">nullptr</span>) : __data(data), __next(next) &#123;&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Node::data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__data; &#125;  <span class="comment">// 获取当前节点的字符</span></span><br><span class="line"><span class="function">Node *<span class="title">Node::next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__next; &#125;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::insert</span><span class="params">(Node *p)</span> </span>&#123; p-&gt;__next = <span class="keyword">this</span>-&gt;__next; <span class="keyword">this</span>-&gt;__next = p; &#125; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::erase_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *q = <span class="keyword">this</span>-&gt;__next;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__next = <span class="keyword">this</span>-&gt;__next-&gt;__next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable::HashTable(HASH_FUNC_T hash_func, <span class="keyword">int</span> size = <span class="number">10000</span>) : size(size), data(size), hash_func(hash_func) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::insert</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    data[h].insert(<span class="keyword">new</span> Node(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = data[h].next(); p != <span class="literal">nullptr</span>; p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data() == s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::erase</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = &amp;data[h]; p-&gt;next(); p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next()-&gt;data() != s) <span class="keyword">continue</span>;</span><br><span class="line">        p-&gt;erase_next();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) hash = hash * seed + s[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APHash_Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                h = (h &lt;&lt; <span class="number">3</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = ~(h &lt;&lt; <span class="number">7</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">11</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    APHash_Class APHash;</span><br><span class="line">    <span class="function">HashTable <span class="title">h1</span><span class="params">(BKDRHash)</span></span>;</span><br><span class="line">    <span class="function">HashTable <span class="title">h2</span><span class="params">(APHash)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="代码演示第二版："><a href="#代码演示第二版：" class="headerlink" title="代码演示第二版："></a>代码演示第二版：</h4><ul>
<li>[]重载，使得对外表现像个数组<ul>
<li>从字符串映射到整型</li>
</ul>
</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node() = <span class="keyword">default</span>;</span><br><span class="line">    Node(<span class="built_in">string</span>, <span class="keyword">int</span>, Node *);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">()</span></span>; <span class="comment">// 获取当前节点的字符</span></span><br><span class="line">    <span class="keyword">int</span> value;    <span class="comment">// 返回value值跟设置value值，所以设置成为公有更方便</span></span><br><span class="line">    <span class="function">Node *<span class="title">next</span><span class="params">()</span></span>;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *)</span></span>; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase_next</span><span class="params">()</span></span>; <span class="comment">// 删除当前节点的下个节点</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> __key;</span><br><span class="line">    Node *__next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> function&lt;<span class="keyword">int</span>(<span class="built_in">string</span>)&gt; HASH_FUNC_T; <span class="comment">// 定义一个哈希表函数类型</span></span><br><span class="line">    HashTable(HASH_FUNC_T, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *__insert(<span class="built_in">string</span>, <span class="keyword">int</span>); <span class="comment">// 代表插入方法后的节点地址</span></span><br><span class="line">    Node *__find(<span class="built_in">string</span>); <span class="comment">// 代表插入方法后的节点地址</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 哈希表的容量</span></span><br><span class="line">    HASH_FUNC_T hash_func;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; data; <span class="comment">// 哈希表中的一片连续存储区，每个位置指向一个节点, 存储的是虚拟头节点，方便使用头插法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node::Node(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>, Node *next = <span class="literal">nullptr</span>) : __key(key), value(value), __next(next) &#123;&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Node::key</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__key; &#125;  <span class="comment">// 获取当前节点的字符</span></span><br><span class="line"><span class="function">Node *<span class="title">Node::next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__next; &#125;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::insert</span><span class="params">(Node *p)</span> </span>&#123; p-&gt;__next = <span class="keyword">this</span>-&gt;__next; <span class="keyword">this</span>-&gt;__next = p; &#125; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::erase_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *q = <span class="keyword">this</span>-&gt;__next;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__next = <span class="keyword">this</span>-&gt;__next-&gt;__next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable::HashTable(HASH_FUNC_T hash_func, <span class="keyword">int</span> size = <span class="number">10000</span>) : size(size), data(size), hash_func(hash_func) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> __insert(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *HashTable::__insert(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(key) % size;</span><br><span class="line">    data[h].insert(<span class="keyword">new</span> Node(key, value));</span><br><span class="line">    <span class="keyword">return</span> data[h].next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __find(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装两层，看起来优美点</span></span><br><span class="line">Node* HashTable::__find(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = data[h].next(); p != <span class="literal">nullptr</span>; p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key() == s) <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::erase</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = &amp;data[h]; p-&gt;next(); p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next()-&gt;key() != s) <span class="keyword">continue</span>;</span><br><span class="line">        p-&gt;erase_next();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) hash = hash * seed + s[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过__find(key) 查找，如果为空，就通过__insert(key) 插入新节点，并返回其value</span></span><br><span class="line"><span class="comment">// 如果不为空，直接返回该value</span></span><br><span class="line"><span class="comment">// 这样看起来优美很多</span></span><br><span class="line"><span class="keyword">int</span> &amp;HashTable::<span class="keyword">operator</span>[](<span class="built_in">string</span> key) &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (!(p = __find(key))) <span class="keyword">return</span> (__insert(key)-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APHash_Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                h = (h &lt;&lt; <span class="number">3</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = ~(h &lt;&lt; <span class="number">7</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">11</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    APHash_Class APHash;</span><br><span class="line">    <span class="function">HashTable <span class="title">h1</span><span class="params">(BKDRHash)</span></span>;</span><br><span class="line">    <span class="function">HashTable <span class="title">h2</span><span class="params">(APHash)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    h1[<span class="string">&quot;hello&quot;</span>] = <span class="number">123</span>;</span><br><span class="line">    h1[<span class="string">&quot;world&quot;</span>] = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h1[<span class="string">&quot;world&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h1[<span class="string">&quot;hahaha&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="代码演示第三版："><a href="#代码演示第三版：" class="headerlink" title="代码演示第三版："></a>代码演示第三版：</h4><ul>
<li>扩容</li>
</ul>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        打不开请刷新一下页面
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node() = <span class="keyword">default</span>;</span><br><span class="line">    Node(<span class="built_in">string</span>, <span class="keyword">int</span>, Node *);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">()</span></span>; <span class="comment">// 获取当前节点的字符</span></span><br><span class="line">    <span class="keyword">int</span> value;    <span class="comment">// 返回value值跟设置value值，所以设置成为公有更方便</span></span><br><span class="line">    <span class="function">Node *<span class="title">next</span><span class="params">()</span></span>;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *)</span></span>; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase_next</span><span class="params">()</span></span>; <span class="comment">// 删除当前节点的下个节点</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> __key;</span><br><span class="line">    Node *__next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> function&lt;<span class="keyword">int</span>(<span class="built_in">string</span>)&gt; HASH_FUNC_T; <span class="comment">// 定义一个哈希表函数类型</span></span><br><span class="line">    HashTable(HASH_FUNC_T, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="built_in">string</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *__insert(<span class="built_in">string</span>, <span class="keyword">int</span>); <span class="comment">// 代表插入方法后的节点地址</span></span><br><span class="line">    Node *__find(<span class="built_in">string</span>); <span class="comment">// 代表插入方法后的节点地址</span></span><br><span class="line">    <span class="keyword">void</span> __expand();</span><br><span class="line">    <span class="keyword">int</span> size, data_cnt;  <span class="comment">// 哈希表的容量</span></span><br><span class="line">    HASH_FUNC_T hash_func;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; data; <span class="comment">// 哈希表中的一片连续存储区，每个位置指向一个节点, 存储的是虚拟头节点，方便使用头插法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node::Node(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>, Node *next = <span class="literal">nullptr</span>) : __key(key), value(value), __next(next) &#123;&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Node::key</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__key; &#125;  <span class="comment">// 获取当前节点的字符</span></span><br><span class="line"><span class="function">Node *<span class="title">Node::next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__next; &#125;  <span class="comment">//  获取当前节点的 *next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::insert</span><span class="params">(Node *p)</span> </span>&#123; p-&gt;__next = <span class="keyword">this</span>-&gt;__next; <span class="keyword">this</span>-&gt;__next = p; &#125; <span class="comment">// 当前节点的下个节点插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::erase_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *q = <span class="keyword">this</span>-&gt;__next;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__next = <span class="keyword">this</span>-&gt;__next-&gt;__next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable::HashTable(HASH_FUNC_T hash_func, <span class="keyword">int</span> size = <span class="number">10000</span>)</span><br><span class="line">: size(size), data(size), hash_func(hash_func), data_cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashTable::capacity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> __insert(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *HashTable::__insert(<span class="built_in">string</span> key, <span class="keyword">int</span> value = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data_cnt &gt;= size * <span class="number">2</span>) __expand();</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(key) % size;</span><br><span class="line">    data[h].insert(<span class="keyword">new</span> Node(key, value));</span><br><span class="line">    data_cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> data[h].next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HashTable::__expand() &#123;</span><br><span class="line">    <span class="keyword">int</span> new_size = size * <span class="number">2</span>;</span><br><span class="line">    <span class="function">HashTable <span class="title">temp_h</span><span class="params">(hash_func, new_size)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node *p = data[i].next(); p; p = p-&gt;next()) &#123;</span><br><span class="line">            temp_h[p-&gt;key()] = p-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(temp_h, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __find(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* HashTable::__find(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = data[h].next(); p != <span class="literal">nullptr</span>; p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;key() == s) <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HashTable::erase</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash_func(s) % size;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = &amp;data[h]; p-&gt;next(); p = p-&gt;next()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next()-&gt;key() != s) <span class="keyword">continue</span>;</span><br><span class="line">        p-&gt;erase_next();</span><br><span class="line">        data_cnt -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) hash = hash * seed + s[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切记，返回的是引用！！！这样返回的就是该节点对应的value值</span></span><br><span class="line"><span class="comment">// 因为是该节点本身，所以在h1[&quot;hello&quot;] = 123 时才能把 h1[&quot;hello&quot;] 这个节点的value 设置为123</span></span><br><span class="line"><span class="keyword">int</span> &amp;HashTable::<span class="keyword">operator</span>[](<span class="built_in">string</span> key) &#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (!(p = __find(key))) <span class="keyword">return</span> (__insert(key)-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APHash_Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">                h = (h &lt;&lt; <span class="number">3</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = ~(h &lt;&lt; <span class="number">7</span>) ^ s[i] ^ (h &gt;&gt; <span class="number">11</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    APHash_Class APHash;</span><br><span class="line">    <span class="function">HashTable <span class="title">h1</span><span class="params">(BKDRHash)</span></span>;</span><br><span class="line">    <span class="function">HashTable <span class="title">h2</span><span class="params">(APHash)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    h1[<span class="string">&quot;hello&quot;</span>] = <span class="number">123</span>;</span><br><span class="line">    h1[<span class="string">&quot;world&quot;</span>] = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h1[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h1[<span class="string">&quot;world&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h1[<span class="string">&quot;hahaha&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Insert &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.insert(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Erase &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.erase(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 1 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h1.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Find &quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot; to hash table 2 = &quot;</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; h2.find(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件的传输</title>
    <url>/2021/01/16/0031.%20%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="文件的传输"><a href="#文件的传输" class="headerlink" title="文件的传输"></a>文件的传输</h1><ul>
<li><p>用套接字发送一个简短的信息，是一个字节流；发送一个文件，也是一个字节流。</p>
<blockquote>
<p>不考虑应用层的情况下， 在运输层、网络层以及数据链路层来说，不管是信息、文件、信息还是其他，都是数据流，都是一个一个的协议传输单元。</p>
</blockquote>
</li>
<li><p>不同：把文件通过某种形式转换成信息流、字节流，然后在通过套接字发送出去并保存在某个地方。 </p>
</li>
</ul>
<h2 id="基于epoll实现文件传递"><a href="#基于epoll实现文件传递" class="headerlink" title="基于epoll实现文件传递"></a>基于epoll实现文件传递</h2><ul>
<li><p>使用：</p>
<ul>
<li><p>通过客户端发送一个文件，该文件会被其他人都收到</p>
</li>
<li><p>发送的文件到达目的地时，文件名一样（发送文件名）</p>
<ul>
<li><p>双链接：一条长连接发送信息，一条短连接发送数据</p>
<ul>
<li>实现比下面的方式会难一点，但是很不错</li>
</ul>
<blockquote>
<p>如果不用双连接，而是使用单连接，在每次发送文件前，先给对方发信息通知对方要发送什么文件，然后在发送文件；这样的话，有一个bug，因为对方并不知道什么时候发完文件！！！如果这个时候发送一句话，也有可能被当成是文件，而不是信息！而且，如果中间文件丢了的话，也不好处理。</p>
</blockquote>
</li>
<li><p>TCP协议是可靠传输协议，但是如果一次性通过一条连接传输所有数据，可能会出现数据报粘连，而对于业务层来说，要解决的不是丢失问题，而是数据报能不能进行分离或者按照要求展示出来</p>
<blockquote>
<p>当然也可以一条连接，就是在传输之前先约定好传输的数据长度，没接收一个数据，长度加一，直到达到长度要求，达到之后再解析数据报得到信息。 </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>功能需求（广播）：</p>
<ul>
<li>定时上线接收信息，所以发送频率不能太快</li>
<li>为每个人维护一个资源（广播信息），即每个人都给给其他人共享一段信息（以图片为例），命名规则为每个人独特的用户名</li>
<li>当用户上线之后，发送一个<code>receive</code>指令之后，系统会把除了该用户以外的其他所有用户的图片一一发送给该用户</li>
<li>指令<code>send + 图片</code>就是把图片重命名为<code>用户名</code>并上传到服务端，让服务端去维护它</li>
</ul>
</li>
<li><p>用 sleep 来控制程序的流程，是最简单的。</p>
<blockquote>
<p>尽量别让人看到，免得被笑死，毕竟就像无论什么题都直接无脑暴力法解决一样。   </p>
</blockquote>
</li>
<li><p>用<code>telnet</code>连接的时候，第一次比较慢，原因是路由表，第一次的时候不知道怎么走，第二次连接的时候，已经明确了线路，走起来比较顺畅</p>
</li>
<li><p>发送图片（<code>send + 文件名</code>）：</p>
<ul>
<li>在server端，让程序自己根据 client端的选择执行流程的时候，尽量不要用字符串来分析，而是应该用明确的数据，能够直接验证判断应该走哪个逻辑。</li>
<li>可以定义位掩码 </li>
<li>本地客户端必须用字符串匹配，以便分辨出是<code>send</code>还是<code>recv</code>，亦或是什么都不是  <ul>
<li>如果是<code>send</code>：打开文件，读取文件，发送<ul>
<li>但是因为是选择双链接，即在发送数据之前，应该先跟对方建立一条连接</li>
<li>epoll，发送数据之前先跟对方确认。可以定义一个宏定义(<code>filesend </code>)，先发送这个数据给服务端，服务端收到之后，默默启动一个监听套接字， 同时这个套接字需要让客户端知道<ul>
<li>方式一：服务端建立一个固定端口的套接字，客户端只向固定端口发信息。但问题是，如果有多个客户端都向该端口发送信息，服务端很难分辨信息都是来自哪里。服务端可以通过字符串匹配等来分别识别出信息都是来自哪个客户端，但这样工作量太大！</li>
<li><strong>（优选）方式二</strong>：客户端发起建立连接请求的同时，会自己建立一个监听套接字，当服务端收到请求后，通过自己在本地新申请的TCP套接字，反向连接客户端；但是问题是NAT模式下，局域网可以通过这个模式跟外面的机器建立通讯来回传递信息，如果在局域网内部建立一个端口，然后希望服务端通过网络来连接本地的端口，有难度，因为服务器压根访问不到该端口，因为NAT是由内而外，就是服务端得发送个请求消息，一来一回才能建立，而这种方式，就是希望服务端直接单程就连接到客户端，比难</li>
<li>方式三：沿途每到一个路由器，就让路由器建立一个NAT，让远端端口机器来连接，这个方式是下沉到了网络层，而不是应用层的程序，即告诉全程的所有机器，让它们为它建立一条通道，这个十分的麻烦，不合适！</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><h4 id="common-h"><a href="#common-h" class="headerlink" title="common.h"></a>common.h</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMMON_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">make_block</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_str_nonblock</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buff, <span class="keyword">long</span> size, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="common-c"><a href="#common-c" class="headerlink" title="common.c"></a>common.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_nonblock</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">make_block</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span> ((flag = fcntl(fd, F_GETFL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag &amp;= ~O_NONBLOCK;</span><br><span class="line">    <span class="keyword">return</span> fcntl(fd, F_SETFL, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不设置定时收取信息，则可能会因为一直没收道信息、同时连接数一直增加导致最终服务器无法再连接任何一个客户端</span></span><br><span class="line"><span class="comment">// 定时检查收到的信息，如果限时内收到信息，就返回buff，如果没有收到就返回错误</span></span><br><span class="line"><span class="comment">// timeout为微秒</span></span><br><span class="line"><span class="comment">// 在timeout时间内，从sockfd那里收取size大小的信息，存到buff中。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_str_nonblock</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buff, <span class="keyword">long</span> size, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用man手册中select的例子</span></span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="comment">// 查看标准输入文件，看看是否有输入。清空rfds，并将rfds加入到sockfd中</span></span><br><span class="line">    FD_ZERO(&amp;rfds);</span><br><span class="line">    FD_SET(sockfd, &amp;rfds);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//设置等待时间</span></span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = timeout;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 设置select，使其阻塞，并判断返回值，如果大于0，开始收数据</span></span><br><span class="line">    <span class="keyword">if</span> ((retval = select(sockfd + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 收取数据，从sockfd中收取size大小的数据，存放到buff中</span></span><br><span class="line">    <span class="keyword">int</span> rsize = recv(sockfd, buff, size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (rsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="cmd-h"><a href="#cmd-h" class="headerlink" title="cmd.h"></a>cmd.h</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CMD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CMD_H</span></span><br><span class="line"><span class="comment">// 定义了比特掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEND 0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECV 0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL 0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="1-server-c"><a href="#1-server-c" class="headerlink" title="1.server.c"></a>1.server.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLIENTS 100 <span class="comment">// 最大的连接数量，最大的客户数量</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Client</span> &#123;</span>         <span class="comment">// 客户结构体</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> online;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port, epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create(<span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = server_listen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, server_listen, &amp;ev) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// // 申请空间,用于存储客户</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Client</span> *<span class="title">users</span> =</span> (struct Client *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Client) * MAX_EVENTS); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_listen) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogIn&gt; : %s login...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                <span class="comment">// 把 sockfd 设置为非阻塞</span></span><br><span class="line">                make_nonblock(sockfd);</span><br><span class="line">                <span class="comment">// 在跟客户第一次接触，握完手之后，</span></span><br><span class="line">                <span class="comment">// 需要将对方加到我的epoll实例中以及加到用户列表中</span></span><br><span class="line">                <span class="comment">// 所以客户需要给与服务端名字，如果不给，就把该客户的连接断掉 </span></span><br><span class="line">                <span class="comment">// 判断收到的名字,如果不符合要求，删除并关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (recv_str_nonblock(sockfd, name, <span class="keyword">sizeof</span>(name), <span class="number">1000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LoginError&gt; : %s did not send his name...deleted...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    <span class="comment">// 出错则关闭套接字，关闭连接</span></span><br><span class="line">                    close (sockfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 现在的情况不是一个典型的反应堆或者说是事件驱动的类型，因为每当发一个flag之后，</span></span><br><span class="line">                <span class="comment">// 还需要紧接着发送一个信息或者激活一个业务，所以如果用非阻塞的，</span></span><br><span class="line">                <span class="comment">// 那紧跟着的信息或者业务应该怎么收，等多久收都不能确定，这需要同步，而不是靠循环，</span></span><br><span class="line">                <span class="comment">// 需要一个flag带动一系列的操作，如果用非阻塞的，发送信息的时候，可能都没法展示出来，</span></span><br><span class="line">                <span class="comment">// 因为紧跟着的业务并没有跟着一起运动起来，所以必须在这里改成阻塞的</span></span><br><span class="line">                <span class="comment">// 问题定位方法：sleep 5秒钟，本来客户端发信息时，服务端应该在5秒后才有反应，然而却是立马就接收到了</span></span><br><span class="line">                <span class="comment">// 如果不把非阻塞改为阻塞的话，信息会发送不到服务端</span></span><br><span class="line">                <span class="comment">// 这里可以其实可以一开始就直接不设置非阻，即把make_nonblock(sockfd);去掉</span></span><br><span class="line">                make_block(sockfd);</span><br><span class="line">                <span class="comment">// 符合要求，发送欢迎对方加入的信息</span></span><br><span class="line">                <span class="comment">// 这里其实可以多一个功能，就是验证密钥！这里不实现</span></span><br><span class="line">                send(sockfd, <span class="string">&quot;Welcome!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;Welcome!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 存储用户以及在线用户数量</span></span><br><span class="line">                users[sockfd].fd = sockfd;</span><br><span class="line">                <span class="built_in">strcpy</span>(users[sockfd].name, name);</span><br><span class="line">                users[sockfd].online = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让程序自己根据 client端的选择执行流程的时候，尽量不要用字符串来分析，</span></span><br><span class="line">                <span class="comment">// 而是应该用明确的数据，能够直接验证判断应该走哪个逻辑</span></span><br><span class="line">                <span class="comment">// 可以定义一个位掩码，此处定义位掩码</span></span><br><span class="line">                <span class="comment">// epoll的边缘模式跟水平模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sockfd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印出用户成功从哪里登录，这个时候，用户已经被加入到epoll实例中</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogInSuccess&gt; : %s login on %s...\n&quot;</span>, name, inet_ntoa(client.sin_addr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do_use_fd(events[i].data.fd);</span></span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> rsize = <span class="number">0</span>, fd = events[i].data.fd;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                getpeername(fd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="comment">// 检测客户端是否有发信息过来，如果有，就接收并打印，如果没有就报错</span></span><br><span class="line">                <span class="comment">// flag指针类型记得修改</span></span><br><span class="line">                <span class="keyword">if</span> ((rsize = recv(fd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(flag), <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogOut&gt; : %s logout...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断对方发送的是什么信息</span></span><br><span class="line">                    <span class="keyword">if</span> (flag &amp; SEND) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client send data...\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; RECV) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client want recv data...\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; NORMAL) &#123;</span><br><span class="line">                        recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s\n&quot;</span>, users[fd].name, buff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="1-client-c"><a href="#1-client-c" class="headerlink" title="1.client.c"></a>1.client.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">20</span>] = <span class="string">&quot;alin&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s ip port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    signal(SIGINT, logout);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经连接上服务端，此时第一件事就是把名字发送给服务端</span></span><br><span class="line">    send(sockfd, name, <span class="built_in">strlen</span>(name), <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 收取服务端发送过来的确认信息，如果没有收到，报错。</span></span><br><span class="line">    <span class="keyword">if</span> (recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收到服务端的确认信息，并打印出来</span></span><br><span class="line">    <span class="comment">// 不过这种接收，并不能保证一定连接上，只是说明服务端发送了信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;Server&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// （方式二）客户端建立监听套接字，服务端反向连接</span></span><br><span class="line">        <span class="comment">// cmd用来收取命令</span></span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, cmd);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strlen</span>(cmd)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 字符串匹配指令</span></span><br><span class="line">        <span class="comment">// s a.txt 发送</span></span><br><span class="line">        <span class="comment">// r 收</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(cmd) == <span class="number">1</span> &amp;&amp; cmd[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">            flag |= RECV;</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Here recv!\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; cmd[<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取文件名</span></span><br><span class="line">            flag |= SEND;</span><br><span class="line">            <span class="keyword">char</span> file[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strcpy</span>(file, cmd + <span class="number">2</span>);</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;filename = %s\n&quot;</span>, file);</span><br><span class="line">            <span class="comment">// 发送文件名</span></span><br><span class="line">            <span class="comment">// alin.jpg</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// flag 标识好发送，给服务端发送过去，服务端收到之后，就会之后客户端准备发信息</span></span><br><span class="line">            flag |= NORMAL;</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            send(sockfd, cmd, <span class="built_in">strlen</span>(cmd), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="完善："><a href="#完善：" class="headerlink" title="完善："></a>完善：</h3><p>问题：</p>
<ol>
<li><p>代码很深，逻辑很深，不太好，可以把epoll对事件的处理用函数封装起来</p>
</li>
<li><p>目前用户已经可以成功加到反应堆中（epoll实例，epoll的响应机制特别像反应堆，即一个连接进去后会触发很多的操作，类似反应堆的概念）</p>
</li>
<li><p>获取文件大小，可以用 stat，或者 lstat，或者用 fseek</p>
</li>
<li><p><code>strrchr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>找到的话返回一个匹配字符的指针，没找到的话，返回NULL </li>
<li>通过这个函数获得最终的文件名</li>
</ul>
</li>
<li><p>注意粘包情况：本来是打算发文件名，结果客户端把文件名跟内容一起打印了，原因是文件名与内容连在了一起，系统分辨不出什么时候结束！</p>
<ul>
<li>写应用程序的时候，千万不能用等待的做法，学习的时候可以</li>
<li>解决：一方说一句，另一方重复一句，不重复不罢休</li>
<li>语法、语义、同步</li>
<li>粘包属于同步问题</li>
</ul>
</li>
<li><p>传送文件成功之后，出现乱码情况，以及数据传多了的情况</p>
<ul>
<li>乱码是因为使用了fread，fopen的情况，应该改为read、open，以二进制的方式传输</li>
</ul>
</li>
<li><p>文件可以传输了，图片却还是不可以，传输了之后，图片被损坏了</p>
<ul>
<li>原因：需要以二进制来传输</li>
</ul>
</li>
</ol>
<h4 id="1-server-c-1"><a href="#1-server-c-1" class="headerlink" title="1.server.c"></a>1.server.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLIENTS 100 <span class="comment">// 最大的连接数量，最大的客户数量</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Client</span> &#123;</span>         <span class="comment">// 客户结构体</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> online;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port, epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create(<span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = server_listen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, server_listen, &amp;ev) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// // 申请空间,用于存储客户</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Client</span> *<span class="title">users</span> =</span> (struct Client *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Client) * MAX_EVENTS); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_listen) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogIn&gt; : %s login...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                <span class="comment">// 把 sockfd 设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 这里如果不设置为非阻塞，需要思考会不会对recv_str_nonblock 造成影响</span></span><br><span class="line">                <span class="comment">// 事实上，不设置非阻塞也不会对其造成影响，因为阻塞是阻塞在select</span></span><br><span class="line">                <span class="comment">// 对于阻塞和非阻塞套接字，select都会等待，除非参数设置为非等待</span></span><br><span class="line">                <span class="comment">// make_nonblock(sockfd);   </span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在跟客户第一次接触，握完手之后，</span></span><br><span class="line">                <span class="comment">// 需要将对方加到我的epoll实例中以及加到用户列表中</span></span><br><span class="line">                <span class="comment">// 所以客户需要给与服务端名字，如果不给，就把该客户的连接断掉 </span></span><br><span class="line">                <span class="comment">// 判断收到的名字,如果不符合要求，删除并关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (recv_str_nonblock(sockfd, name, <span class="keyword">sizeof</span>(name), <span class="number">1000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LoginError&gt; : %s did not send his name...deleted...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    <span class="comment">// 出错则关闭套接字，关闭连接</span></span><br><span class="line">                    close (sockfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 现在的情况不是一个典型的反应堆或者说是事件驱动的类型，因为每当发一个flag之后，</span></span><br><span class="line">                <span class="comment">// 还需要紧接着发送一个信息或者激活一个业务，所以如果用非阻塞的，</span></span><br><span class="line">                <span class="comment">// 那紧跟着的信息或者业务应该怎么收，等多久收都不能确定，这需要同步，而不是靠循环，</span></span><br><span class="line">                <span class="comment">// 需要一个flag带动一系列的操作，如果用非阻塞的，发送信息的时候，可能都没法展示出来，</span></span><br><span class="line">                <span class="comment">// 因为紧跟着的业务并没有跟着一起运动起来，所以必须在这里改成阻塞的</span></span><br><span class="line">                <span class="comment">// 问题定位方法：sleep 5秒钟，本来客户端发信息时，服务端应该在5秒后才有反应，然而却是立马就接收到了</span></span><br><span class="line">                <span class="comment">// 如果不把非阻塞改为阻塞的话，信息会发送不到服务端</span></span><br><span class="line">                <span class="comment">// 这里可以其实可以一开始就直接不设置非阻，即把make_nonblock(sockfd);去掉</span></span><br><span class="line">                <span class="comment">// make_block(sockfd);</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 符合要求，发送欢迎对方加入的信息</span></span><br><span class="line">                <span class="comment">// 这里其实可以多一个功能，就是验证密钥！这里不实现</span></span><br><span class="line">                send(sockfd, <span class="string">&quot;Welcome!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;Welcome!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 存储用户以及在线用户数量</span></span><br><span class="line">                users[sockfd].fd = sockfd;</span><br><span class="line">                <span class="built_in">strcpy</span>(users[sockfd].name, name);</span><br><span class="line">                users[sockfd].online = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让程序自己根据 client端的选择执行流程的时候，尽量不要用字符串来分析，</span></span><br><span class="line">                <span class="comment">// 而是应该用明确的数据，能够直接验证判断应该走哪个逻辑</span></span><br><span class="line">                <span class="comment">// 可以定义一个位掩码，此处定义位掩码</span></span><br><span class="line">                <span class="comment">// epoll的边缘模式跟水平模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sockfd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印出用户成功从哪里登录，这个时候，用户已经被加入到epoll实例中</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogInSuccess&gt; : %s login on %s...\n&quot;</span>, name, inet_ntoa(client.sin_addr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do_use_fd(events[i].data.fd);</span></span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> rsize = <span class="number">0</span>, fd = events[i].data.fd;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                getpeername(fd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="comment">// 检测客户端是否有发信息过来，如果有，就接收并打印，如果没有就报错</span></span><br><span class="line">                <span class="comment">// flag指针类型记得修改</span></span><br><span class="line">                <span class="keyword">if</span> ((rsize = recv(fd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(flag), <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogOut&gt; : %s logout...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断对方发送的是什么信息</span></span><br><span class="line">                    <span class="keyword">if</span> (flag &amp; SEND) &#123;</span><br><span class="line">                        <span class="keyword">char</span> name[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, file_path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client send data...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 收取文件的大小信息</span></span><br><span class="line">                        <span class="keyword">ssize_t</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> ack = <span class="number">1</span>;</span><br><span class="line">                        recv(fd, (<span class="keyword">void</span> *)&amp;size, <span class="keyword">sizeof</span>(size), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 收取文件名字</span></span><br><span class="line">                        recv(fd, name, <span class="keyword">sizeof</span>(name), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 发送ack，方便同步</span></span><br><span class="line">                        send(fd, (<span class="keyword">char</span> *)&amp;ack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 打印文件名字</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;filename = %s\n&quot;</span>, name);</span><br><span class="line">                        <span class="comment">// 打开一个文件，方便把收到的数据写进去</span></span><br><span class="line">                        <span class="comment">// 如果没有data文件夹，会显示不存在该文件夹</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(file_path, <span class="string">&quot;./data/%s&quot;</span>, name);</span><br><span class="line">                        FILE *fp = fopen(file_path, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">                        <span class="comment">// 如果没有该判断，那可能会从一个null指针上打开一个文件流，就会产生段错误</span></span><br><span class="line">                        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                            perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 收数据</span></span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">ssize_t</span> tmp = recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 写文件</span></span><br><span class="line">                            fwrite(buff, <span class="number">1</span>, tmp, fp);</span><br><span class="line">                            sum += tmp;</span><br><span class="line">                            <span class="comment">// 文件收齐</span></span><br><span class="line">                            <span class="keyword">if</span> (sum &gt;= size) &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;File transfer finished!\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fclose(fp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; RECV) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client want recv data...\n&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; NORMAL) &#123;</span><br><span class="line">                        recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s\n&quot;</span>, users[fd].name, buff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="1-client-c-1"><a href="#1-client-c-1" class="headerlink" title="1.client.c"></a>1.client.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最终文件名</span></span><br><span class="line"><span class="comment">// 可以写在一个函数中，返回一个字符串</span></span><br><span class="line"><span class="comment">// 或者把找到的东西放在传输参数中，变成这个函数的参数，这样就不用额外的空间，也不用return了</span></span><br><span class="line"><span class="comment">// 两种方式，这里选择传输参数的形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_name</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果没找到，path就是name</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(name, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(name, ptr + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd, port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">20</span>] = <span class="string">&quot;alin&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s ip port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    signal(SIGINT, logout);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经连接上服务端，此时第一件事就是把名字发送给服务端</span></span><br><span class="line">    send(sockfd, name, <span class="built_in">strlen</span>(name), <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 收取服务端发送过来的确认信息，如果没有收到，报错。</span></span><br><span class="line">    <span class="keyword">if</span> (recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收到服务端的确认信息，并打印出来</span></span><br><span class="line">    <span class="comment">// 不过这种接收，并不能保证一定连接上，只是说明服务端发送了信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;Server&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// （方式二）客户端建立监听套接字，服务端反向连接</span></span><br><span class="line">        <span class="comment">// cmd用来收取命令</span></span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, cmd);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strlen</span>(cmd)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 字符串匹配指令</span></span><br><span class="line">        <span class="comment">// s a.txt 发送</span></span><br><span class="line">        <span class="comment">// r 收</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(cmd) == <span class="number">1</span> &amp;&amp; cmd[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">            flag |= RECV;</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Here recv!\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; cmd[<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取文件名</span></span><br><span class="line">            flag |= SEND;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> file[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strcpy</span>(file, cmd + <span class="number">2</span>);</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;filename = %s\n&quot;</span>, file);</span><br><span class="line">            <span class="comment">// 获取文件大小</span></span><br><span class="line">            FILE *fp = fopen(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">				<span class="comment">// 设置文件指针，使其指向末尾</span></span><br><span class="line">            fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">            	<span class="comment">// 获取文件流的大小</span></span><br><span class="line">            <span class="keyword">ssize_t</span> size = ftell(fp);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送文件大小</span></span><br><span class="line">            send(sockfd, (<span class="keyword">void</span> *)&amp;size, <span class="keyword">sizeof</span>(size), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 发送文件名 alin.jpg</span></span><br><span class="line">            get_name(file, name);</span><br><span class="line">            send(sockfd, (<span class="keyword">void</span> *)&amp;name, <span class="built_in">strlen</span>(name), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 接收服务端发送的ack,方便同步</span></span><br><span class="line">            recv(sockfd, (<span class="keyword">char</span> *)&amp;ack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 两次recv 就不会出现黏包问题，可是逻辑上不应该有两次！</span></span><br><span class="line">            <span class="comment">// recv(sockfd, (char *)&amp;ack, sizeof(int), 0);</span></span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error in ACK!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 发送文件前先把文件指针移至开头，避免读不到内容</span></span><br><span class="line">            fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读文件</span></span><br><span class="line">                <span class="comment">// 每次从fd中读取一个，重复读1024次</span></span><br><span class="line">                <span class="keyword">int</span> rsize = fread(buffer, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">               	<span class="comment">// 这里通过单词返回值判断是否出错，来决定是否停止读取</span></span><br><span class="line">                <span class="comment">// 也可以通过累积量，因为size知道，通过累计，直到size的时候停止读取</span></span><br><span class="line">                <span class="keyword">if</span> (rsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read success!...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送文件给服务端</span></span><br><span class="line">                <span class="comment">// 可以先发一个文档，再发一张图片，来看看会不会出错</span></span><br><span class="line">                send(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(fp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// flag 标识好发送，给服务端发送过去，服务端收到之后，就会之后客户端准备发信息</span></span><br><span class="line">            flag |= NORMAL;</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            send(sockfd, cmd, <span class="built_in">strlen</span>(cmd), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h2 id="C-S文件传输软件的设计与实现（粘包与拆包）"><a href="#C-S文件传输软件的设计与实现（粘包与拆包）" class="headerlink" title="C/S文件传输软件的设计与实现（粘包与拆包）"></a>C/S文件传输软件的设计与实现（粘包与拆包）</h2><ul>
<li>在进行网络传输的时候，特别是在应用层的时候，不会去关注网络层、运输层会分成什么样的密度去传输，人们只在意数据能否顺利到达客户端、服务端</li>
<li>所以，文件传输实际上是应用层的传输，不是运输层、网络层的传输</li>
</ul>
<h3 id="为什么要写这个软件"><a href="#为什么要写这个软件" class="headerlink" title="为什么要写这个软件"></a>为什么要写这个软件</h3><img src="/2021/01/16/0031/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210311084719724.png" alt="image-20210311084719724" style="zoom:50%;">

<ul>
<li>理解整包、拆包、粘包<ul>
<li>整包：一端发送指定大小的数据，另一端收到同样大小的数据，整包直接交付就可以<ul>
<li><img src="/2021/01/16/0031/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210311084953795.png" alt="image-20210311084953795" style="zoom:50%;"></li>
</ul>
</li>
<li>拆包：一段发送一段数据，另一端收到的数据被拆分成了两份（流量控制）<ul>
<li><img src="/2021/01/16/0031/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210311085115109.png" alt="image-20210311085115109" style="zoom:50%;"></li>
</ul>
</li>
<li>粘包：两个文件包收到时粘连在一起，不能分隔开<ul>
<li><img src="/2021/01/16/0031/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210311084843125.png" alt="image-20210311084843125" style="zoom:50%;"></li>
</ul>
</li>
<li>拆包跟粘包如果都有，就会出现”拆包——粘包——拆包——粘包”的循环情况，发送了一次拆包之后，就很容易发送粘包！</li>
<li>流程：<ul>
<li>offset表示一个偏移量，表示数据从哪个位置开始存储</li>
<li> 现在收到对端一个满的数据包，此时的 offset 也在一个0值，意味着可以完整的接收整个数据包，这就是<strong>整包</strong>！</li>
<li>并不能每次都能收到一个整包，有可能你发送一个整包，可是中间快递发现量太大，装不下，就只能拆开发送，即在应用层可能发送完整一个包，可是在运输层却是被切片发送，这个时候就是<strong>拆包</strong>，这个时候，会先把收到的数据包接受了，然后调整offset的位置，等待下次的接收。如果收到的那部分数据包，缺失了开头，收到的部分不能按顺序拼接起来的话，协议不会收走这些包，而是等开头的数据到了，一起就绪了，才会收！</li>
<li>如果最后收到的数据包的大小，超过流量窗口剩余的空间的话，就是<strong>粘包</strong>了，这个时候，会按照窗口剩余空间的大小，把收到的数据包切开，一部分交给offset位置，拼成一个整包交付，另一部分先交给一个临时区，并记录此时临时区的offset，在下次收到数据时，先把临时区的数据移交给packet窗口，然后循环切割分离粘连数据包的问题</li>
</ul>
</li>
</ul>
</li>
<li>理解拆包和粘包的产生原因，掌握处理方法</li>
<li>进一步了解底层协议乃至所有网络编程中对数据流的处理方法</li>
</ul>
<h3 id="代码最终完善："><a href="#代码最终完善：" class="headerlink" title="代码最终完善："></a>代码最终完善：</h3><ul>
<li>上一份代码的bug<ol>
<li>文件传过去之后，文本的，会出现乱码</li>
<li>不是文本的，最终大小变小了！（如果是文本，数据太多，会出现两次接收的情况，这两者同样的问题）</li>
<li>问题在于：上一份代码是通过strlen来获取尺寸，可是如果有确定的尺寸的话，应该直接把确定的值发过去<ul>
<li><img src="/2021/01/16/0031/Users\Alin\AppData\Roaming\Typora\typora-user-images\image-20210312203610696.png" alt="image-20210312203610696"></li>
<li>客户端中，上面的rsize其实就是真实的大小了，所以send 应该发送rsize 大小的数据才对。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="后续功能完善："><a href="#后续功能完善：" class="headerlink" title="后续功能完善："></a>后续功能完善：</h4><ol>
<li>可以做到一次又一次的发文件<ul>
<li>打开目录，有文件就发，没文件就不发</li>
<li>发文件之前先发ack，有文件就 ack = 1， 没文件就 ack = 0；</li>
<li>建立监听端口（9003），由服务端连过来<ul>
<li>通过原先创建好的连接，像服务端发送ack = 1， 表现监听端口已经建立</li>
<li>服务端收到，本地创建空白套接字，然后连到客户端，然后发数据，发完再发送一个ack = 0，就关闭连接，客户端感知到连接关闭，就说明文件已经传达</li>
<li>如果需要第二次传送文件呢？那客户端需要断连吗？这是客户端需要考虑的，现在可以先用服务端跟客户端都关闭，性能低点无所谓，重要的是实现出来</li>
</ul>
</li>
</ul>
</li>
<li>问题：当一个客户这样频繁的下载数据时，因为是单线程，所以当由其他客户需要下载时，就会阻塞到，这样的响应能力就会比较弱，可以通过多线程、或者线程池（最好）来解决</li>
</ol>
<h4 id="1-server-c-2"><a href="#1-server-c-2" class="headerlink" title="1.server.c"></a>1.server.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CLIENTS 100 <span class="comment">// 最大的连接数量，最大的客户数量</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Client</span> &#123;</span>         <span class="comment">// 客户结构体</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> online;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send一个数据，怎么知道tcp一定把这个数据传到对方去了呢？</span></span><br><span class="line"><span class="comment">// send返回之后，才回send_one_file，有没有逻辑问题？</span></span><br><span class="line"><span class="comment">// 或者send返回之后，这个数据到底是交给底层的内核的输出缓冲区了呢，还是说数据已经经由内核到缓冲区传到对方，然后对方传来ack 之后，这边才回返回呢？</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_one_file</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立连接套接字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cli);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">fd_t</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">name_t</span>[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    getpeername(fd, (struct sockaddr *)&amp;cli, &amp;len);</span><br><span class="line">    <span class="keyword">int</span> data = socket_connect(inet_ntoa(cli.sin_addr), <span class="number">9003</span>);</span><br><span class="line">    <span class="keyword">if</span> (data &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要进入目录，可以通过拼接，也可以通过chgdir，这里用拼接，方便点</span></span><br><span class="line">    <span class="built_in">sprintf</span>(<span class="keyword">name_t</span>, <span class="string">&quot;./data/%s&quot;</span>, name);</span><br><span class="line">    <span class="comment">// 传送数据</span></span><br><span class="line">    <span class="comment">// read 与 recv， send 与 write ，本质上其实没什么区别</span></span><br><span class="line">    <span class="comment">// 还是设置文件互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">fd_t</span> = open(<span class="keyword">name_t</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    flock(<span class="keyword">fd_t</span>, LOCK_EX);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num_read = read(<span class="keyword">fd_t</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (send(data, buffer, num_read, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读到了末尾</span></span><br><span class="line">        <span class="keyword">if</span> (num_read == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(data);</span><br><span class="line">    close(<span class="keyword">fd_t</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_files</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dir</span>;</span></span><br><span class="line">    DIR *dirp = opendir(<span class="string">&quot;./data&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ack</span> <span class="title">ack</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ack, <span class="number">0</span>, <span class="keyword">sizeof</span>(ack));</span><br><span class="line">    <span class="keyword">if</span> (dirp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((dir = readdir(dirp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印一下文件名字，找bug</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name = %s\n&quot;</span>, dir-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(dir-&gt;d_name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(dir-&gt;d_name, <span class="string">&quot;..&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// send ack 1</span></span><br><span class="line">        <span class="comment">// connect to data connection</span></span><br><span class="line">        <span class="comment">// close connection</span></span><br><span class="line">        ack.ack = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(ack.name, dir-&gt;d_name);</span><br><span class="line">        send(fd, (<span class="keyword">void</span> *)&amp;ack, <span class="keyword">sizeof</span>(ack), <span class="number">0</span>);</span><br><span class="line">        send_one_file(fd, dir-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send ack 0</span></span><br><span class="line">    ack.ack = <span class="number">0</span>;</span><br><span class="line">    send(fd, (<span class="keyword">void</span> *)&amp;ack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_listen, sockfd, port, epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s port!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((server_listen = socket_create(port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((epollfd = epoll_create(<span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = server_listen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, server_listen, &amp;ev) &lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 申请空间,用于存储客户</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Client</span> *<span class="title">users</span> =</span> (struct Client *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Client) * MAX_EVENTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_listen) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">char</span> name[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                <span class="keyword">if</span> ((sockfd = accept(server_listen, (struct sockaddr *)&amp;client, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogIn&gt; : %s login...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                <span class="comment">// 把 sockfd 设置为非阻塞</span></span><br><span class="line">                <span class="comment">// 这里如果不设置为非阻塞，需要思考会不会对recv_str_nonblock 造成影响</span></span><br><span class="line">                <span class="comment">// 事实上，不设置非阻塞也不会对其造成影响，因为阻塞是阻塞在select</span></span><br><span class="line">                <span class="comment">// 对于阻塞和非阻塞套接字，select都会等待，除非参数设置为非等待</span></span><br><span class="line">                <span class="comment">// make_nonblock(sockfd);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在跟客户第一次接触，握完手之后，</span></span><br><span class="line">                <span class="comment">// 需要将对方加到我的epoll实例中以及加到用户列表中</span></span><br><span class="line">                <span class="comment">// 所以客户需要给与服务端名字，如果不给，就把该客户的连接断掉</span></span><br><span class="line">                <span class="comment">// 判断收到的名字,如果不符合要求，删除并关闭连接</span></span><br><span class="line">                <span class="keyword">if</span> (recv_str_nonblock(sockfd, name, <span class="keyword">sizeof</span>(name), <span class="number">1000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LoginError&gt; : %s did not send his name...deleted...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    <span class="comment">// 出错则关闭套接字，关闭连接</span></span><br><span class="line">                    close (sockfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 现在的情况不是一个典型的反应堆或者说是事件驱动的类型，因为每当发一个flag之后，</span></span><br><span class="line">                <span class="comment">// 还需要紧接着发送一个信息或者激活一个业务，所以如果用非阻塞的，</span></span><br><span class="line">                <span class="comment">// 那紧跟着的信息或者业务应该怎么收，等多久收都不能确定，这需要同步，而不是靠循环，</span></span><br><span class="line">                <span class="comment">// 需要一个flag带动一系列的操作，如果用非阻塞的，发送信息的时候，可能都没法展示出来，</span></span><br><span class="line">                <span class="comment">// 因为紧跟着的业务并没有跟着一起运动起来，所以必须在这里改成阻塞的</span></span><br><span class="line">                <span class="comment">// 问题定位方法：sleep 5秒钟，本来客户端发信息时，服务端应该在5秒后才有反应，然而却是立马就接收到了</span></span><br><span class="line">                <span class="comment">// 如果不把非阻塞改为阻塞的话，信息会发送不到服务端</span></span><br><span class="line">                <span class="comment">// 这里可以其实可以一开始就直接不设置非阻，即把make_nonblock(sockfd);去掉</span></span><br><span class="line">                <span class="comment">// make_block(sockfd);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 符合要求，发送欢迎对方加入的信息</span></span><br><span class="line">                <span class="comment">// 这里其实可以多一个功能，就是验证密钥！这里不实现</span></span><br><span class="line">                send(sockfd, <span class="string">&quot;Welcome!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;Welcome!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 存储用户以及在线用户数量</span></span><br><span class="line">                users[sockfd].fd = sockfd;</span><br><span class="line">                <span class="built_in">strcpy</span>(users[sockfd].name, name);</span><br><span class="line">                users[sockfd].online = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 让程序自己根据 client端的选择执行流程的时候，尽量不要用字符串来 分析，</span></span><br><span class="line">                <span class="comment">// 而是应该用明确的数据，能够直接验证判断应该走哪个逻辑</span></span><br><span class="line">                <span class="comment">// 可以定义一个位掩码，此处定义位掩码</span></span><br><span class="line">                <span class="comment">// epoll的边缘模式跟水平模式</span></span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sockfd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印出用户成功从哪里登录，这个时候，用户已经被加入到epoll实例中</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogInSuccess&gt; : %s login on %s...\n&quot;</span>, name, inet_ntoa(client.sin_addr));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//do_use_fd(events[i].data.fd);</span></span><br><span class="line">                <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> rsize = <span class="number">0</span>, fd = events[i].data.fd;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client);</span><br><span class="line">                getpeername(fd, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">                <span class="comment">// 检测客户端是否有发信息过来，如果有，就接收并打印，如果没有就报错</span></span><br><span class="line">                <span class="comment">// flag指针类型记得修改</span></span><br><span class="line">                <span class="keyword">if</span> ((rsize = recv(fd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(flag), <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;&lt;LogOut&gt; : %s logout...\n&quot;</span>, inet_ntoa(client.sin_addr));</span><br><span class="line">                    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断对方发送的是什么信息</span></span><br><span class="line">                    <span class="keyword">if</span> (flag &amp; SEND) &#123;</span><br><span class="line">                        <span class="keyword">char</span> name[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, file_path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client send data...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 收取文件的大小信息</span></span><br><span class="line">                        <span class="keyword">ssize_t</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> ack = <span class="number">1</span>;</span><br><span class="line">                        recv(fd, (<span class="keyword">void</span> *)&amp;size, <span class="keyword">sizeof</span>(size), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 收取文件名字</span></span><br><span class="line">                        recv(fd, name, <span class="keyword">sizeof</span>(name), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 发送ack，方便同步</span></span><br><span class="line">                        send(fd, (<span class="keyword">char</span> *)&amp;ack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// 打印文件名字</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;filename = %s\n&quot;</span>, name);</span><br><span class="line">                        <span class="comment">// 打开一个文件，方便把收到的数据写进去</span></span><br><span class="line">                        <span class="comment">// 如果没有data文件夹，会显示不存在该文件夹</span></span><br><span class="line">                        <span class="comment">// 收到的文件，顺便以客户的名字命名</span></span><br><span class="line">                        <span class="built_in">sprintf</span>(file_path, <span class="string">&quot;./data/%s_%s&quot;</span>, users[fd].name, name);</span><br><span class="line">                        FILE *fp = fopen(file_path, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">                        <span class="comment">// 如果没有该判断，那可能会从一个null指针上打开一个文件流，就会产生段错误</span></span><br><span class="line">                        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                            perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 收数据</span></span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">ssize_t</span> tmp = recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 写文件</span></span><br><span class="line">                            fwrite(buff, <span class="number">1</span>, tmp, fp);</span><br><span class="line">                            sum += tmp;</span><br><span class="line">                            <span class="comment">// 文件收齐</span></span><br><span class="line">                            <span class="keyword">if</span> (sum &gt;= size) &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;File transfer finished!\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        fclose(fp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; RECV) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client want recv data...\n&quot;</span>);</span><br><span class="line">                        <span class="comment">// 开始不断发送文件</span></span><br><span class="line">                        <span class="comment">// 发送的目录也已经是写死了</span></span><br><span class="line">                        send_files(fd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; NORMAL) &#123;</span><br><span class="line">                        recv(fd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%s&gt; : %s\n&quot;</span>, users[fd].name, buff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h4 id="1-client-c-2"><a href="#1-client-c-2" class="headerlink" title="1.client.c"></a>1.client.c</h4><div class="spoiler collapsed">
    <div class="spoiler-title">
        代码演示
    </div>
    <div class="spoiler-content">
        <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cmd.h&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> sockfd, data_sock, data_listen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ByeBye!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最终文件名</span></span><br><span class="line"><span class="comment">// 可以写在一个函数中，返回一个字符串</span></span><br><span class="line"><span class="comment">// 或者把找到的东西放在传输参数中，变成这个函数的参数，这样就不用额外的空间，也不用return了</span></span><br><span class="line"><span class="comment">// 两种方式，这里选择传输参数的形式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_name</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果没找到，path就是name</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(name, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(name, ptr + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_file</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path_name[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(path_name, <span class="string">&quot;./recv/%s&quot;</span>, name);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">fd_t</span> = open(path_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">fd_t</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> num_recv = recv(fd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (num_recv &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="keyword">fd_t</span>, buffer, num_recv);</span><br><span class="line">    &#125;</span><br><span class="line">    close(<span class="keyword">fd_t</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, ip[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">20</span>] = <span class="string">&quot;alin&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage : %s ip port\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(ip, argv[<span class="number">1</span>]);</span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    signal(SIGINT, logout);</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket_connect(ip, port)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket_connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经连接上服务端，此时第一件事就是把名字发送给服务端</span></span><br><span class="line">    send(sockfd, name, <span class="built_in">strlen</span>(name), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收取服务端发送过来的确认信息，如果没有收到，报错。</span></span><br><span class="line">    <span class="keyword">if</span> (recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到服务端的确认信息，并打印出来</span></span><br><span class="line">    <span class="comment">// 不过这种接收，并不能保证一定连接上，只是说明服务端发送了信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;Server&gt; : %s\n&quot;</span>, buff);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// （方式二）客户端建立监听套接字，服务端反向连接</span></span><br><span class="line">        <span class="comment">// cmd用来收取命令</span></span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, cmd);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strlen</span>(cmd)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 字符串匹配指令</span></span><br><span class="line">        <span class="comment">// s a.txt 发送</span></span><br><span class="line">        <span class="comment">// r 收</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(cmd) == <span class="number">1</span> &amp;&amp; cmd[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">            flag |= RECV;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file_ack</span> <span class="title">ack</span>;</span></span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 接收文件</span></span><br><span class="line">            <span class="comment">// 不管有没有数据，都先 create listen socket for data connection</span></span><br><span class="line">            <span class="keyword">if</span> ((data_listen = socket_create(<span class="number">9003</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;socket_create&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// recv ack</span></span><br><span class="line">                recv(sockfd, (<span class="keyword">void</span> *)&amp;ack, <span class="keyword">sizeof</span>(ack), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// if ack == 1</span></span><br><span class="line">                <span class="comment">//     accept</span></span><br><span class="line">                <span class="comment">//     recv</span></span><br><span class="line">                <span class="comment">//     close</span></span><br><span class="line">                <span class="comment">//if ack == 0</span></span><br><span class="line">                <span class="comment">//     break</span></span><br><span class="line">                <span class="keyword">if</span> (ack.ack == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((data_sock = accept(data_listen, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果收到，说明连接建立成功，打印一下</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Server connection!\n&quot;</span>);</span><br><span class="line">                    recv_file(data_sock, ack.name);</span><br><span class="line">                    close(data_sock);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(data_listen);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// close data connection</span></span><br><span class="line">            <span class="comment">// close listen socket 对于客户端来说，也可以先不关</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Here recv!\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; cmd[<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取文件名</span></span><br><span class="line">            flag |= SEND;</span><br><span class="line">            <span class="keyword">int</span> ack = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">char</span> file[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;, buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;, name[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strcpy</span>(file, cmd + <span class="number">2</span>);</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;filename = %s\n&quot;</span>, file);</span><br><span class="line">            <span class="comment">// 获取文件大小</span></span><br><span class="line">            FILE *fp = fopen(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">                                <span class="comment">// 设置文件指针，使其指向末尾</span></span><br><span class="line">            fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">                <span class="comment">// 获取文件流的大小</span></span><br><span class="line">            <span class="keyword">ssize_t</span> size = ftell(fp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送文件大小</span></span><br><span class="line">            send(sockfd, (<span class="keyword">void</span> *)&amp;size, <span class="keyword">sizeof</span>(size), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 发送文件名 alin.jpg</span></span><br><span class="line">            get_name(file, name);</span><br><span class="line">            send(sockfd, (<span class="keyword">void</span> *)&amp;name, <span class="built_in">strlen</span>(name), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 接收服务端发送的ack,方便同步</span></span><br><span class="line">            recv(sockfd, (<span class="keyword">char</span> *)&amp;ack, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 两次recv 就不会出现黏包问题，可是逻辑上不应该有两次！</span></span><br><span class="line">            <span class="comment">// recv(sockfd, (char *)&amp;ack, sizeof(int), 0);</span></span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error in ACK!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">// 发送文件前先把文件指针移至开头，避免读不到内容</span></span><br><span class="line">            fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读文件</span></span><br><span class="line">                <span class="comment">// 每次从fd中读取一个，重复读1024次</span></span><br><span class="line">                <span class="keyword">int</span> rsize = fread(buffer, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line">                <span class="comment">// 这里通过单词返回值判断是否出错，来决定是否停止读取</span></span><br><span class="line">                <span class="comment">// 也可以通过累积量，因为size知道，通过累计，直到size的时候停止读取</span></span><br><span class="line">                <span class="keyword">if</span> (rsize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read success!...\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送文件给服务端</span></span><br><span class="line">                <span class="comment">// 可以先发一个文档，再发一张图片，来看看会不会出错</span></span><br><span class="line">                <span class="comment">// 发送的大小必须是rsize，不能是strlen(buffer)，不然会出现，要么图 片大小变小了，要么发送过长文章时，出现两次接收的情况</span></span><br><span class="line">                send(sockfd, buffer, rsize, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fclose(fp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// flag 标识好发送，给服务端发送过去，服务端收到之后，就会之后客户端准 备发信息</span></span><br><span class="line">            flag |= NORMAL;</span><br><span class="line">            send(sockfd, (<span class="keyword">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">            send(sockfd, cmd, <span class="built_in">strlen</span>(cmd), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="后续可以优化的方向："><a href="#后续可以优化的方向：" class="headerlink" title="后续可以优化的方向："></a>后续可以优化的方向：</h3><ol>
<li>响应慢，一旦多人下载，别人就只能被阻塞等待<ul>
<li>改进：加线程，或直接一步到位，加上线程池</li>
</ul>
</li>
<li>连接数过多的时候，可能会断开，出现太多的TIME_WAIT套接字，虽然过一会就会自动去除，但没消失之前，就会占用很多系统资源；而一旦连接数过多，就会导致系统的崩溃</li>
<li>目前发送数据的方式是基于同步的原理，即发送数据前，先约定好发送什么，说了发什么，就会发送什么，这种发送数据的方式可以是可以，就是效率低；现在有了分组网络，效率高很多，即发送的数据包每一个都是独立的，与其他数据包没有任何联系，吗，每个数据包，自己选择一条线路，只要最终可以到达目的地，并汇总起来就可以了。下载数据时，每个数据都是以4个block为标准，传输下载的。<ul>
<li>像这种方式，比较方便，不用管什么时候到</li>
</ul>
</li>
<li>问题：如果在应用层，把数据封装成一个又一个的结构体，假设编号从0到102，会不会出现这样的情况，对端在收到第99个结构体的时候，前面的某个结构体还没有到位，会不会出现这种情况？<ul>
<li>不会！因为默认底层是用tcp连接， 是可靠的传输协议，能够保证数据按顺序、正确有效的到达对方！</li>
</ul>
</li>
<li>运输层协议不会把数据按照你发的时候那样，一个包一个包的发给你，因为对TCP来说，无论是一个包还是什么，对它来说都是字节流，只要保证是字节流正确就行了，所以TCP无法感知到这些数据包哪个是哪个，而且TCP本身也不在乎，所以对端的应用层，应该自己把TCP交付的数据重组成一个，方便阅读解析。也正因为这样，所以才会出现拆包与粘包问题。</li>
<li>拆分成一个又一个数据包传输，有什么优势？<ul>
<li>运输层：最大的好处就是避免单点故障，避免一个位置出错就导致整个系统出错</li>
<li>应用层：TCP的输出缓冲区是有限制的，如果传输的数据过多，不拆分成一个又一个的数据包时，就会出现，缓冲区已经放满了，还要继续往里塞的情况，这种情况就是很不好的。</li>
<li>实际上，读取数据的时候，读多大合适，怎么读效率更高等，这些都是可以考虑的</li>
<li>问题：如果要从网络发送一个数据，这个数据存在磁盘上，请你详细的描述这个过程？<ul>
<li>因为要读取数据，所以需要先在用户空间上申请一个buffer，用来承载读到的数据；</li>
<li>如果没权限读取数据，就需要用到系统调用，这就意味着要内核帮忙做，而内核是无法随叫随到的，还得进行调度；这个时候，就是从用户态下沉到内核态，然后发现要读数据，所以加入排队，因为有很多应用程序要读IO（IO也是设备资源，意味着可能有优先级），读取出来后，还到不了buffer，而是到内核缓冲区，然后内核会告诉程序，数据到了，可以拿走了，这个时候数据就会被拷贝到用户空间，即从内核态上升到用户态，到了用户态，这个数据，要用send发送，send函数也是系统调用，也是要往一个文件写数据，写就是IO，IO权限都是你没有权限做的，如果哟i要写怎么办，系统调用send给shockfd，而buffer是在用户态，shockfd又是在内核态，所以又要下沉到内核态，然后才能写入，所以又要拷贝到内核态，而要send的文件，是一个外设，是一个网络设备，所以最终这个文件又得拷贝到shockfd的发送缓冲区，然后放到发送缓冲区里面，等着TCP协议把这个数据拷贝走，然后再传过去，这就是一整套的流程，这里面每一步都需要时间。所以，应该做到每收到一部分数据就处理，而不是收到所有数据才发送出去！</li>
</ul>
</li>
</ul>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Linux</category>
        <category>系统编程与网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
